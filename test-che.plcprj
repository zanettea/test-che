<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<plcProject LocalVarsFBAccess="false" PNContactsOnEachNetwork="false" SFCControl="false" autoDerefPointers="false" caseSensitive="false" copyWarningThreshold="200" customSortOfProjectTree="false" debugMode="false" extcheck="true" extendedIdNames="false" iecTypeConversionRules="false" strictEnumsCheck="false" strictInitValuesCheck="false" strictPointerCheck="false" useCustomWorkspace="true" useFBMethods="true" useLD2="true" useXPLCFiles="false" verboseWarningMode="false" version="2.11">
  <image>test-che.imgx</image>
  <commSettings>GDB:0,1000#TCPIP:10.0.0.86/5000</commSettings>
  <sources>
    <main>
			  <resources>
				    <resource name="RaspPI" processor="ARM32_VFP2">
					    <task descr="Fast task" dynamic="false" hidden="false" interval="t#10000us" name="Fast" priority="0" type="cyclic"/>
					    <task descr="Slow task" dynamic="false" hidden="false" interval="t#20000us" name="Slow" priority="1" type="cyclic"/>
					    <task descr="Background task" dynamic="false" hidden="false" interval="t#100000us" name="Background" priority="2" type="cyclic"/>
					    <task descr="Boot task" dynamic="false" hidden="false" interval="t#0us" name="Boot" priority="3" type="single"/>
					    <task descr="Init task" dynamic="false" hidden="false" interval="t#0us" name="Init" priority="4" type="single"/>
				</resource>
			</resources>
			  <tasks>
				    <task name="Fast">
					    <program>PidControl</program>
					    <program>PidModeSelector</program>
				</task>
				    <task name="Slow">
					    <program>Loops</program>
				</task>
				    <task name="Background">
					    <program>LadderLogic</program>
				</task>
				    <task name="Init">
					    <program>Init</program>
				</task>
			</tasks>
			  <globalVars>
				    <group excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" name="Counters_and_timers" version="1.0.0">
					    <var name="parCtDownPreset" type="UDINT">
						      <descr>Counter down preset</descr>
						      <initValue>100</initValue>
					</var>
					    <var name="parCtUpPreset" type="UDINT">
						      <descr>Counter up preset</descr>
						      <initValue>15</initValue>
					</var>
					    <var name="parPulseValue" type="UDINT">
						      <descr>Actual pulse time value</descr>
					</var>
					    <var name="parPulseWidth" type="UDINT">
						      <descr>Pulse width</descr>
						      <initValue>500</initValue>
					</var>
					    <var name="parTimOnDelay" type="UDINT">
						      <descr>Delay of the ON delay timer</descr>
						      <initValue>1000</initValue>
					</var>
					    <var name="parTimOnValue" type="UDINT">
						      <descr>Actual value of the timer</descr>
					</var>
				</group>
				    <group excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" name="PID" version="1.0.0">
					    <var name="pidKD" type="REAL">
						      <descr>PID derivative gain</descr>
					</var>
					    <var name="parPIDAutoPeriod" type="UDINT">
						      <initValue>2000</initValue>
					</var>
					    <var name="parPIDMode" type="INT"/>
					    <var name="parPIDSetpoint" type="REAL">
						      <descr>PID setpoint from HMI</descr>
					</var>
					    <var name="parPIDThreshold" type="REAL">
						      <initValue>0.2</initValue>
					</var>
					    <var name="hmiPIDThreshold" type="REAL"/>
					    <var name="pidFeedback" type="REAL">
						      <descr>PID feedback input</descr>
					</var>
					    <var name="pidOutput" type="REAL">
						      <descr>PID output value</descr>
					</var>
					    <var name="pidSetpoint" type="REAL">
						      <descr>PID setpoint (from -1 to +1)</descr>
					</var>
					    <var name="pidKI" type="REAL">
						      <descr>PID integral time</descr>
						      <initValue>0.1</initValue>
					</var>
					    <var name="pidKP" type="REAL">
						      <descr>PID proportional gain</descr>
						      <initValue>0.5</initValue>
					</var>
				</group>
				    <group excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" name="IO" version="1.0.0">
					    <var name="inpLogicData" type="BOOL"/>
					    <var name="inpLogicReset" type="BOOL"/>
					    <var name="inpZeroSetpoint" type="BOOL"/>
					    <var name="inpAnalogSetpoint" type="BOOL"/>
					    <var name="inpPidReset" type="BOOL"/>
					    <var name="outPulse" type="BOOL"/>
					    <var name="outDelayed" type="BOOL"/>
					    <var name="outCountUp" type="BOOL"/>
					    <var name="outCountDown" type="BOOL"/>
					    <var name="outPidOk" type="BOOL"/>
					    <var name="outPidOverShoot" type="BOOL"/>
					    <var name="outPidOverflow" type="BOOL"/>
					    <var name="aiSetpoint" type="INT"/>
					    <var name="aoCtDownValue" type="UDINT"/>
					    <var name="aoCtUpValue" type="UDINT"/>
					    <var name="aoActuator" type="INT"/>
					    <var name="aoSystemResponse" type="INT"/>
					    <var name="inpAutomatic" type="BOOL"/>
				</group>
				    <group excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" name="Ungrouped_vars" version="1.0.0">
					    <var name="parPidTest" type="BOOL">
						      <descr>Starts execution of PID test</descr>
					</var>
					    <var name="hmiPidTest" type="BOOL">
						      <descr>Starts execution of PID test</descr>
					</var>
					    <var name="loopsValue" type="WORD"/>
					    <var name="runLoops" type="BOOL">
						      <initValue>true</initValue>
					</var>
				</group>
			</globalVars>
			  <retainVars/>
			  <constantVars/>
			  <iecVarsDeclaration>
				    <group name="Counters_and_timers">
					    <iecDeclaration active="FALSE"/>
				</group>
				    <group name="PID">
					    <iecDeclaration active="FALSE"/>
				</group>
				    <group name="IO">
					    <iecDeclaration active="FALSE"/>
				</group>
				    <group name="Ungrouped_vars">
					    <iecDeclaration active="FALSE"/>
				</group>
			</iecVarsDeclaration>
			  <functions>
				    <function creationDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="0" name="RotateBit" version="1.0.0">
					    <returnValue>WORD</returnValue>
					    <vars>
						      <inputVars>
							      <var name="i" type="UINT"/>
						</inputVars>
						      <localVars>
							      <var name="shift" type="WORD"/>
						</localVars>
					</vars>
					    <iecDeclaration active="FALSE"/>
					    <sourceCode type="ST">
						<![CDATA[(*		
	rotazione del bit i-esimo per ottenere la sequenza:
	0 2 4 6    1 3 5 7    8 10 12 14    9 11 13 15
	
	if i <= 3 then
		shift := (i- 0) * 2 + 0 + 0;
	elsif i <= 7 then
		shift := (i- 4) * 2 + 0 + 1;
	elsif i <= 11 then
		shift := (i- 8) * 2 + 8 + 0;
	else 
		shift := (i-12) * 2 + 8 + 1;
	end_if;
*)


	shift := (i MOD 4) * 2 + (i - i MOD 8) + (i MOD 8) / 4;
	
	RotateBit := SHL(UINT#1, shift);
]]>
					</sourceCode>
				</function>
			</functions>
			  <functionBlocks>
				    <functionBlock creationDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="0" name="LowPassFilter" version="1.0.0">
					    <vars>
						      <inputVars>
							      <var name="in" type="REAL"/>
							      <var name="k" type="REAL"/>
						</inputVars>
						      <outputVars>
							      <var name="out" type="REAL"/>
						</outputVars>
					</vars>
					    <iecDeclaration active="FALSE"/>
					    <interfaces/>
					    <methods/>
					    <sourceCode type="ST">
						<![CDATA[

	out := k * ( in - out ) + out;
	

]]>
					</sourceCode>
				</functionBlock>
			</functionBlocks>
			  <programs>
				    <program creationDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="1624954980" name="PidControl" version="1.0.0">
					    <vars>
						      <localVars>
							      <var name="fbPid" type="FT_PID"/>
							      <var name="lpf" type="LowPassFilter"/>
						</localVars>
					</vars>
					    <iecDeclaration active="FALSE"/>
					    <sourceCode type="FBD">
						      <FBD>
							      <network disableCondition="" disabled="false" error="false" height="22" order="N:1" width="200">
								        <conn error="false" id="C:0">
									        <segment xEnd="21" xStart="20" yEnd="9" yStart="9"/>
									        <startPin>FB:fbPid.overflow</startPin>
									        <endPin>V:6</endPin>
								</conn>
								        <conn error="false" id="C:1">
									        <segment xEnd="22" xStart="20" yEnd="6" yStart="6"/>
									        <startPin>FB:fbPid.y</startPin>
									        <endPin>V:7</endPin>
								</conn>
								        <conn error="false" id="C:2">
									        <segment xEnd="45" xStart="45" yEnd="7" yStart="7"/>
									        <startPin>O:13.2</startPin>
									        <endPin>V:10</endPin>
								</conn>
								        <conn error="false" id="C:3">
									        <segment xEnd="40" xStart="33" yEnd="7" yStart="7"/>
									        <startPin>F:1.#O</startPin>
									        <endPin>O:13.0</endPin>
								</conn>
								        <conn error="false" id="C:4">
									        <segment xEnd="28" xStart="20" yEnd="7" yStart="7"/>
									        <startPin>FB:fbPid.diff</startPin>
									        <endPin>F:1.#0</endPin>
								</conn>
								        <conn error="false" id="C:5">
									        <segment xEnd="40" xStart="40" yEnd="8" yStart="8"/>
									        <startPin>V:11</startPin>
									        <endPin>O:13.1</endPin>
								</conn>
								        <conn error="false" id="C:6">
									        <segment xEnd="8" xStart="9" yEnd="6" yStart="6"/>
									        <startPin>FB:fbPid.actual</startPin>
									        <endPin>V:8</endPin>
								</conn>
								        <conn error="false" id="C:7">
									        <segment xEnd="8" xStart="9" yEnd="7" yStart="7"/>
									        <startPin>FB:fbPid.set_point</startPin>
									        <endPin>V:4</endPin>
								</conn>
								        <conn error="false" id="C:8">
									        <segment xEnd="8" xStart="9" yEnd="12" yStart="12"/>
									        <startPin>FB:fbPid.rst</startPin>
									        <endPin>V:5</endPin>
								</conn>
								        <conn error="false" id="C:9">
									        <segment xEnd="7" xStart="9" yEnd="13" yStart="13"/>
									        <startPin>FB:fbPid.int_band</startPin>
									        <endPin>K:12</endPin>
								</conn>
								        <conn error="false" id="C:10">
									        <segment xEnd="7" xStart="9" yEnd="14" yStart="14"/>
									        <startPin>FB:fbPid.KP</startPin>
									        <endPin>V:3</endPin>
								</conn>
								        <conn error="false" id="C:11">
									        <segment xEnd="6" xStart="9" yEnd="15" yStart="15"/>
									        <startPin>FB:fbPid.TN</startPin>
									        <endPin>V:2</endPin>
								</conn>
								        <conn error="false" id="C:12">
									        <segment xEnd="7" xStart="9" yEnd="16" yStart="16"/>
									        <startPin>FB:fbPid.TV</startPin>
									        <endPin>V:9</endPin>
								</conn>
								        <comment error="false" id="CO:0" x="12" y="1">PID regulator</comment>
								        <comment error="false" id="CO:0" x="35" y="3">PID regulation is OK if target is inside threshold</comment>
								        <const error="false" id="K:12" name="1000.0" x="7" y="13">
									        <pin>C:9</pin>
								</const>
								        <var error="false" id="V:2" name="pidKI" type="Input" x="6" y="15">
									        <pin>C:11</pin>
								</var>
								        <var error="false" id="V:3" name="pidKP" type="Input" x="7" y="14">
									        <pin>C:10</pin>
								</var>
								        <var error="false" id="V:4" name="pidSetpoint" type="Input" x="8" y="7">
									        <pin>C:7</pin>
								</var>
								        <var error="false" id="V:5" name="inpPidReset" type="Input" x="8" y="12">
									        <pin>C:8</pin>
								</var>
								        <var error="false" id="V:6" name="outPidOverflow" type="Output" x="21" y="9">
									        <pin>C:0</pin>
								</var>
								        <var error="false" id="V:7" name="pidOutput" type="Output" x="22" y="6">
									        <pin>C:1</pin>
								</var>
								        <var error="false" id="V:8" name="pidFeedback" type="Input" x="8" y="6">
									        <pin>C:6</pin>
								</var>
								        <var error="false" id="V:9" name="pidKD" type="Input" x="7" y="16">
									        <pin>C:12</pin>
								</var>
								        <var error="false" id="V:10" name="outPidOk" type="Output" x="45" y="7">
									        <pin>C:2</pin>
								</var>
								        <var error="false" id="V:11" name="hmiPIDThreshold" type="Input" x="40" y="8">
									        <pin>C:5</pin>
								</var>
								        <op error="false" id="O:13" name="LE" width="5" x="40" y="7">
									        <inputPin name="0" negated="false">C:3</inputPin>
									        <inputPin name="1" negated="false">C:5</inputPin>
									        <outputPin name="2" negated="false">C:2</outputPin>
								</op>
								        <fun error="false" id="F:1" name="ABS" width="5" x="28" y="7">
									        <inputPin name="#0" negated="false">C:4</inputPin>
									        <outputPin name="#O" negated="false">C:3</outputPin>
								</fun>
								        <funBlock error="false" id="FB:fbPid" imgheight="100" imgwidth="75" name="FT_PID" width="11" x="9" y="6">
									        <inputPin name="actual" negated="false">C:6</inputPin>
									        <inputPin name="set_point" negated="false">C:7</inputPin>
									        <inputPin name="noise" negated="false"/>
									        <inputPin name="offset" negated="false"/>
									        <inputPin name="manual_in" negated="false"/>
									        <inputPin name="manual" negated="false"/>
									        <inputPin name="rst" negated="false">C:8</inputPin>
									        <inputPin name="int_band" negated="false">C:9</inputPin>
									        <inputPin name="KP" negated="false">C:10</inputPin>
									        <inputPin name="TN" negated="false">C:11</inputPin>
									        <inputPin name="TV" negated="false">C:12</inputPin>
									        <inputPin name="limit_L" negated="false"/>
									        <inputPin name="limit_H" negated="false"/>
									        <outputPin name="y" negated="false">C:1</outputPin>
									        <outputPin name="diff" negated="false">C:4</outputPin>
									        <outputPin name="lim" negated="false"/>
									        <outputPin name="overflow" negated="false">C:0</outputPin>
								</funBlock>
							</network>
							      <network disableCondition="" disabled="false" error="false" height="11" order="N:2" width="200">
								        <conn error="false" id="C:0">
									        <segment xEnd="9" xStart="8" yEnd="7" yStart="7"/>
									        <startPin>V:1</startPin>
									        <endPin>FB:lpf.in</endPin>
								</conn>
								        <conn error="false" id="C:1">
									        <segment xEnd="16" xStart="15" yEnd="7" yStart="7"/>
									        <startPin>FB:lpf.out</startPin>
									        <endPin>V:2</endPin>
								</conn>
								        <conn error="false" id="C:2">
									        <segment xEnd="9" xStart="6" yEnd="8" yStart="8"/>
									        <startPin>K:3</startPin>
									        <endPin>FB:lpf.k</endPin>
								</conn>
								        <comment error="false" id="CO:0" x="5" y="1">System response simulation using a low pass filter
on the output</comment>
								        <const error="false" id="K:3" name="0.05" x="6" y="8">
									        <pin>C:2</pin>
								</const>
								        <var error="false" id="V:1" name="pidOutput" type="Input" x="8" y="7">
									        <pin>C:0</pin>
								</var>
								        <var error="false" id="V:2" name="pidFeedback" type="Output" x="16" y="7">
									        <pin>C:1</pin>
								</var>
								        <funBlock error="false" id="FB:lpf" name="LowPassFilter" width="6" x="9" y="7">
									        <inputPin name="in" negated="false">C:0</inputPin>
									        <inputPin name="k" negated="false">C:2</inputPin>
									        <outputPin name="out" negated="false">C:1</outputPin>
								</funBlock>
							</network>
							      <network disableCondition="" disabled="false" error="false" height="12" order="N:3" width="200">
								        <conn error="false" id="C:0">
									        <segment xEnd="9" xStart="8" yEnd="6" yStart="6"/>
									        <startPin>V:2</startPin>
									        <endPin>O:1.0</endPin>
								</conn>
								        <conn error="false" id="C:1">
									        <segment xEnd="9" xStart="7" yEnd="7" yStart="7"/>
									        <startPin>K:3</startPin>
									        <endPin>O:1.1</endPin>
								</conn>
								        <conn error="false" id="C:2">
									        <segment xEnd="35" xStart="34" yEnd="6" yStart="6"/>
									        <startPin>F:5.#O</startPin>
									        <endPin>V:4</endPin>
								</conn>
								        <conn error="false" id="C:3">
									        <segment xEnd="23" xStart="14" yEnd="6" yStart="6"/>
									        <startPin>O:1.2</startPin>
									        <endPin>F:7.IN</endPin>
								</conn>
								        <conn error="false" id="C:4">
									        <segment xEnd="29" xStart="28" yEnd="6" yStart="6"/>
									        <startPin>F:7.#O</startPin>
									        <endPin>F:5.#0</endPin>
								</conn>
								        <conn error="false" id="C:5">
									        <segment xEnd="23" xStart="22" yEnd="7" yStart="7"/>
									        <startPin>K:8</startPin>
									        <endPin>F:7.MN</endPin>
								</conn>
								        <conn error="false" id="C:6">
									        <segment xEnd="23" xStart="21" yEnd="8" yStart="8"/>
									        <startPin>K:9</startPin>
									        <endPin>F:7.MX</endPin>
								</conn>
								        <comment error="false" id="CO:0" x="7" y="1">Scaling to analog output</comment>
								        <const error="false" id="K:3" name="102.4" x="7" y="7">
									        <pin>C:1</pin>
								</const>
								        <const error="false" id="K:8" name="-1024.0" x="22" y="7">
									        <pin>C:5</pin>
								</const>
								        <const error="false" id="K:9" name="1023.0" x="21" y="8">
									        <pin>C:6</pin>
								</const>
								        <var error="false" id="V:2" name="pidOutput" type="Input" x="8" y="6">
									        <pin>C:0</pin>
								</var>
								        <var error="false" id="V:4" name="aoActuator" type="Output" x="35" y="6">
									        <pin>C:2</pin>
								</var>
								        <op error="false" id="O:1" name="MUL" width="5" x="9" y="6">
									        <inputPin name="0" negated="false">C:0</inputPin>
									        <inputPin name="1" negated="false">C:1</inputPin>
									        <outputPin name="2" negated="false">C:3</outputPin>
								</op>
								        <fun error="false" id="F:5" name="TO_INT" width="5" x="29" y="6">
									        <inputPin name="#0" negated="false">C:4</inputPin>
									        <outputPin name="#O" negated="false">C:2</outputPin>
								</fun>
								        <fun error="false" id="F:7" name="LIMIT" width="5" x="23" y="6">
									        <inputPin name="IN" negated="false">C:3</inputPin>
									        <inputPin name="MN" negated="false">C:5</inputPin>
									        <inputPin name="MX" negated="false">C:6</inputPin>
									        <outputPin name="#O" negated="false">C:4</outputPin>
								</fun>
							</network>
							      <network disableCondition="" disabled="false" error="false" height="12" order="N:4" width="200">
								        <conn error="false" id="C:0">
									        <segment xEnd="9" xStart="8" yEnd="6" yStart="6"/>
									        <startPin>V:2</startPin>
									        <endPin>O:1.0</endPin>
								</conn>
								        <conn error="false" id="C:1">
									        <segment xEnd="9" xStart="7" yEnd="7" yStart="7"/>
									        <startPin>K:3</startPin>
									        <endPin>O:1.1</endPin>
								</conn>
								        <conn error="false" id="C:2">
									        <segment xEnd="35" xStart="34" yEnd="6" yStart="6"/>
									        <startPin>F:5.#O</startPin>
									        <endPin>V:4</endPin>
								</conn>
								        <conn error="false" id="C:3">
									        <segment xEnd="23" xStart="14" yEnd="6" yStart="6"/>
									        <startPin>O:1.2</startPin>
									        <endPin>F:7.IN</endPin>
								</conn>
								        <conn error="false" id="C:4">
									        <segment xEnd="29" xStart="28" yEnd="6" yStart="6"/>
									        <startPin>F:7.#O</startPin>
									        <endPin>F:5.#0</endPin>
								</conn>
								        <conn error="false" id="C:5">
									        <segment xEnd="23" xStart="22" yEnd="7" yStart="7"/>
									        <startPin>K:8</startPin>
									        <endPin>F:7.MN</endPin>
								</conn>
								        <conn error="false" id="C:6">
									        <segment xEnd="23" xStart="21" yEnd="8" yStart="8"/>
									        <startPin>K:9</startPin>
									        <endPin>F:7.MX</endPin>
								</conn>
								        <comment error="false" id="CO:0" x="7" y="1">Scaling to analog output</comment>
								        <const error="false" id="K:3" name="102.4" x="7" y="7">
									        <pin>C:1</pin>
								</const>
								        <const error="false" id="K:8" name="-1024.0" x="22" y="7">
									        <pin>C:5</pin>
								</const>
								        <const error="false" id="K:9" name="1023.0" x="21" y="8">
									        <pin>C:6</pin>
								</const>
								        <var error="false" id="V:2" name="pidFeedback" type="Input" x="8" y="6">
									        <pin>C:0</pin>
								</var>
								        <var error="false" id="V:4" name="aoSystemResponse" type="Output" x="35" y="6">
									        <pin>C:2</pin>
								</var>
								        <op error="false" id="O:1" name="MUL" width="5" x="9" y="6">
									        <inputPin name="0" negated="false">C:0</inputPin>
									        <inputPin name="1" negated="false">C:1</inputPin>
									        <outputPin name="2" negated="false">C:3</outputPin>
								</op>
								        <fun error="false" id="F:5" name="TO_INT" width="5" x="29" y="6">
									        <inputPin name="#0" negated="false">C:4</inputPin>
									        <outputPin name="#O" negated="false">C:2</outputPin>
								</fun>
								        <fun error="false" id="F:7" name="LIMIT" width="5" x="23" y="6">
									        <inputPin name="IN" negated="false">C:3</inputPin>
									        <inputPin name="MN" negated="false">C:5</inputPin>
									        <inputPin name="MX" negated="false">C:6</inputPin>
									        <outputPin name="#O" negated="false">C:4</outputPin>
								</fun>
							</network>
							      <network disableCondition="" disabled="false" error="false" height="22" order="N:5" width="200">
								        <conn error="false" id="C:9">
									        <segment xEnd="10" xStart="10" yEnd="10" yStart="7"/>
									        <startPin>I:0</startPin>
									        <endPin>I:1</endPin>
								</conn>
								        <conn error="false" id="C:0">
									        <segment xEnd="10" xStart="8" yEnd="7" yStart="7"/>
									        <startPin>V:2</startPin>
									        <endPin>I:0</endPin>
								</conn>
								        <conn error="false" id="C:8">
									        <segment xEnd="16" xStart="10" yEnd="7" yStart="7"/>
									        <startPin>I:0</startPin>
									        <endPin>O:4.1</endPin>
								</conn>
								        <conn error="false" id="C:10">
									        <segment xEnd="10" xStart="10" yEnd="15" yStart="10"/>
									        <startPin>I:1</startPin>
									        <endPin>I:2</endPin>
								</conn>
								        <conn error="false" id="C:11">
									        <segment xEnd="16" xStart="10" yEnd="10" yStart="10"/>
									        <startPin>I:1</startPin>
									        <endPin>O:6.0</endPin>
								</conn>
								        <conn error="false" id="C:12">
									        <segment xEnd="10" xStart="10" yEnd="18" yStart="15"/>
									        <segment xEnd="16" yEnd="18"/>
									        <startPin>I:2</startPin>
									        <endPin>O:11.0</endPin>
								</conn>
								        <conn error="false" id="C:13">
									        <segment xEnd="16" xStart="10" yEnd="15" yStart="15"/>
									        <startPin>I:2</startPin>
									        <endPin>O:12.1</endPin>
								</conn>
								        <cross error="false" id="I:0" x="10" y="7">
									        <top/>
									        <bottom>C:9</bottom>
									        <right>C:8</right>
									        <left>C:0</left>
								</cross>
								        <cross error="false" id="I:1" x="10" y="10">
									        <top>C:9</top>
									        <bottom>C:10</bottom>
									        <right>C:11</right>
									        <left/>
								</cross>
								        <cross error="false" id="I:2" x="10" y="15">
									        <top>C:10</top>
									        <bottom>C:12</bottom>
									        <right>C:13</right>
									        <left/>
								</cross>
								        <conn error="false" id="C:15">
									        <segment xEnd="9" xStart="9" yEnd="14" yStart="6"/>
									        <segment xEnd="16" yEnd="14"/>
									        <startPin>I:3</startPin>
									        <endPin>O:12.0</endPin>
								</conn>
								        <conn error="false" id="C:7">
									        <segment xEnd="9" xStart="8" yEnd="6" yStart="6"/>
									        <startPin>V:1</startPin>
									        <endPin>I:3</endPin>
								</conn>
								        <conn error="false" id="C:14">
									        <segment xEnd="16" xStart="9" yEnd="6" yStart="6"/>
									        <startPin>I:3</startPin>
									        <endPin>O:4.0</endPin>
								</conn>
								        <cross error="false" id="I:3" x="9" y="6">
									        <top/>
									        <bottom>C:15</bottom>
									        <right>C:14</right>
									        <left>C:7</left>
								</cross>
								        <conn error="false" id="C:1">
									        <segment xEnd="16" xStart="16" yEnd="11" yStart="11"/>
									        <startPin>K:7</startPin>
									        <endPin>O:6.1</endPin>
								</conn>
								        <conn error="false" id="C:2">
									        <segment xEnd="22" xStart="21" yEnd="6" yStart="6"/>
									        <segment xEnd="22" yEnd="9"/>
									        <segment xEnd="25" yEnd="9"/>
									        <startPin>O:4.2</startPin>
									        <endPin>O:8.0</endPin>
								</conn>
								        <conn error="false" id="C:3">
									        <segment xEnd="25" xStart="21" yEnd="10" yStart="10"/>
									        <startPin>O:6.2</startPin>
									        <endPin>O:8.1</endPin>
								</conn>
								        <conn error="false" id="C:4">
									        <segment xEnd="25" xStart="21" yEnd="14" yStart="14"/>
									        <startPin>O:12.2</startPin>
									        <endPin>O:10.0</endPin>
								</conn>
								        <conn error="false" id="C:5">
									        <segment xEnd="22" xStart="21" yEnd="18" yStart="18"/>
									        <segment xEnd="22" yEnd="15"/>
									        <segment xEnd="25" yEnd="15"/>
									        <startPin>O:11.2</startPin>
									        <endPin>O:10.1</endPin>
								</conn>
								        <conn error="false" id="C:6">
									        <segment xEnd="16" xStart="16" yEnd="19" yStart="19"/>
									        <startPin>K:9</startPin>
									        <endPin>O:11.1</endPin>
								</conn>
								        <conn error="false" id="C:16">
									        <segment xEnd="33" xStart="30" yEnd="9" yStart="9"/>
									        <startPin>O:8.2</startPin>
									        <endPin>O:13.0</endPin>
								</conn>
								        <conn error="false" id="C:17">
									        <segment xEnd="32" xStart="30" yEnd="14" yStart="14"/>
									        <segment xEnd="32" yEnd="10"/>
									        <segment xEnd="33" yEnd="10"/>
									        <startPin>O:10.2</startPin>
									        <endPin>O:13.1</endPin>
								</conn>
								        <conn error="false" id="C:18">
									        <segment xEnd="39" xStart="38" yEnd="9" yStart="9"/>
									        <startPin>O:13.2</startPin>
									        <endPin>V:3</endPin>
								</conn>
								        <comment error="false" id="CO:0" x="7" y="1">Detection of PID overshoots</comment>
								        <const error="false" id="K:7" name="0.0" x="16" y="11">
									        <pin>C:1</pin>
								</const>
								        <const error="false" id="K:9" name="0.0" x="16" y="19">
									        <pin>C:6</pin>
								</const>
								        <var error="false" id="V:1" name="pidFeedback" type="Input" x="8" y="6">
									        <pin>C:7</pin>
								</var>
								        <var error="false" id="V:2" name="pidSetpoint" type="Input" x="8" y="7">
									        <pin>C:0</pin>
								</var>
								        <var error="false" id="V:3" name="outPidOverShoot" type="Output" x="39" y="9">
									        <pin>C:18</pin>
								</var>
								        <op error="false" id="O:4" name="GT" width="5" x="16" y="6">
									        <inputPin name="0" negated="false">C:14</inputPin>
									        <inputPin name="1" negated="false">C:8</inputPin>
									        <outputPin name="2" negated="false">C:2</outputPin>
								</op>
								        <op error="false" id="O:6" name="GE" width="5" x="16" y="10">
									        <inputPin name="0" negated="false">C:11</inputPin>
									        <inputPin name="1" negated="false">C:1</inputPin>
									        <outputPin name="2" negated="false">C:3</outputPin>
								</op>
								        <op error="false" id="O:8" name="AND" width="5" x="25" y="9">
									        <inputPin name="0" negated="false">C:2</inputPin>
									        <inputPin name="1" negated="false">C:3</inputPin>
									        <outputPin name="2" negated="false">C:16</outputPin>
								</op>
								        <op error="false" id="O:10" name="AND" width="5" x="25" y="14">
									        <inputPin name="0" negated="false">C:4</inputPin>
									        <inputPin name="1" negated="false">C:5</inputPin>
									        <outputPin name="2" negated="false">C:17</outputPin>
								</op>
								        <op error="false" id="O:11" name="LT" width="5" x="16" y="18">
									        <inputPin name="0" negated="false">C:12</inputPin>
									        <inputPin name="1" negated="false">C:6</inputPin>
									        <outputPin name="2" negated="false">C:5</outputPin>
								</op>
								        <op error="false" id="O:12" name="LT" width="5" x="16" y="14">
									        <inputPin name="0" negated="false">C:15</inputPin>
									        <inputPin name="1" negated="false">C:13</inputPin>
									        <outputPin name="2" negated="false">C:4</outputPin>
								</op>
								        <op error="false" id="O:13" name="OR" width="5" x="33" y="9">
									        <inputPin name="0" negated="false">C:16</inputPin>
									        <inputPin name="1" negated="false">C:17</inputPin>
									        <outputPin name="2" negated="false">C:18</outputPin>
								</op>
							</network>
						</FBD>
					</sourceCode>
				</program>
				    <program creationDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="0" name="PidModeSelector" version="1.0.0">
					    <vars>
						      <localVars>
							      <var name="end_Analog" type="BOOL">
								        <descr>Transition result</descr>
							</var>
							      <var name="actualTime" type="UDINT"/>
							      <var name="end_Automatic" type="BOOL">
								        <descr>Transition result</descr>
							</var>
							      <var name="end_AutoPhase0" type="BOOL">
								        <descr>Transition result</descr>
							</var>
							      <var name="end_AutoPhase1" type="BOOL">
								        <descr>Transition result</descr>
							</var>
							      <var name="baseTime" type="UDINT"/>
							      <var name="end_Zero" type="BOOL">
								        <descr>Transition result</descr>
							</var>
						</localVars>
					</vars>
					    <iecDeclaration active="FALSE"/>
					    <sourceCode type="SFC">
						      <SFC>
							      <network error="false" height="34" order="N:1" width="200">
								        <conn error="false" id="C:0">
									        <segment xEnd="5" xStart="5" yEnd="5" yStart="5"/>
									        <startPin>ACT:Init.O1</startPin>
									        <endPin>TR:5.I0</endPin>
								</conn>
								        <conn error="false" id="C:1">
									        <segment xEnd="5" xStart="5" yEnd="8" yStart="8"/>
									        <startPin>TR:5.O1</startPin>
									        <endPin>ACT:Zero_setpoint.I0</endPin>
								</conn>
								        <conn error="false" id="C:2">
									        <segment xEnd="15" xStart="15" yEnd="8" yStart="8"/>
									        <startPin>TR:5.O2</startPin>
									        <endPin>ACT:Analog_setpoint.I0</endPin>
								</conn>
								        <conn error="false" id="C:3">
									        <segment xEnd="25" xStart="25" yEnd="8" yStart="8"/>
									        <startPin>TR:5.O3</startPin>
									        <endPin>ACT:Auto_Phase_0.I0</endPin>
								</conn>
								        <conn error="false" id="C:4">
									        <segment xEnd="25" xStart="25" yEnd="13" yStart="13"/>
									        <startPin>ACT:Auto_Phase_0.O1</startPin>
									        <endPin>TR:6.I0</endPin>
								</conn>
								        <conn error="false" id="C:5">
									        <segment xEnd="25" xStart="25" yEnd="16" yStart="16"/>
									        <startPin>TR:6.O1</startPin>
									        <endPin>ACT:Auto_Phase_1.I0</endPin>
								</conn>
								        <conn error="false" id="C:6">
									        <segment xEnd="25" xStart="25" yEnd="21" yStart="21"/>
									        <startPin>ACT:Auto_Phase_1.O1</startPin>
									        <endPin>TR:7.I0</endPin>
								</conn>
								        <conn error="false" id="C:7">
									        <segment xEnd="15" xStart="15" yEnd="13" yStart="13"/>
									        <startPin>ACT:Analog_setpoint.O1</startPin>
									        <endPin>TR:8.I0</endPin>
								</conn>
								        <conn error="false" id="C:8">
									        <segment xEnd="5" xStart="5" yEnd="13" yStart="13"/>
									        <startPin>ACT:Zero_setpoint.O1</startPin>
									        <endPin>TR:9.I0</endPin>
								</conn>
								        <conn error="false" id="C:9">
									        <segment xEnd="5" xStart="5" yEnd="16" yStart="16"/>
									        <startPin>TR:9.O1</startPin>
									        <endPin>J:10</endPin>
								</conn>
								        <conn error="false" id="C:10">
									        <segment xEnd="15" xStart="15" yEnd="16" yStart="16"/>
									        <startPin>TR:8.O1</startPin>
									        <endPin>J:11</endPin>
								</conn>
								        <conn error="false" id="C:11">
									        <segment xEnd="35" xStart="35" yEnd="24" yStart="24"/>
									        <startPin>TR:7.O2</startPin>
									        <endPin>J:12</endPin>
								</conn>
								        <conn error="false" id="C:12">
									        <segment xEnd="25" xStart="25" yEnd="24" yStart="24"/>
									        <startPin>TR:7.O1</startPin>
									        <endPin>J:13</endPin>
								</conn>
								        <step error="false" id="ACT:Init" type="Init" x="5" y="0">
									        <pin name="O1" type="Output">C:0</pin>
									        <action name="Idle" type="N"/>
								</step>
								        <step error="false" id="ACT:Zero_setpoint" type="Normal" x="5" y="8">
									        <pin name="I0" type="Input">C:1</pin>
									        <pin name="O1" type="Output">C:8</pin>
									        <action name="ManualMode" type="N"/>
								</step>
								        <step error="false" id="ACT:Analog_setpoint" type="Normal" x="15" y="8">
									        <pin name="I0" type="Input">C:2</pin>
									        <pin name="O1" type="Output">C:7</pin>
									        <action name="AnalogInputMode" type="N"/>
								</step>
								        <step error="false" id="ACT:Auto_Phase_0" type="Normal" x="25" y="8">
									        <pin name="I0" type="Input">C:3</pin>
									        <pin name="O1" type="Output">C:4</pin>
									        <action name="SetPoint10Negative" type="N"/>
									        <action name="AutoModeInit" type="P"/>
								</step>
								        <step error="false" id="ACT:Auto_Phase_1" type="Normal" x="25" y="16">
									        <pin name="I0" type="Input">C:5</pin>
									        <pin name="O1" type="Output">C:6</pin>
									        <action name="SetPoint10Positive" type="N"/>
								</step>
								        <transition error="false" id="TR:5" type="Div" x="5" y="5">
									        <pin name="I0" type="Input" xPos="5">C:0</pin>
									        <pin name="O1" type="Output" xPos="5">
										          <condition code="false" hidden="false" name="inpZeroSetpoint">C:1</condition>
									</pin>
									        <pin name="O2" type="Output" xPos="15">
										          <condition code="false" hidden="false" name="inpAnalogSetpoint">C:2</condition>
									</pin>
									        <pin name="O3" type="Output" xPos="25">
										          <condition code="false" hidden="false" name="inpAutomatic">C:3</condition>
									</pin>
								</transition>
								        <transition error="false" id="TR:6" type="Normal" x="25" y="13">
									        <pin name="I0" type="Input" xPos="25">
										          <condition code="true" hidden="false" name="end_AutoPhase0">C:4</condition>
									</pin>
									        <pin name="O1" type="Output" xPos="25">C:5</pin>
								</transition>
								        <transition error="false" id="TR:7" type="Div" x="25" y="21">
									        <pin name="I0" type="Input" xPos="25">C:6</pin>
									        <pin name="O1" type="Output" xPos="25">
										          <condition code="true" hidden="false" name="end_AutoPhase1">C:12</condition>
									</pin>
									        <pin name="O2" type="Output" xPos="35">
										          <condition code="true" hidden="false" name="end_Automatic">C:11</condition>
									</pin>
								</transition>
								        <transition error="false" id="TR:8" type="Normal" x="15" y="13">
									        <pin name="I0" type="Input" xPos="15">
										          <condition code="true" hidden="false" name="end_Analog">C:7</condition>
									</pin>
									        <pin name="O1" type="Output" xPos="15">C:10</pin>
								</transition>
								        <transition error="false" id="TR:9" type="Normal" x="5" y="13">
									        <pin name="I0" type="Input" xPos="5">
										          <condition code="true" hidden="false" name="end_Zero">C:8</condition>
									</pin>
									        <pin name="O1" type="Output" xPos="5">C:9</pin>
								</transition>
								        <jump error="false" id="J:10" name="Init" x="5" y="16">
									        <pin>C:9</pin>
								</jump>
								        <jump error="false" id="J:11" name="Init" x="15" y="16">
									        <pin>C:10</pin>
								</jump>
								        <jump error="false" id="J:12" name="Init" x="35" y="24">
									        <pin>C:11</pin>
								</jump>
								        <jump error="false" id="J:13" name="Auto_Phase_0" x="25" y="24">
									        <pin>C:12</pin>
								</jump>
							</network>
							      <steps>
								        <step name="ManualMode">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Input from HMI edit box *)
	pidSetpoint := 0.0;
	


]]>
									</sourceCode>
								</step>
								        <step name="AnalogInputMode">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Input from analog input, -32768 to +32767 scaled to -10 to +10 *)
	pidSetpoint := TO_REAL( aiSetpoint ) / 102.4;
		


]]>
									</sourceCode>
								</step>
								        <step name="AutoModeInit">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Store initial time for auto sequence *)
	baseTime := sysTimer;
	
	


]]>
									</sourceCode>
								</step>
								        <step name="TestModeInit">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Store initial time for auto sequence *)
	baseTime := sysTimer;
	traceStartAcq := TRUE;


]]>
									</sourceCode>
								</step>
								        <step name="SetPoint10Positive">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Phase 0, set setpoint to max value (+10) *)
	pidSetpoint := 10.0;


]]>
									</sourceCode>
								</step>
								        <step name="SetPoint10Negative">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Phase 0, set setpoint to min value (-10) *)
	pidSetpoint := -10.0;


]]>
									</sourceCode>
								</step>
							</steps>
							      <transitions>
								        <transition name="end_Analog">
									        <sourceCode type="LD">
										          <LD>
											          <network error="false" height="8" order="N:1" width="200">
												            <conn error="false" id="C:3">
													            <segment xEnd="2" xStart="2" yEnd="4" yStart="3"/>
													            <startPin>I:0</startPin>
													            <endPin>I:2</endPin>
												</conn>
												            <conn error="false" id="C:1">
													            <segment xEnd="2" xStart="1" yEnd="3" yStart="3"/>
													            <startPin>PR:1.0</startPin>
													            <endPin>I:0</endPin>
												</conn>
												            <conn error="false" id="C:2">
													            <segment xEnd="3" xStart="2" yEnd="3" yStart="3"/>
													            <startPin>I:0</startPin>
													            <endPin>CN:3.I</endPin>
												</conn>
												            <conn error="false" id="C:7">
													            <segment xEnd="2" xStart="2" yEnd="5" yStart="4"/>
													            <segment xEnd="3" yEnd="5"/>
													            <startPin>I:2</startPin>
													            <endPin>CN:5.I</endPin>
												</conn>
												            <conn error="false" id="C:6">
													            <segment xEnd="3" xStart="2" yEnd="4" yStart="4"/>
													            <startPin>I:2</startPin>
													            <endPin>CN:4.I</endPin>
												</conn>
												            <cross error="false" id="I:0" x="2" y="3">
													            <top/>
													            <bottom>C:3</bottom>
													            <right>C:2</right>
													            <left>C:1</left>
												</cross>
												            <cross error="false" id="I:2" x="2" y="4">
													            <top>C:3</top>
													            <bottom>C:7</bottom>
													            <right>C:6</right>
													            <left/>
												</cross>
												            <conn error="false" id="C:8">
													            <segment xEnd="7" xStart="7" yEnd="3" yStart="4"/>
													            <startPin>I:3</startPin>
													            <endPin>I:1</endPin>
												</conn>
												            <conn error="false" id="C:0">
													            <segment xEnd="7" xStart="5" yEnd="3" yStart="3"/>
													            <startPin>CN:3.O</startPin>
													            <endPin>I:1</endPin>
												</conn>
												            <conn error="false" id="C:4">
													            <segment xEnd="26" xStart="7" yEnd="3" yStart="3"/>
													            <startPin>I:1</startPin>
													            <endPin>CL:6.I</endPin>
												</conn>
												            <conn error="false" id="C:9">
													            <segment xEnd="7" xStart="5" yEnd="5" yStart="5"/>
													            <segment xEnd="7" yEnd="4"/>
													            <startPin>CN:5.O</startPin>
													            <endPin>I:3</endPin>
												</conn>
												            <conn error="false" id="C:5">
													            <segment xEnd="7" xStart="5" yEnd="4" yStart="4"/>
													            <startPin>CN:4.O</startPin>
													            <endPin>I:3</endPin>
												</conn>
												            <cross error="false" id="I:1" x="7" y="3">
													            <top/>
													            <bottom>C:8</bottom>
													            <right>C:4</right>
													            <left>C:0</left>
												</cross>
												            <cross error="false" id="I:3" x="7" y="4">
													            <top>C:8</top>
													            <bottom>C:9</bottom>
													            <right/>
													            <left>C:5</left>
												</cross>
												            <conn error="false" id="C:10">
													            <segment xEnd="30" xStart="28" yEnd="3" yStart="3"/>
													            <startPin>CL:6.O</startPin>
													            <endPin>PR:2.0</endPin>
												</conn>
												            <coil error="false" id="CL:6" name="end_Analog" type="Normal" x="26" y="3">
													            <pin name="I">C:4</pin>
													            <pin name="O">C:10</pin>
												</coil>
												            <powerRail error="false" id="PR:1" pos="0" type="Input">
													            <pinPos yPos="3"/>
													            <pin name="0" negated="false">C:1</pin>
												</powerRail>
												            <powerRail error="false" id="PR:2" pos="30" type="Output">
													            <pinPos yPos="3"/>
													            <pin name="0" negated="false">C:10</pin>
												</powerRail>
												            <contact error="false" id="CN:3" name="inpZeroSetpoint" type="Normal" x="3" y="3">
													            <pin name="I" negated="false">C:2</pin>
													            <pin name="O" negated="false">C:0</pin>
												</contact>
												            <contact error="false" id="CN:4" name="inpAnalogSetpoint" type="Closed" x="3" y="4">
													            <pin name="I" negated="false">C:6</pin>
													            <pin name="O" negated="false">C:5</pin>
												</contact>
												            <contact error="false" id="CN:5" name="inpAutomatic" type="Normal" x="3" y="5">
													            <pin name="I" negated="false">C:7</pin>
													            <pin name="O" negated="false">C:9</pin>
												</contact>
											</network>
										</LD>
									</sourceCode>
								</transition>
								        <transition name="end_Automatic">
									        <sourceCode type="LD">
										          <LD>
											          <network error="false" height="8" order="N:1" width="200">
												            <conn error="false" id="C:3">
													            <segment xEnd="2" xStart="2" yEnd="4" yStart="3"/>
													            <startPin>I:0</startPin>
													            <endPin>I:2</endPin>
												</conn>
												            <conn error="false" id="C:1">
													            <segment xEnd="2" xStart="1" yEnd="3" yStart="3"/>
													            <startPin>PR:1.0</startPin>
													            <endPin>I:0</endPin>
												</conn>
												            <conn error="false" id="C:2">
													            <segment xEnd="3" xStart="2" yEnd="3" yStart="3"/>
													            <startPin>I:0</startPin>
													            <endPin>CN:3.I</endPin>
												</conn>
												            <conn error="false" id="C:7">
													            <segment xEnd="2" xStart="2" yEnd="5" yStart="4"/>
													            <segment xEnd="3" yEnd="5"/>
													            <startPin>I:2</startPin>
													            <endPin>CN:5.I</endPin>
												</conn>
												            <conn error="false" id="C:6">
													            <segment xEnd="3" xStart="2" yEnd="4" yStart="4"/>
													            <startPin>I:2</startPin>
													            <endPin>CN:4.I</endPin>
												</conn>
												            <cross error="false" id="I:0" x="2" y="3">
													            <top/>
													            <bottom>C:3</bottom>
													            <right>C:2</right>
													            <left>C:1</left>
												</cross>
												            <cross error="false" id="I:2" x="2" y="4">
													            <top>C:3</top>
													            <bottom>C:7</bottom>
													            <right>C:6</right>
													            <left/>
												</cross>
												            <conn error="false" id="C:8">
													            <segment xEnd="7" xStart="7" yEnd="3" yStart="4"/>
													            <startPin>I:3</startPin>
													            <endPin>I:1</endPin>
												</conn>
												            <conn error="false" id="C:0">
													            <segment xEnd="7" xStart="5" yEnd="3" yStart="3"/>
													            <startPin>CN:3.O</startPin>
													            <endPin>I:1</endPin>
												</conn>
												            <conn error="false" id="C:4">
													            <segment xEnd="26" xStart="7" yEnd="3" yStart="3"/>
													            <startPin>I:1</startPin>
													            <endPin>CL:6.I</endPin>
												</conn>
												            <conn error="false" id="C:9">
													            <segment xEnd="7" xStart="5" yEnd="5" yStart="5"/>
													            <segment xEnd="7" yEnd="4"/>
													            <startPin>CN:5.O</startPin>
													            <endPin>I:3</endPin>
												</conn>
												            <conn error="false" id="C:5">
													            <segment xEnd="7" xStart="5" yEnd="4" yStart="4"/>
													            <startPin>CN:4.O</startPin>
													            <endPin>I:3</endPin>
												</conn>
												            <cross error="false" id="I:1" x="7" y="3">
													            <top/>
													            <bottom>C:8</bottom>
													            <right>C:4</right>
													            <left>C:0</left>
												</cross>
												            <cross error="false" id="I:3" x="7" y="4">
													            <top>C:8</top>
													            <bottom>C:9</bottom>
													            <right/>
													            <left>C:5</left>
												</cross>
												            <conn error="false" id="C:10">
													            <segment xEnd="30" xStart="28" yEnd="3" yStart="3"/>
													            <startPin>CL:6.O</startPin>
													            <endPin>PR:2.0</endPin>
												</conn>
												            <coil error="false" id="CL:6" name="end_Automatic" type="Normal" x="26" y="3">
													            <pin name="I">C:4</pin>
													            <pin name="O">C:10</pin>
												</coil>
												            <powerRail error="false" id="PR:1" pos="0" type="Input">
													            <pinPos yPos="3"/>
													            <pin name="0" negated="false">C:1</pin>
												</powerRail>
												            <powerRail error="false" id="PR:2" pos="30" type="Output">
													            <pinPos yPos="3"/>
													            <pin name="0" negated="false">C:10</pin>
												</powerRail>
												            <contact error="false" id="CN:3" name="inpZeroSetpoint" type="Normal" x="3" y="3">
													            <pin name="I" negated="false">C:2</pin>
													            <pin name="O" negated="false">C:0</pin>
												</contact>
												            <contact error="false" id="CN:4" name="inpAnalogSetpoint" type="Normal" x="3" y="4">
													            <pin name="I" negated="false">C:6</pin>
													            <pin name="O" negated="false">C:5</pin>
												</contact>
												            <contact error="false" id="CN:5" name="inpAutomatic" type="Closed" x="3" y="5">
													            <pin name="I" negated="false">C:7</pin>
													            <pin name="O" negated="false">C:9</pin>
												</contact>
											</network>
										</LD>
									</sourceCode>
								</transition>
								        <transition name="end_AutoPhase0">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Phase 0 ends when half period elapsed *)
	end_AutoPhase0 := ( sysTimer - baseTime ) > 1000;


]]>
									</sourceCode>
								</transition>
								        <transition name="end_AutoPhase1">
									        <sourceCode type="ST">
										<![CDATA[
	(*	Phase 1 ends when period elapsed *)
	end_AutoPhase1 := ( sysTimer - baseTime ) > 2000;


]]>
									</sourceCode>
								</transition>
								        <transition name="end_Zero">
									        <sourceCode type="LD">
										          <LD>
											          <network error="false" height="8" order="N:1" width="200">
												            <conn error="false" id="C:3">
													            <segment xEnd="2" xStart="2" yEnd="4" yStart="3"/>
													            <startPin>I:0</startPin>
													            <endPin>I:2</endPin>
												</conn>
												            <conn error="false" id="C:0">
													            <segment xEnd="2" xStart="1" yEnd="3" yStart="3"/>
													            <startPin>PR:1.0</startPin>
													            <endPin>I:0</endPin>
												</conn>
												            <conn error="false" id="C:2">
													            <segment xEnd="3" xStart="2" yEnd="3" yStart="3"/>
													            <startPin>I:0</startPin>
													            <endPin>CN:3.I</endPin>
												</conn>
												            <conn error="false" id="C:7">
													            <segment xEnd="2" xStart="2" yEnd="5" yStart="4"/>
													            <segment xEnd="3" yEnd="5"/>
													            <startPin>I:2</startPin>
													            <endPin>CN:5.I</endPin>
												</conn>
												            <conn error="false" id="C:6">
													            <segment xEnd="3" xStart="2" yEnd="4" yStart="4"/>
													            <startPin>I:2</startPin>
													            <endPin>CN:4.I</endPin>
												</conn>
												            <cross error="false" id="I:0" x="2" y="3">
													            <top/>
													            <bottom>C:3</bottom>
													            <right>C:2</right>
													            <left>C:0</left>
												</cross>
												            <cross error="false" id="I:2" x="2" y="4">
													            <top>C:3</top>
													            <bottom>C:7</bottom>
													            <right>C:6</right>
													            <left/>
												</cross>
												            <conn error="false" id="C:8">
													            <segment xEnd="7" xStart="7" yEnd="3" yStart="4"/>
													            <startPin>I:3</startPin>
													            <endPin>I:1</endPin>
												</conn>
												            <conn error="false" id="C:1">
													            <segment xEnd="7" xStart="5" yEnd="3" yStart="3"/>
													            <startPin>CN:3.O</startPin>
													            <endPin>I:1</endPin>
												</conn>
												            <conn error="false" id="C:4">
													            <segment xEnd="26" xStart="7" yEnd="3" yStart="3"/>
													            <startPin>I:1</startPin>
													            <endPin>CL:6.I</endPin>
												</conn>
												            <conn error="false" id="C:9">
													            <segment xEnd="7" xStart="5" yEnd="5" yStart="5"/>
													            <segment xEnd="7" yEnd="4"/>
													            <startPin>CN:5.O</startPin>
													            <endPin>I:3</endPin>
												</conn>
												            <conn error="false" id="C:5">
													            <segment xEnd="7" xStart="5" yEnd="4" yStart="4"/>
													            <startPin>CN:4.O</startPin>
													            <endPin>I:3</endPin>
												</conn>
												            <cross error="false" id="I:1" x="7" y="3">
													            <top/>
													            <bottom>C:8</bottom>
													            <right>C:4</right>
													            <left>C:1</left>
												</cross>
												            <cross error="false" id="I:3" x="7" y="4">
													            <top>C:8</top>
													            <bottom>C:9</bottom>
													            <right/>
													            <left>C:5</left>
												</cross>
												            <conn error="false" id="C:10">
													            <segment xEnd="30" xStart="28" yEnd="3" yStart="3"/>
													            <startPin>CL:6.O</startPin>
													            <endPin>PR:2.0</endPin>
												</conn>
												            <coil error="false" id="CL:6" name="end_Zero" type="Normal" x="26" y="3">
													            <pin name="I">C:4</pin>
													            <pin name="O">C:10</pin>
												</coil>
												            <powerRail error="false" id="PR:1" pos="0" type="Input">
													            <pinPos yPos="3"/>
													            <pin name="0" negated="false">C:0</pin>
												</powerRail>
												            <powerRail error="false" id="PR:2" pos="30" type="Output">
													            <pinPos yPos="3"/>
													            <pin name="0" negated="false">C:10</pin>
												</powerRail>
												            <contact error="false" id="CN:3" name="inpZeroSetpoint" type="Closed" x="3" y="3">
													            <pin name="I" negated="false">C:2</pin>
													            <pin name="O" negated="false">C:1</pin>
												</contact>
												            <contact error="false" id="CN:4" name="inpAutomatic" type="Normal" x="3" y="4">
													            <pin name="I" negated="false">C:6</pin>
													            <pin name="O" negated="false">C:5</pin>
												</contact>
												            <contact error="false" id="CN:5" name="inpAnalogSetpoint" type="Normal" x="3" y="5">
													            <pin name="I" negated="false">C:7</pin>
													            <pin name="O" negated="false">C:9</pin>
												</contact>
											</network>
										</LD>
									</sourceCode>
								</transition>
							</transitions>
						</SFC>
					</sourceCode>
				</program>
				    <program creationDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="1530259977" name="Loops" version="1.0.0">
					    <vars>
						      <localVars>
							      <var name="x" type="REAL"/>
							      <var name="y" type="REAL"/>
							      <var name="incr" type="REAL">
								        <initValue>0.01</initValue>
							</var>
							      <var name="i" type="UINT"/>
							      <var name="bit" type="BOOL"/>
							      <var dim0="64" name="prevInp" type="BOOL"/>
							      <var dim0="8" name="pressed" type="BOOL"/>
						</localVars>
					</vars>
					    <iecDeclaration active="FALSE"/>
					    <sourceCode type="ST">
						<![CDATA[
	y := SIN(x);
	x := x + incr;


	loopsValue := 0;
	FOR i := 0 TO 15 DO
		bit := (y + 0.9) > (0.125 * TO_REAL(i));
		
		IF bit THEN
			loopsValue := loopsValue OR RotateBit(i);
		END_IF;
	END_FOR;

	
	(* uses pid to move value up and down *)
	loopsValue := 0;
	FOR i := 0 TO 15 DO
		bit := (pidFeedback + 10.0) > (1.25 * TO_REAL(i));
		
		IF bit THEN
			loopsValue := loopsValue OR RotateBit(i);
		END_IF;
	END_FOR;

	(* turn on digital outputs (led lights) based on value *)
	IF runLoops THEN
		sysDigitalOutputs[2] := (loopsValue >= 1);
		sysDigitalOutputs[3] := (loopsValue >= 4);
		sysDigitalOutputs[4] := (loopsValue >= 16);
		sysDigitalOutputs[5] := (loopsValue >= 64);
		sysDigitalOutputs[6] := (loopsValue >= 256);
		sysDigitalOutputs[7] := (loopsValue >= 1024);
	END_IF;	
	
	
	(* save previous states of digital inputs*)
	FOR i := 0 TO 7 DO
		IF NOT(prevInp[i]) AND sysDigitalInputs[i] THEN
			pressed[i] := TRUE;
		ELSE
			pressed[i] := FALSE;
		END_IF;	
	END_FOR;
	prevInp := sysDigitalInputs;
	
	
	(* 1st digital input toggles 1st digital output (relay and led) *)
	IF pressed[0] THEN 
		sysDigitalOutputs[0] := NOT(sysDigitalOutputs[0]);
	END_IF;

	(* 2nd digital input toggles 2nd digital output (relay and led) *)
	IF pressed[1] THEN 
		sysDigitalOutputs[1] := NOT(sysDigitalOutputs[1]);
	END_IF;

	(* 4th digital input pauses/unpauses led lights *)
	IF pressed[3] THEN 
		runLoops := NOT(runLoops);
	END_IF;
	
]]>
					</sourceCode>
				</program>
				    <program creationDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="1624954980" name="Init" version="1.0.0">
					    <vars/>
					    <iecDeclaration active="FALSE"/>
					    <sourceCode type="ST">
						<![CDATA[	
	inpAutomatic := TRUE;
]]>
					</sourceCode>
				</program>
				    <program creationDate="1650955784" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="1650957576" name="LadderLogic" version="1.0.0">
					    <vars>
						      <localVars>
							      <var name="fbDelay" type="TON"/>
							      <var name="fbCtu" type="CTU_UDINT"/>
							      <var name="fbCtd" type="CTD_UDINT"/>
							      <var name="fbTp" type="TP"/>
							      <var name="ettp" type="UDINT"/>
							      <var name="TP" type="TP"/>
						</localVars>
					</vars>
					    <iecDeclaration active="FALSE"/>
					    <sourceCode type="LD2">
						      <LD2 version="1">
							      <network comment="" disableCondition="" disabled="false" id="1" label="" nextID="5">
								        <assignment fromTmpVar="">
									        <input>
										          <funcBlock id="2" instance="fbTp" name="TP">
											          <inputs>
												            <pin name="IN" neg="false" type="BOOL">
													            <contact id="0" name="inpLogicData" type="Normal"/>
												</pin>
												            <pin name="PT" neg="false" type="UDINT">
													            <var id="3" name="parPulseWidth"/>
												</pin>
											</inputs>
											          <outputs>
												            <pin name="Q" neg="false" type="BOOL">
													            <outputLine/>
												</pin>
												            <pin name="ET" neg="false" type="UDINT">
													            <var id="4" name="parPulseValue"/>
												</pin>
											</outputs>
										</funcBlock>
									</input>
									        <outputs>
										          <coil id="1" name="outPulse" type="Normal"/>
									</outputs>
								</assignment>
							</network>
							      <network comment="" disableCondition="" disabled="false" id="2" label="" nextID="5">
								        <assignment fromTmpVar="">
									        <input>
										          <funcBlock id="2" instance="fbDelay" name="TON">
											          <inputs>
												            <pin name="IN" neg="false" type="BOOL">
													            <contact id="0" name="inpLogicData" type="Normal"/>
												</pin>
												            <pin name="PT" neg="false" type="UDINT">
													            <var id="3" name="parTimOnDelay"/>
												</pin>
											</inputs>
											          <outputs>
												            <pin name="Q" neg="false" type="BOOL">
													            <outputLine/>
												</pin>
												            <pin name="ET" neg="false" type="UDINT">
													            <var id="4" name="parTimOnValue"/>
												</pin>
											</outputs>
										</funcBlock>
									</input>
									        <outputs>
										          <coil id="1" name="outDelayed" type="Normal"/>
									</outputs>
								</assignment>
							</network>
							      <network comment="" disableCondition="" disabled="false" id="3" label="" nextID="16">
								        <assignment fromTmpVar="">
									        <input>
										          <funcBlock id="2" instance="fbCtu" name="CTU_UDINT">
											          <inputs>
												            <pin name="CU" neg="false" type="BOOL">
													            <contact id="0" name="inpLogicData" type="Positive"/>
												</pin>
												            <pin name="R" neg="false" type="BOOL">
													            <contact id="15" name="inpLogicReset" type="Normal"/>
												</pin>
												            <pin name="PV" neg="false" type="UDINT">
													            <var id="3" name="parCtUpPreset"/>
												</pin>
											</inputs>
											          <outputs>
												            <pin name="Q" neg="false" type="BOOL">
													            <outputLine/>
												</pin>
												            <pin name="CV" neg="false" type="UDINT">
													            <var id="10" name="aoCtUpValue"/>
												</pin>
											</outputs>
										</funcBlock>
									</input>
									        <outputs>
										          <coil id="1" name="outCountUp" type="Normal"/>
									</outputs>
								</assignment>
							</network>
							      <network comment="" disableCondition="" disabled="false" id="4" label="" nextID="19">
								        <assignment fromTmpVar="">
									        <input>
										          <funcBlock id="15" instance="fbCtd" name="CTD_UDINT">
											          <inputs>
												            <pin name="CD" neg="false" type="BOOL">
													            <contact id="0" name="inpLogicData" type="Positive"/>
												</pin>
												            <pin name="LD" neg="false" type="BOOL">
													            <contact id="18" name="inpLogicReset" type="Normal"/>
												</pin>
												            <pin name="PV" neg="false" type="UDINT">
													            <var id="16" name="parCtDownPreset"/>
												</pin>
											</inputs>
											          <outputs>
												            <pin name="Q" neg="false" type="BOOL">
													            <outputLine/>
												</pin>
												            <pin name="CV" neg="false" type="UDINT">
													            <var id="17" name="aoCtDownValue"/>
												</pin>
											</outputs>
										</funcBlock>
									</input>
									        <outputs>
										          <coil id="1" name="outCountDown" type="Normal"/>
									</outputs>
								</assignment>
							</network>
						</LD2>
					</sourceCode>
				</program>
			</programs>
			  <macros/>
			  <structs/>
			  <typedefs/>
			  <enums/>
			  <subranges/>
			  <interfaces/>
		</main>  <target fullXml="false" id="RaspPI_2p2" name="RaspPI.tgt"><![CDATA[(************************************************************************)
(*                                                                      *)
(*	Description: Definition of target variables and functions           *)
(*                                                                      *)
(************************************************************************)




(************************************************************************)
(*                                                                      *)
(*   GLOBAL VARIABLES                                                   *)
(*                                                                      *)
(************************************************************************)

VAR_GLOBAL

	{G:"Internal variables"}
	sysPLCStatus			AT %MD60000.0 : PLC_Status;		{ DE:"Internal PLC Status"}

	{G:"System Timers"}
	sysTimer 		AT %MD60000.0 	: UDINT;	{ DE:"System timer [ms]"}

	{G:"Plugins data allocation"}
	sysPluginsDataRO AT %MB100.0 : ARRAY[0..19999] OF BYTE;  { IO:"RO allocation area for plugins" }
	sysPluginsDataRW AT %MB101.0 : ARRAY[0..19999] OF BYTE;  { IO:"RW allocation area for plugins" }
	
	{G:"User data blocks"}
	sysUserDataBlock 		AT %MB200.0 : ARRAY[ 0..65535 ] OF BYTE;	{ IO:"Data block available for user data mapping" }
	sysUserDataBlockRetain 	AT %MB201.0 : ARRAY[ 0..4095 ] OF BYTE;	{ IO:"Data block available for user data mapping - Retain DB" }
	
	{G:"Time and date"}
	sysHours				AT	%MB60002.4 : USINT;		{ DE:"Values 0-23"}
	sysMinutes				AT	%MB60002.5 : USINT;		{ DE:"Values 0-59"}
	sysSeconds				AT	%MB60002.6 : USINT;		{ DE:"Values 0-59"}
	sysDay					AT	%MB60002.7 : USINT;		{ DE:"Values 1-31"}
	sysDayOfWeek			AT	%MB60002.8 : USINT;		{ DE:"Values 0-6 where 0 is Sunday "}
	sysMonth				AT	%MB60002.9 : USINT;		{ DE:"Values 1-12"}
	sysYear					AT	%MW60002.10 : UINT;		{ DE:"Values 4 digit"}
	
	sysDigitalInputs  AT %IX0.0 	: ARRAY[ 0..63 ] OF BOOL;
	sysDigitalOutputs  AT %QX0.0 	: ARRAY[ 0..63 ] OF BOOL;
END_VAR


(************************)
(*                      *)
(*      STRUCTURES      *)
(*                      *)
(************************)

TYPE

	PLC_Status : STRUCT { DE:"PLC engine status" }
		systemTime : UDINT; { DE:"Absolute system value" }
		IOCycleTime : UDINT; { DE:"I/O cycle period" }
		IOCycleDuration : UDINT; { DE:"Duration of I/O cycle" }
		IOOvrTreshold : UDINT; { DE:"Treshold for I/O cycle overtime" }
		IORealPeriod  : UDINT; { DE:"Real I/O period" }
	END_STRUCT;

END_TYPE


(************************************************************************)    
(*                                                                      *)    
(*   EMBEDDED FUNCTIONS                                                 *)    
(*                                                                      *)    
(************************************************************************)   

FUNCTION GetTime_us : UDINT	{ DE:"Get timestamp in micro seconds" }
	
	VAR_INPUT
	dmy : UINT;			{ DE:"Dummy input parameter for function call" }
	END_VAR
	
	{CODE:EMBEDDED}

END_FUNCTION

FUNCTION GetEpochTime_s : UDINT	{ DE:"Get seconds from epoch (UTC)" }
	
	VAR_INPUT
	dmy : UINT;			{ DE:"Dummy input parameter for function call" }
	END_VAR
	
	{CODE:EMBEDDED}

END_FUNCTION

FUNCTION SignalTask : BOOL	{ DE:"Send signal event to wake up specified task" }
	
	VAR_INPUT
	taskId : UINT;		{ DE:"Task id of the event task to wake up" }
	END_VAR
	
	{CODE:EMBEDDED}

END_FUNCTION

FUNCTION sysTraceLog : BOOL	{ DE:"Write log to AlTrace, LLExec target logging environment" }
	{ HIDDEN:ON }
	VAR_INPUT
		mask: DWORD;	{ DE:"ALTRACE log mask. 0x00000001: ALTRACE_LEV_BASE. 0x00000020: ALTRACE_LEV_FAULT. 0x00000040: ALTRACE_LEV_ADVANCED" }
		msg: STRING;	{ DE:"String to print. N.B.: max 1 parameter with '%d' printf specifier supported" }
		param: UDINT;	{ DE:"Specified parameter" }
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysLogWriteMsg : BOOL	{ DE:"Print remote log to LogicLab Debug output window" }
	VAR_INPUT
		level: UINT;	{ DE:"Level [0 to 65535] value is reported into message" }
		msg: STRING;	{ DE:"Message string to print" }
		info1: DINT;	{ DE:"User parameter 1" }
		info2: DINT;	{ DE:"User parameter 2" }
		info3: DINT;	{ DE:"User parameter 3" }
		info4: DINT;	{ DE:"User parameter 4" }
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

]]></target>
    <targetXML fullXml="true" name="RaspPI.tgtx">
      <target>
	      <resources>
		        <resource name="RaspPI" processor="ARM32_VFP2">
			        <task descr="Fast task" id="0" name="Fast" period="10000" type="cyclic">
				          <constraints>
					          <validPeriods>
						            <period>1000</period>
						            <period>2000</period>
						            <period>5000</period>
						            <period>10000</period>
					</validPeriods>
				</constraints>
			</task>
			        <task descr="Slow task" id="1" name="Slow" period="20000" type="cyclic">
				          <constraints maxPeriod="1000000" multipleOfTask="0"/>
			</task>
			        <task descr="Background task" id="2" name="Background" period="100000" type="cyclic"/>
			        <task descr="Boot task" id="3" name="Boot" period="0" type="single"/>
			        <task descr="Init task" id="4" name="Init" period="0" type="single"/>
		</resource>
	</resources>
</target>    </targetXML>
    <libraries>
      <lib fullXml="true" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\..\..\LogicLab\Libraries\Standard.plclib" version="1.0.3">
				    <descr>Release notes:
- 1.0.2 : changed the behaviour of R_TRIG to be fully compliant to IEC 61131-3. Even after a cold restart R_TRIG.Q will now return TRUE once when R_TRIG.CLK is connected to TRUE.
- 1.0.3 : corrected descriptions and images of R_TRIG and F_TRIG (behaviour has not been changed).
		</descr>
				    <libWorkspace>
					    <folder id="7" name="Standard">
						      <folder name="Timers">
							      <Pou name="TOF"/>
							      <Pou name="TON"/>
						</folder>
						      <folder name="Set/reset">
							      <Pou name="TP"/>
							      <Pou name="RS"/>
							      <Pou name="SR"/>
						</folder>
						      <folder name="Edge detection">
							      <Pou genHidden="false" name="F_TRIG"/>
							      <Pou genHidden="false" name="R_TRIG"/>
						</folder>
						      <folder name="Counters">
							      <Pou name="CTD"/>
							      <Pou name="CTD_DINT"/>
							      <Pou name="CTD_UDINT"/>
							      <Pou name="CTU_DINT"/>
							      <Pou name="CTU"/>
							      <Pou name="CTU_UDINT"/>
							      <Pou name="CTUD"/>
							      <Pou name="CTUD_DINT"/>
							      <Pou name="CTUD_UDINT"/>
						</folder>
					</folder>
				</libWorkspace>
				    <globalVars/>
				    <retainVars/>
				    <constantVars/>
				    <functions/>
				    <functionBlocks>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTUD_UDINT" version="1.0.0">
						      <title>Up-Down counter (UDINT data type)</title>
						      <descr>&lt;HTML&gt;(Same as CTUD_UDINT but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTUD_UDINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and &lt;b&gt;count down&lt;/b&gt; for each  FALSE-to-TRUE transition of the input CD.&lt;br/&gt;
Sets the QU output when the accumulated value (CV) reaches the preset value (PV) value and sets the QD output when the accumulated value (CV) becomes 0.&lt;br/&gt;
&lt;img src= ctudscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of LD set CV to PV&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output QU is set&lt;/li&gt;
&lt;li&gt;when CV becomes 0 the output QD is set&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CU" type="BOOL">
									        <descr>Count-up input</descr>
								</var>
								        <var name="CD" type="BOOL">
									        <descr>Count-down input</descr>
								</var>
								        <var name="R" type="BOOL">
									        <descr>Reset counter input</descr>
								</var>
								        <var name="LD" type="BOOL">
									        <descr>Preset counter input</descr>
								</var>
								        <var name="PV" type="UDINT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="QU" type="BOOL">
									        <descr>Count-up output</descr>
								</var>
								        <var name="QD" type="BOOL">
									        <descr>Count-down output</descr>
								</var>
								        <var name="CV" type="UDINT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="MEMCU" type="BOOL">
									        <descr>Previous value of CU</descr>
								</var>
								        <var name="MEMCD" type="BOOL">
									        <descr>Previous value of CD</descr>
								</var>
								        <var name="CUEDGE" type="BOOL">
									        <descr>True whenever a posedge on CU is detected</descr>
								</var>
								        <var name="CDEDGE" type="BOOL">
									        <descr>True whenever a posedge on CD is detected</descr>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(* Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l10

l0:
	(* Check for preset input *)
	LD		LD
	JMPCN	l1
	
	LD		PV
	ST		CV
	JMP		l10

l1:
	(* Check for posedge on CU *)
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	(* Store CU value for next cycle *)	
	LD 		CU
	ST 		MEMCU

	(* Check for posedge on CD *)
	LD		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	(* Store CD value for next cycle *)	
	LD 		CD
	ST 		MEMCD

	(* Check for simultaneous posedges on *)
	LD		CUEDGE
	AND		CDEDGE
	JMPC	l10
	
	(* ASSERT(!CUEDGE || !CDEDGE) *)

	(* Check if posedge on CU and we are in bounds *)
	LD		CUEDGE
	AND(	16#FFFFFFFF
	GT		CV
	)
	JMPCN	l2
	
	(* ASSERT(CUEDGE) *)
	(* Increment *)
	LD		CV
	ADD		1
	ST		CV

l2:
    (* Check if posedge on CD and we are in bounds *)
	LD		CDEDGE
	AND(	CV
	GT		0
	)
	JMPCN	l10
	
	(* ASSERT(CDEDGE) *)
	(* Decrement *)
	LD		CV
	SUB		1
	ST		CV
	
	(* ASSERT(!CUEDGE && !CDEDGE) *)
	
l10:
	(* Up counter output *)
	LD		CV
	GE		PV
	ST		QU

	(* Down counter output *)
	LD		CV
	LE		0
	ST		QD
]]>
						</sourceCode>
						      <images>
							      <image height="244" name="ctudscheme.png" width="376">
								<![CDATA[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]]>
							</image>
							      <image height="48" icon="true" name="ctud48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAC5UlEQVRoge1YoZLbMBB92yns
gRRcZ2xWHtSZfEGKDxXHKCHH8wvHW3KHHFzSooLeF1yn6Ep7zAIBNcgHbEEkZ61IthS7OWea
N6ORJa1Xb61drSXgjDP+b5Cnn11jzPxv2USAaEvvhWOMrXrQsA2wSQ/eiJdW27iN04WGCJcL
nRTOBjw3WrfRJMlvAczF2F1RzBb2C2m6WgK4cegqAbwH8FO35wBufXJKZUYOzAwiQpLkDICU
yvZesoPYhXvxPPdKbQneOfrnuiwi5QDAkAcATpJ8z4ioRKaV3SmVLWRSG0/W+FN886gCa8J7
q+aSUyqr5AT5GueimDUmslbYGfnx4fIQNY3wkAcATtNV1QhxoVCMACx1HYIbIWvqEmgkb1B5
yMEGpOlqVBSzcjxZm66lLjZK7Pv8CFt/t401ARycRLtso7/TdCV3HUOGrPJaEDModb+UAYCp
rjmgHG6ADqARgNHjw2UfMVCaB2aGUlnbClTjnRPZeLKGcKPOMLtLgxFUFLOq0RoDSZJ/wG5p
AWCqk5sPrrHP2OWTd2jOJxWKYkZpupIBTUplIMqqjpAgnloTvhXtp18/3gAAkiQ34y5yT2g3
wBXsUCqjpkzsw9HOAU2nPGauFfGR2vWGKOyrtBkXS77RgKHh5H+nzwY8N6ptVPq3SSZ9+jwf
srMxE4jMj1utNlku6jzQBdyzTqOo8+/0QV+2R+xcSHQSolntviyzWGAHYtySyC+v5whZgThb
msiHjAfIb66vqudQFxr+LR3rxdI+zVwvQSeMYxW8+l7xrlZgc32125k+fWXRDsLFxy+gi/t2
QQu8mdbek217zPRB9FUk5c+SUhknSS4veiVsw9pixKfHp68V8lolNgZiSXQ13j2ZCGxpgMx0
TcpjJw25IvFhLwNvaybzLcQXqWUCLeTS1TRXCDdqGQ9Fh5u544OiLR3ayaV2FyTR13oeE2Su
3ZswNGO8K3AiMQAgMl8MbQXOGCz+ArhmepcGiq6VAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTUD_DINT" version="1.0.0">
						      <title>Up-Down counter (DINT data type)</title>
						      <descr>&lt;HTML&gt;(Same as CTUD but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTUD_DINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and &lt;b&gt;count down&lt;/b&gt; for each  FALSE-to-TRUE transition of the input CD.&lt;br/&gt;
Sets the QU output when the accumulated value (CV) reaches the preset value (PV) value and sets the QD output when the accumulated value (CV) becomes 0.&lt;br/&gt;
&lt;img src= ctudscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of LD set CV to PV&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output QU is set&lt;/li&gt;
&lt;li&gt;when CV becomes 0 the output QD is set&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CU" type="BOOL">
									        <descr>Count-up input</descr>
								</var>
								        <var name="CD" type="BOOL">
									        <descr>Count-down input</descr>
								</var>
								        <var name="R" type="BOOL">
									        <descr>Reset counter input</descr>
								</var>
								        <var name="LD" type="BOOL">
									        <descr>Preset counter input</descr>
								</var>
								        <var name="PV" type="DINT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="QU" type="BOOL">
									        <descr>Count-up output</descr>
								</var>
								        <var name="QD" type="BOOL">
									        <descr>Count-down output</descr>
								</var>
								        <var name="CV" type="DINT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="MEMCU" type="BOOL">
									        <descr>Previous value of CU</descr>
								</var>
								        <var name="MEMCD" type="BOOL">
									        <descr>Previous value of CD</descr>
								</var>
								        <var name="CUEDGE" type="BOOL">
									        <descr>True whenever a posedge on CU is detected</descr>
								</var>
								        <var name="CDEDGE" type="BOOL">
									        <descr>True whenever a posedge on CD is detected</descr>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(* Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l10

l0:
	(* Check for preset input *)
	LD		LD
	JMPCN	l1
	
	LD		PV
	ST		CV
	JMP		l10

l1:
	(* Check for posedge on CU *)
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	(* Store CU value for next cycle *)	
	LD 		CU
	ST 		MEMCU

	(* Check for posedge on CD *)
	LD		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	(* Store CD value for next cycle *)	
	LD 		CD
	ST 		MEMCD

	(* Check for simultaneous posedges on *)
	LD		CUEDGE
	AND		CDEDGE
	JMPC	l10
	
	(* ASSERT(!CUEDGE || !CDEDGE) *)

	(* Check if posedge on CU and we are in bounds *)
	LD		CUEDGE
	AND(	CV
	LT		16#7FFFFFFF
	)
	JMPCN	l2
	
	(* ASSERT(CUEDGE) *)
	(* Increment *)
	LD		CV
	ADD		1
	ST		CV

l2:
    (* Check if posedge on CD and we are in bounds *)
	LD		CDEDGE
	AND(	CV
	GT		-2147483648
	)
	JMPCN	l10
	
	(* ASSERT(CDEDGE) *)
	(* Decrement *)
	LD		CV
	SUB		1
	ST		CV
	
	(* ASSERT(!CUEDGE && !CDEDGE) *)
	
l10:
	(* Up counter output *)
	LD		CV
	GE		PV
	ST		QU

	(* Down counter output *)
	LD		CV
	LE		0
	ST		QD
]]>
						</sourceCode>
						      <images>
							      <image height="244" name="ctudscheme.png" width="376">
								<![CDATA[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]]>
							</image>
							      <image height="48" icon="true" name="ctud48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAC5UlEQVRoge1YoZLbMBB92yns
gRRcZ2xWHtSZfEGKDxXHKCHH8wvHW3KHHFzSooLeF1yn6Ep7zAIBNcgHbEEkZ61IthS7OWea
N6ORJa1Xb61drSXgjDP+b5Cnn11jzPxv2USAaEvvhWOMrXrQsA2wSQ/eiJdW27iN04WGCJcL
nRTOBjw3WrfRJMlvAczF2F1RzBb2C2m6WgK4cegqAbwH8FO35wBufXJKZUYOzAwiQpLkDICU
yvZesoPYhXvxPPdKbQneOfrnuiwi5QDAkAcATpJ8z4ioRKaV3SmVLWRSG0/W+FN886gCa8J7
q+aSUyqr5AT5GueimDUmslbYGfnx4fIQNY3wkAcATtNV1QhxoVCMACx1HYIbIWvqEmgkb1B5
yMEGpOlqVBSzcjxZm66lLjZK7Pv8CFt/t401ARycRLtso7/TdCV3HUOGrPJaEDModb+UAYCp
rjmgHG6ADqARgNHjw2UfMVCaB2aGUlnbClTjnRPZeLKGcKPOMLtLgxFUFLOq0RoDSZJ/wG5p
AWCqk5sPrrHP2OWTd2jOJxWKYkZpupIBTUplIMqqjpAgnloTvhXtp18/3gAAkiQ34y5yT2g3
wBXsUCqjpkzsw9HOAU2nPGauFfGR2vWGKOyrtBkXS77RgKHh5H+nzwY8N6ptVPq3SSZ9+jwf
srMxE4jMj1utNlku6jzQBdyzTqOo8+/0QV+2R+xcSHQSolntviyzWGAHYtySyC+v5whZgThb
msiHjAfIb66vqudQFxr+LR3rxdI+zVwvQSeMYxW8+l7xrlZgc32125k+fWXRDsLFxy+gi/t2
QQu8mdbek217zPRB9FUk5c+SUhknSS4veiVsw9pixKfHp68V8lolNgZiSXQ13j2ZCGxpgMx0
TcpjJw25IvFhLwNvaybzLcQXqWUCLeTS1TRXCDdqGQ9Fh5u544OiLR3ayaV2FyTR13oeE2Su
3ZswNGO8K3AiMQAgMl8MbQXOGCz+ArhmepcGiq6VAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTUD" version="1.0.0">
						      <title>Up-Down counter</title>
						      <descr>&lt;HTML&gt;The CTUD block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and &lt;b&gt;count down&lt;/b&gt; for each  FALSE-to-TRUE transition of the input CD.&lt;br/&gt;
Sets the QU output when the accumulated value (CV) reaches the preset value (PV) value and sets the QD output when the accumulated value (CV) becomes 0.&lt;br/&gt;
&lt;img src= ctudscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of LD set CV to PV&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output QU is set&lt;/li&gt;
&lt;li&gt;when CV becomes 0 the output QD is set&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CU" type="BOOL">
									        <descr>Count-up input</descr>
								</var>
								        <var name="CD" type="BOOL">
									        <descr>Count-down input</descr>
								</var>
								        <var name="R" type="BOOL">
									        <descr>Reset counter input</descr>
								</var>
								        <var name="LD" type="BOOL">
									        <descr>Preset counter input</descr>
								</var>
								        <var name="PV" type="INT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="QU" type="BOOL">
									        <descr>Count-up output</descr>
								</var>
								        <var name="QD" type="BOOL">
									        <descr>Count-down output</descr>
								</var>
								        <var name="CV" type="INT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="MEMCU" type="BOOL">
									        <descr>Previous value of CU</descr>
								</var>
								        <var name="MEMCD" type="BOOL">
									        <descr>Previous value of CD</descr>
								</var>
								        <var name="CUEDGE" type="BOOL">
									        <descr>True whenever a posedge on CU is detected</descr>
								</var>
								        <var name="CDEDGE" type="BOOL">
									        <descr>True whenever a posedge on CD is detected</descr>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(* Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l10

l0:
	(* Check for preset input *)
	LD		LD
	JMPCN	l1
	
	LD		PV
	ST		CV
	JMP		l10
	
l1:
	(* Check for posedge on CU *)
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	(* Store CU value for next cycle *)	
	LD 		CU
	ST 		MEMCU
	
	(* Check for posedge on CD *)
	LD		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	(* Store CD value for next cycle *)	
	LD 		CD
	ST 		MEMCD

	(* Check for simultaneous posedges on *)
	LD		CUEDGE
	AND		CDEDGE
	JMPC	l10
	
	(* ASSERT(!CUEDGE || !CDEDGE) *)

	(* Check if posedge on CU and we are in bounds *)
	LD		CUEDGE
	AND(	CV
	LT		16#7FFF
	)
	JMPCN	l2
	
	(* ASSERT(CUEDGE) *)
	(* Increment *)
	LD		CV
	ADD		1
	ST		CV
	
l2: 
    (* Check if posedge on CD and we are in bounds *)
	LD		CDEDGE
	AND(	CV
	GT		-32768
	)
	JMPCN	l10
	
	(* ASSERT(CDEDGE) *)
	(* Decrement *)
	LD		CV
	SUB		1
	ST		CV
	
	(* ASSERT(!CUEDGE && !CDEDGE) *)
	
l10:
	(* Up counter output *)
	LD		CV
	GE		PV
	ST		QU

	(* Down counter output *)
	LD		CV
	LE		0
	ST		QD
]]>
						</sourceCode>
						      <images>
							      <image height="244" name="ctudscheme.png" width="376">
								<![CDATA[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]]>
							</image>
							      <image height="48" icon="true" name="ctud48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAC5UlEQVRoge1YoZLbMBB92yns
gRRcZ2xWHtSZfEGKDxXHKCHH8wvHW3KHHFzSooLeF1yn6Ep7zAIBNcgHbEEkZ61IthS7OWea
N6ORJa1Xb61drSXgjDP+b5Cnn11jzPxv2USAaEvvhWOMrXrQsA2wSQ/eiJdW27iN04WGCJcL
nRTOBjw3WrfRJMlvAczF2F1RzBb2C2m6WgK4cegqAbwH8FO35wBufXJKZUYOzAwiQpLkDICU
yvZesoPYhXvxPPdKbQneOfrnuiwi5QDAkAcATpJ8z4ioRKaV3SmVLWRSG0/W+FN886gCa8J7
q+aSUyqr5AT5GueimDUmslbYGfnx4fIQNY3wkAcATtNV1QhxoVCMACx1HYIbIWvqEmgkb1B5
yMEGpOlqVBSzcjxZm66lLjZK7Pv8CFt/t401ARycRLtso7/TdCV3HUOGrPJaEDModb+UAYCp
rjmgHG6ADqARgNHjw2UfMVCaB2aGUlnbClTjnRPZeLKGcKPOMLtLgxFUFLOq0RoDSZJ/wG5p
AWCqk5sPrrHP2OWTd2jOJxWKYkZpupIBTUplIMqqjpAgnloTvhXtp18/3gAAkiQ34y5yT2g3
wBXsUCqjpkzsw9HOAU2nPGauFfGR2vWGKOyrtBkXS77RgKHh5H+nzwY8N6ptVPq3SSZ9+jwf
srMxE4jMj1utNlku6jzQBdyzTqOo8+/0QV+2R+xcSHQSolntviyzWGAHYtySyC+v5whZgThb
msiHjAfIb66vqudQFxr+LR3rxdI+zVwvQSeMYxW8+l7xrlZgc32125k+fWXRDsLFxy+gi/t2
QQu8mdbek217zPRB9FUk5c+SUhknSS4veiVsw9pixKfHp68V8lolNgZiSXQ13j2ZCGxpgMx0
TcpjJw25IvFhLwNvaybzLcQXqWUCLeTS1TRXCDdqGQ9Fh5u544OiLR3ayaV2FyTR13oeE2Su
3ZswNGO8K3AiMQAgMl8MbQXOGCz+ArhmepcGiq6VAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTU_UDINT" version="1.0.0">
						      <title>Up counter (UDINT data type)</title>
						      <descr>&lt;HTML&gt;(Same as CTU but with PV and CV of &lt;b&gt;UDINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTU_UDINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and sets the output Q when the accumulated value (CV) reaches the preset value (PV) value.&lt;br/&gt;
&lt;img src= ctuscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is equal to PV its value remains until a rising edge of R&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CU" type="BOOL">
									        <descr>Count-up on input rising edge</descr>
								</var>
								        <var name="R" type="BOOL">
									        <descr>Reset counter input</descr>
								</var>
								        <var name="PV" type="UDINT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Count-up output</descr>
								</var>
								        <var name="CV" type="UDINT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="CUEDGE" type="BOOL"/>
								        <var name="MEMCU" type="BOOL"/>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	
	LD 		CU
	ST 		MEMCU
	
	LD 		CUEDGE
	AND(	CV
	LT		16#FFFFFFFF
	)
	JMPCN	l1
	
	LD		CV
	ADD		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	GE		PV
	ST		Q
	

]]>
						</sourceCode>
						      <images>
							      <image height="48" icon="true" name="ctu48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACtUlEQVRoge2YoXLcMBCGf3UK
G3AF7YzFyoM6kye44KDiO3RHwu8VwluSQz5c0qKA5gnaKWppw2wQUIN7gC2w1ifLki3ZzkU3
9TfjsSWt17vWrtYyMDHxfyMc/WQbI6KntSYAIUrzXljGyDhHjemAaXT0Trw02hw21hCKEVsI
nRSTA89N5zKaJOktgJU2ts2yxdq8QcrdBsCNRVcB4BLAT9VeAbh1yeX5kuVARBBCIElSAiDy
fNm4yUxiG/fa9copVRq4tfSv1LEOlAMANh4AKEnShhNBhUwp2+b5cq0XtfOLR/zN7hyqQMrg
xqzZ5PJ8WclpxtdszrJFayHrxKzIv76/6aOmFYfxAEBS7qqGTwj5MgOwUWcfbjRZPhdAq/FM
FSG9HZByN8uyRXF+8chdG3WYFGjG/AxlvJvOcgJ7F9Ehy+gfKXf6qsPGCON4rRnGFKpflwGA
eagRvWZALW0zADOOfyn7aKoo+MLML05WF4NzQAuhUegy2KTTgSRJP6A+tXNV3FzYxj7jUE/e
o72eBOEzA3Pjge+09sPvH28BAEmS8rjNuAd0O2BL9t4cbR8wdJcXlAMxbSmZ4CQOTbKn5uQ/
pycHnpsqB/QE5TgfM2mpz8pGJCAEf7jVzpyJQfuBIdDIOlnR4E+JXm92RA4hpHUKBFt1eLNE
2gRbCAlLIdzy6hk+MxDmS1edCK0jFvn99VV17RtCcVUvG6QmS8U0Uf1ATAdefavsrmZgf311
WJk+fSWt7cXZxy8QZ/fdgga0n9fu09vmGPdB69OMrKUxASQsA8Y91nETlx6Xvk7KdcI/iYcY
MdR5+8O0xNYd0Ctdm/LQh/r8InHRqMDlmQS/C58QMnS1PcvHNtEx7suAP3PHRwR7GtvWq1pB
Tcaaz2Mi+Ld7G7E545yBE8kBAIH1IrYZmIiWf2FOAyn58r38AAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTU" version="1.0.0">
						      <title>Up counter</title>
						      <descr>&lt;HTML&gt;The CTU block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and sets the output Q when the accumulated value (CV) reaches the preset value (PV) value.&lt;br/&gt;
&lt;img src= ctuscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is equal to PV its value remains until a rising edge of R&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CU" type="BOOL">
									        <descr>Count-up on input rising edge</descr>
								</var>
								        <var name="R" type="BOOL">
									        <descr>Reset counter input</descr>
								</var>
								        <var name="PV" type="INT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Count-up output</descr>
								</var>
								        <var name="CV" type="INT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="CUEDGE" type="BOOL"/>
								        <var name="MEMCU" type="BOOL"/>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	
	LD 		CU
	ST 		MEMCU
	
	LD 		CUEDGE
	AND(	CV
	LT		16#7FFF
	)
	JMPCN	l1
	
	LD		CV
	ADD		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	GE		PV
	ST		Q
	

]]>
						</sourceCode>
						      <images>
							      <image height="200" name="ctuscheme.png" width="336">
								<![CDATA[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
Si8AAAAASUVORK5CYII=]]>
							</image>
							      <image height="48" icon="true" name="ctu48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACtUlEQVRoge2YoXLcMBCGf3UK
G3AF7YzFyoM6kye44KDiO3RHwu8VwluSQz5c0qKA5gnaKWppw2wQUIN7gC2w1ifLki3ZzkU3
9TfjsSWt17vWrtYyMDHxfyMc/WQbI6KntSYAIUrzXljGyDhHjemAaXT0Trw02hw21hCKEVsI
nRSTA89N5zKaJOktgJU2ts2yxdq8QcrdBsCNRVcB4BLAT9VeAbh1yeX5kuVARBBCIElSAiDy
fNm4yUxiG/fa9copVRq4tfSv1LEOlAMANh4AKEnShhNBhUwp2+b5cq0XtfOLR/zN7hyqQMrg
xqzZ5PJ8WclpxtdszrJFayHrxKzIv76/6aOmFYfxAEBS7qqGTwj5MgOwUWcfbjRZPhdAq/FM
FSG9HZByN8uyRXF+8chdG3WYFGjG/AxlvJvOcgJ7F9Ehy+gfKXf6qsPGCON4rRnGFKpflwGA
eagRvWZALW0zADOOfyn7aKoo+MLML05WF4NzQAuhUegy2KTTgSRJP6A+tXNV3FzYxj7jUE/e
o72eBOEzA3Pjge+09sPvH28BAEmS8rjNuAd0O2BL9t4cbR8wdJcXlAMxbSmZ4CQOTbKn5uQ/
pycHnpsqB/QE5TgfM2mpz8pGJCAEf7jVzpyJQfuBIdDIOlnR4E+JXm92RA4hpHUKBFt1eLNE
2gRbCAlLIdzy6hk+MxDmS1edCK0jFvn99VV17RtCcVUvG6QmS8U0Uf1ATAdefavsrmZgf311
WJk+fSWt7cXZxy8QZ/fdgga0n9fu09vmGPdB69OMrKUxASQsA8Y91nETlx6Xvk7KdcI/iYcY
MdR5+8O0xNYd0Ctdm/LQh/r8InHRqMDlmQS/C58QMnS1PcvHNtEx7suAP3PHRwR7GtvWq1pB
Tcaaz2Mi+Ld7G7E545yBE8kBAIH1IrYZmIiWf2FOAyn58r38AAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTU_DINT" version="1.0.0">
						      <title>Up counter (DINT data type)</title>
						      <descr>&lt;HTML&gt;(Same as CTU but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTU_DINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and sets the output Q when the accumulated value (CV) reaches the preset value (PV) value.&lt;br/&gt;
&lt;img src= ctuscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is equal to PV its value remains until a rising edge of R&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CU" type="BOOL">
									        <descr>Count-up on input rising edge</descr>
								</var>
								        <var name="R" type="BOOL">
									        <descr>Reset counter input</descr>
								</var>
								        <var name="PV" type="DINT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Count-up output</descr>
								</var>
								        <var name="CV" type="DINT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="CUEDGE" type="BOOL"/>
								        <var name="MEMCU" type="BOOL"/>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	
	LD 		CU
	ST 		MEMCU
	
	LD 		CUEDGE
	AND(	CV
	LT		16#7FFFFFFF
	)
	JMPCN	l1
	
	LD		CV
	ADD		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	GE		PV
	ST		Q
	

]]>
						</sourceCode>
						      <images>
							      <image height="200" name="ctuscheme.png" width="336">
								<![CDATA[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
Si8AAAAASUVORK5CYII=]]>
							</image>
							      <image height="48" icon="true" name="ctu48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACtUlEQVRoge2YoXLcMBCGf3UK
G3AF7YzFyoM6kye44KDiO3RHwu8VwluSQz5c0qKA5gnaKWppw2wQUIN7gC2w1ifLki3ZzkU3
9TfjsSWt17vWrtYyMDHxfyMc/WQbI6KntSYAIUrzXljGyDhHjemAaXT0Trw02hw21hCKEVsI
nRSTA89N5zKaJOktgJU2ts2yxdq8QcrdBsCNRVcB4BLAT9VeAbh1yeX5kuVARBBCIElSAiDy
fNm4yUxiG/fa9copVRq4tfSv1LEOlAMANh4AKEnShhNBhUwp2+b5cq0XtfOLR/zN7hyqQMrg
xqzZ5PJ8WclpxtdszrJFayHrxKzIv76/6aOmFYfxAEBS7qqGTwj5MgOwUWcfbjRZPhdAq/FM
FSG9HZByN8uyRXF+8chdG3WYFGjG/AxlvJvOcgJ7F9Ehy+gfKXf6qsPGCON4rRnGFKpflwGA
eagRvWZALW0zADOOfyn7aKoo+MLML05WF4NzQAuhUegy2KTTgSRJP6A+tXNV3FzYxj7jUE/e
o72eBOEzA3Pjge+09sPvH28BAEmS8rjNuAd0O2BL9t4cbR8wdJcXlAMxbSmZ4CQOTbKn5uQ/
pycHnpsqB/QE5TgfM2mpz8pGJCAEf7jVzpyJQfuBIdDIOlnR4E+JXm92RA4hpHUKBFt1eLNE
2gRbCAlLIdzy6hk+MxDmS1edCK0jFvn99VV17RtCcVUvG6QmS8U0Uf1ATAdefavsrmZgf311
WJk+fSWt7cXZxy8QZ/fdgga0n9fu09vmGPdB69OMrKUxASQsA8Y91nETlx6Xvk7KdcI/iYcY
MdR5+8O0xNYd0Ctdm/LQh/r8InHRqMDlmQS/C58QMnS1PcvHNtEx7suAP3PHRwR7GtvWq1pB
Tcaaz2Mi+Ld7G7E545yBE8kBAIH1IrYZmIiWf2FOAyn58r38AAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTD_UDINT" version="1.0.0">
						      <title>Down counter (UDINT data type)</title>
						      <descr>&lt;HTML&gt;(Same as CTD but with PV and CV of &lt;b&gt;UDINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTD_UDINT block &lt;b&gt;counts down&lt;/b&gt; for each FALSE-to-TRUE transition of the input CD and sets the output Q when the accumulated value (CV) reaches the 0 value.&lt;br/&gt;
&lt;img src= ctdscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of LD set CV to the value of PV&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches 0 the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is 0 its value remains 0 until a rising edge of LD&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CD" type="BOOL">
									        <descr>Count-down on input rising edge</descr>
								</var>
								        <var name="LD" type="BOOL">
									        <descr>Preset counter input</descr>
								</var>
								        <var name="PV" type="UDINT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Count-down output</descr>
								</var>
								        <var name="CV" type="UDINT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="CDEDGE" type="BOOL"/>
								        <var name="MEMCD" type="BOOL"/>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		LD
	JMPCN	l0
	
	LD		PV
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD 	CD
	ANDN 	MEMCD
	ST 		CDEDGE
	
	LD 		CD
	ST 		MEMCD
	
	LD 		CDEDGE
	AND(	CV
	GT		0
	)
	JMPCN	l1
	
	LD		CV
	SUB		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	LE		0
	ST		Q
	

]]>
						</sourceCode>
						      <images>
							      <image height="200" name="ctdscheme.png" width="336">
								<![CDATA[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]]>
							</image>
							      <image height="48" icon="true" name="ctd48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADBElEQVRoge1YvW7bMBD+WHRs
AthDA1Bbpg7NVDRP4Ayd2jeQJmdpZ79C9naJJ3nu0k4Zmido4KlZm40EmiEGnO7XQaJ8okiL
st2Yaf0BhCTyJN7H++GJwA47/N8Qnn5yjRHR39WmA4Qo1HviGCPrGjVsArbS0ZN4aj0bt3G6
UIxwudCjwo7AttGaRqXMhwDOHTIzACdKpVMASJLJCMCZTw7AtHweAPhm66F11lSCCEIIEBGS
ZAKXjB3ELkwBjB39w7KddpS7YXIDAIfLJjd7j1IpkgQNEp02Mg4pcwIwVio9PTq+xZ268OpQ
KnzqGDtHQc5rARtJMoFS6dKNzIuXr3+BiBof/vH9eZfPBMG36xeWmFTPIS4EAJAyP7tTF70k
AQD0yu4ZE+kBGLGxldFWshQWyAAEEpAy76Ewta3c9Oj41tyPymZjBndsNObQOpsBqK1wG4Jc
SOtspnXW7ydvhFKpANAvhwZMzJATVutjkYGW4aeUucliFNDCCRhcXx1ACAGzUkDh/xuKgR6A
Xuk+SxOI1lk1HhwDPjAX2ghY3hdwFJNceSCAgJT5KxT+HwrXpvcZwGV5f4hFrBgXrL1jUqSU
eY2EUqkwwWsQYgEfgRmA8fXVgZnM9LtkbywCtsyQyVXQOqtIFCufBqhb4MH+A9b9y+sUAzH9
Uhp0DmLjn7Hg3ymnqd5JFPEvJVeMW8A+jWjsejGCExCOa5RW4CsaGsRtVtga0RACbcpt1cXW
roVKhJLYjKWIgDKdewk4Kym/aNC0gXKtuP/wrrrflAVC0ZWEWUfX1foyUZEzi3KBqj7TH1HD
s8WpTMVk/v5t1bn/6SsBELyvDXsfv0DsXbYLWqD7Qe09/myP1fp+n9QJsHIYWmcEED/o5bDN
F5pifXLeGKJ5fSh5UejIj1VCY2BVJdYl756MFZTsg8SCpJGDtkKA5kKIfa4Xv4oGAT4PdyE2
97L5XBxc8qJlPBQrnMxtD6Iz09gqUG9VvCl7PiSEOXZfhtjIeC3wSGIAQMdCMDYL7BAt/gCj
bz7ec2bPQgAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTD_DINT" version="1.0.0">
						      <title>Down counter (DINT data type)</title>
						      <descr>&lt;HTML&gt;(Same as CTD but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTD_DINT block &lt;b&gt;counts down&lt;/b&gt; for each FALSE-to-TRUE transition of the input CD and sets the output Q when the accumulated value (CV) reaches the 0 value.&lt;br/&gt;
&lt;img src= ctdscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of LD set CV to the value of PV&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches 0 the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is 0 its value remains 0 until a rising edge of LD&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CD" type="BOOL">
									        <descr>Count-down on input rising edge</descr>
								</var>
								        <var name="LD" type="BOOL">
									        <descr>Preset counter input</descr>
								</var>
								        <var name="PV" type="DINT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Count-down output</descr>
								</var>
								        <var name="CV" type="DINT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="CDEDGE" type="BOOL"/>
								        <var name="MEMCD" type="BOOL"/>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		LD
	JMPCN	l0
	
	LD		PV
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD 	CD
	ANDN 	MEMCD
	ST 		CDEDGE
	
	LD 		CD
	ST 		MEMCD
	
	LD 		CDEDGE
	AND(	CV
	GT		-2147483648
	)
	JMPCN	l1
	
	LD		CV
	SUB		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	LE		0
	ST		Q
	

]]>
						</sourceCode>
						      <images>
							      <image height="200" name="ctdscheme.png" width="336">
								<![CDATA[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]]>
							</image>
							      <image height="48" icon="true" name="ctd48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADBElEQVRoge1YvW7bMBD+WHRs
AthDA1Bbpg7NVDRP4Ayd2jeQJmdpZ79C9naJJ3nu0k4Zmido4KlZm40EmiEGnO7XQaJ8okiL
st2Yaf0BhCTyJN7H++GJwA47/N8Qnn5yjRHR39WmA4Qo1HviGCPrGjVsArbS0ZN4aj0bt3G6
UIxwudCjwo7AttGaRqXMhwDOHTIzACdKpVMASJLJCMCZTw7AtHweAPhm66F11lSCCEIIEBGS
ZAKXjB3ELkwBjB39w7KddpS7YXIDAIfLJjd7j1IpkgQNEp02Mg4pcwIwVio9PTq+xZ268OpQ
KnzqGDtHQc5rARtJMoFS6dKNzIuXr3+BiBof/vH9eZfPBMG36xeWmFTPIS4EAJAyP7tTF70k
AQD0yu4ZE+kBGLGxldFWshQWyAAEEpAy76Ewta3c9Oj41tyPymZjBndsNObQOpsBqK1wG4Jc
SOtspnXW7ydvhFKpANAvhwZMzJATVutjkYGW4aeUucliFNDCCRhcXx1ACAGzUkDh/xuKgR6A
Xuk+SxOI1lk1HhwDPjAX2ghY3hdwFJNceSCAgJT5KxT+HwrXpvcZwGV5f4hFrBgXrL1jUqSU
eY2EUqkwwWsQYgEfgRmA8fXVgZnM9LtkbywCtsyQyVXQOqtIFCufBqhb4MH+A9b9y+sUAzH9
Uhp0DmLjn7Hg3ymnqd5JFPEvJVeMW8A+jWjsejGCExCOa5RW4CsaGsRtVtga0RACbcpt1cXW
roVKhJLYjKWIgDKdewk4Kym/aNC0gXKtuP/wrrrflAVC0ZWEWUfX1foyUZEzi3KBqj7TH1HD
s8WpTMVk/v5t1bn/6SsBELyvDXsfv0DsXbYLWqD7Qe09/myP1fp+n9QJsHIYWmcEED/o5bDN
F5pifXLeGKJ5fSh5UejIj1VCY2BVJdYl756MFZTsg8SCpJGDtkKA5kKIfa4Xv4oGAT4PdyE2
97L5XBxc8qJlPBQrnMxtD6Iz09gqUG9VvCl7PiSEOXZfhtjIeC3wSGIAQMdCMDYL7BAt/gCj
bz7ec2bPQgAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="CTD" version="1.0.0">
						      <title>Down counter</title>
						      <descr>&lt;HTML&gt;The CTD block &lt;b&gt;counts down&lt;/b&gt; for each FALSE-to-TRUE transition of the input CD and sets the output Q when the accumulated value (CV) reaches the 0 value.&lt;br/&gt;
&lt;img src= ctdscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of LD set CV to the value of PV&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches 0 the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is 0 its value remains 0 until a rising edge of LD&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="CD" type="BOOL">
									        <descr>Count-down on input rising edge</descr>
								</var>
								        <var name="LD" type="BOOL">
									        <descr>Preset counter input</descr>
								</var>
								        <var name="PV" type="INT">
									        <descr>Preset value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Count-down output</descr>
								</var>
								        <var name="CV" type="INT">
									        <descr>Counter current value</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="CDEDGE" type="BOOL"/>
								        <var name="MEMCD" type="BOOL"/>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		LD
	JMPCN	l0
	
	LD		PV
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD 		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	
	LD 		CD
	ST 		MEMCD
	
	LD 		CDEDGE
	AND(	CV
	GT		-32768
	)
	JMPCN	l1
	
	LD		CV
	SUB		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	LE		0
	ST		Q
	

]]>
						</sourceCode>
						      <images>
							      <image height="200" name="ctdscheme.png" width="336">
								<![CDATA[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]]>
							</image>
							      <image height="48" icon="true" name="ctd48.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADBElEQVRoge1YvW7bMBD+WHRs
AthDA1Bbpg7NVDRP4Ayd2jeQJmdpZ79C9naJJ3nu0k4Zmido4KlZm40EmiEGnO7XQaJ8okiL
st2Yaf0BhCTyJN7H++GJwA47/N8Qnn5yjRHR39WmA4Qo1HviGCPrGjVsArbS0ZN4aj0bt3G6
UIxwudCjwo7AttGaRqXMhwDOHTIzACdKpVMASJLJCMCZTw7AtHweAPhm66F11lSCCEIIEBGS
ZAKXjB3ELkwBjB39w7KddpS7YXIDAIfLJjd7j1IpkgQNEp02Mg4pcwIwVio9PTq+xZ268OpQ
KnzqGDtHQc5rARtJMoFS6dKNzIuXr3+BiBof/vH9eZfPBMG36xeWmFTPIS4EAJAyP7tTF70k
AQD0yu4ZE+kBGLGxldFWshQWyAAEEpAy76Ewta3c9Oj41tyPymZjBndsNObQOpsBqK1wG4Jc
SOtspnXW7ydvhFKpANAvhwZMzJATVutjkYGW4aeUucliFNDCCRhcXx1ACAGzUkDh/xuKgR6A
Xuk+SxOI1lk1HhwDPjAX2ghY3hdwFJNceSCAgJT5KxT+HwrXpvcZwGV5f4hFrBgXrL1jUqSU
eY2EUqkwwWsQYgEfgRmA8fXVgZnM9LtkbywCtsyQyVXQOqtIFCufBqhb4MH+A9b9y+sUAzH9
Uhp0DmLjn7Hg3ymnqd5JFPEvJVeMW8A+jWjsejGCExCOa5RW4CsaGsRtVtga0RACbcpt1cXW
roVKhJLYjKWIgDKdewk4Kym/aNC0gXKtuP/wrrrflAVC0ZWEWUfX1foyUZEzi3KBqj7TH1HD
s8WpTMVk/v5t1bn/6SsBELyvDXsfv0DsXbYLWqD7Qe09/myP1fp+n9QJsHIYWmcEED/o5bDN
F5pifXLeGKJ5fSh5UejIj1VCY2BVJdYl756MFZTsg8SCpJGDtkKA5kKIfa4Xv4oGAT4PdyE2
97L5XBxc8qJlPBQrnMxtD6Iz09gqUG9VvCl7PiSEOXZfhtjIeC3wSGIAQMdCMDYL7BAt/gCj
bz7ec2bPQgAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="R_TRIG" version="1.0.1">
						      <title>Rising edge detector</title>
						      <descr>&lt;HTML&gt;This function block is used to intercept a rising edge event; 
this means that the output Q value will be TRUE only when CLK goes from FALSE to TRUE.
&lt;br&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;As long as CLK stays TRUE, the output Q will be FALSE.&lt;/li&gt;
&lt;li&gt;As long as CLK stays FALSE, the output Q will be FALSE.&lt;/li&gt;
&lt;li&gt;When CLK goes from FALSE to TRUE (rising edge), the output Q will be TRUE.&lt;/li&gt;
&lt;li&gt;When CLK goes from TRUE to FALSE (falling edge), the output Q will be FALSE.&lt;/li&gt;
&lt;/ul&gt;
&lt;img src= r_trig.png&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="clk" type="BOOL">
									        <descr>Input for edge detection</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="q" type="BOOL">
									        <descr>Raising edge output</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="m" type="BOOL">
									        <initValue>FALSE</initValue>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	LD		clk
	ANDN	m
	ST		q

	LD		clk
	ST		m
]]>
						</sourceCode>
						      <images>
							      <image height="117" name="r_trig.png" width="218">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAANoAAAB1CAYAAAAoV//gAAAAAXNSR0IArs4c6QAAAARnQU1B
AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjAuMjHxIGmVAAAEI0lEQVR4Xu3d324MbxjA8be/O+C8EtwBTqQOOZcQdQWckkq4BBJC
XIW/iQtw6gx3gIQLcAn9ebzvyHa7amrss7PTzycZo7NtsynfPjNvd7cbuz8UYKn+a3tgiYQG
CYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCUYf2sbGxs8N1pmJBglGHdrsJDPVWGcm
GiQYbWiLJpipxroy0SDB6F/KoJtiXnGBdWaiQQKhQQKhQQKhQQKhQQKhQQKhQQKhQQKhQQKP
DBlgjA+99ACacTLRIIGJNkA30cZw18Z0X9jPRIMEQoMEQoMEQoMEQoMEhwrt48e6utVtFy60
G5o49uRJe2POiROl3LnT3mhev64fc/16OwAT1Tu0iOLs2VIeP65LyN0y8nxsfUW0V6+WsrNT
yrNn7SBMVO/Qbt+uUdy61Q788PRpKe/e1QgPK6KNz/fwYTsAE9YrtJg+376Vcv58O9CcOVMn
25Ur7UBPcRq5vS0yjo5eoX35UvcnT9b9EHGqGaE5XeQoOdRiyFCPHtVTza9f9y+MwJT1Cq2b
ZN1kGyJONd+8qdH9zbUdrKNeocW12NZWKS9ftgMzDlrSnxeLHyE+X6xexqpjXP/B1PU+dYxV
x+fP90YV11ubm3tXIvuKj4l4L19uB2DK4mkyfb161f0ErW5bW+2GZva2btverrdtbu7u7uzU
v8+K94nbfifuYt32ft4xbWOw6H7Z9m6rtDbPR/vxhWr78RnDV/DXl4nfWuW/kyd+QoLU5X04
qoQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQGCYQ2RDwpddEG
c4QGCYT2L8TLLHipBQ4gNEggNEiQF9r376XcvLl30SDe/vy5vQNMV05oEdO5c3X/6VO9non9
7HGYsJzXdbx2rZQPH0p5/76UY8faweb06Xosbltg1K/r2C3ld/dt/m1olj/RYlrFb8e4eHF/
ZOHGjRqhqcaELT+0iCjE79Jd5NSpun/7tu5hgnImWlg0zWbFYglMVN6qIxxhyw+tOzX808T6
08SDNbb80Lprs+5abV53ahmLJTBRlveHsLxPTznXaPfv130E102wOJW8dKnuX7yox2CickKL
67SYWLGPCRbf+Y8fr0v6cWrZXcfBRK32N34+eFDKvXs1tphqC4L7der488+Rmj91ZLxW9N99
tcv7d+/WwKw4MnF+hzUkWO1EgyNCaJBAaJBAaJBAaJBAaJBAaJBAaJBAaHCAeMBE96CJIYQG
PQwNbmkPwfoX3wVgrA6bjYkGCTyoGA4wf2b2t/8PTTToIQIb8s1eaHCAoYF1hAYJhAYJhAYJ
hAYJhAYJhAYJRv8Da5gCEw0SCA0SCA0SCA0SCA0SCA0SCA0SCA0SCA0SCA2WrpT/ATXobPt7
PTaqAAAAAElFTkSuQmCC]]>
							</image>
							      <image height="34" icon="true" name="rtrig34.png" width="34">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAApklEQVRYhe2VUQrEIAxEZ0pP
Vw/V9VA9X/qzLYvUNrGWTSEPBJEYhzFGIAiC4B4UEUUUa0GEZr+CoUuWDliF8Dv+LuQx7EI6
1UTJix15CDdCxp8eQQBH8zMEND+iw3PcOFJtmVVE0ODCJY4cUfQFptyjeVCWGUwZssxbXmxr
bhwZjfEtxaFy87WO7PerhSmr4tw4EkJKiOlj+WvYUCNlHt9/TRBcsQJT/izAApTRbQAAAABJ
RU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="F_TRIG" version="1.0.0">
						      <title>Falling edge detector</title>
						      <descr>&lt;HTML&gt;This function block is used to intercept a falling edge event; 
this means that the output Q value will be TRUE only when CLK goes from TRUE to FALSE.
&lt;br&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;As long as CLK stays TRUE, the output Q will be FALSE.&lt;/li&gt;
&lt;li&gt;As long as CLK stays FALSE, the output Q will be FALSE.&lt;/li&gt;
&lt;li&gt;When CLK goes from FALSE to TRUE (rising edge), the output Q will be FALSE.&lt;/li&gt;
&lt;li&gt;When CLK goes from TRUE to FALSE (falling edge), the output Q will be TRUE.&lt;/li&gt;
&lt;/ul&gt;
&lt;img src= f_trig.png &gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="clk" type="BOOL">
									        <descr>Input for edge detection</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="q" type="BOOL">
									        <descr>Falling edge output</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="m" type="BOOL">
									        <initValue>FALSE</initValue>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	LDN		clk
	AND		m
	ST		q

	LD		clk
	ST		m
]]>
						</sourceCode>
						      <images>
							      <image height="117" name="f_trig.png" width="218">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAANoAAAB1CAYAAAAoV//gAAAAAXNSR0IArs4c6QAAAARnQU1B
AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjAuMjHxIGmVAAAEIUlEQVR4Xu3dX25MYRjA4a92wH0l2AFupC65lxC1Am5JJSyBhBCr
8DexALfusAMkLMASqq/vOzJtR50x5p0zZ54nOY6eaZvJ8Ot7zteZdmN3TwEW6ljbAwskNEgg
NEggNEggNEggNEggNEggNEggNEggNEggNEggNEgw+NA2NjZ+bbDKTDRIMOjQJieZqcYqM9Eg
wWBDmzbBTDVWlYkGCQb/owy6KeYnLrDKTDRIIDRIIDRIIDRIIDRIIDRIIDRIIDRIIDRI4Jkh
cxjiUy89gWaYTDRIYKLNoZtoQ7hrQ7ovHGaiQQKhQQKhQQKhQQKhQYKZQvv0qa5uddvFi+2G
Jo49fdreOODkyVLu3m1vNG/e1I+5caMdgJHqHVpEce5cKU+e1CXkbhn5YGx9RbTXrpWys1PK
8+ftIIxU79Du3KlR3L7dDux59qyU9+9rhLOKaOPzPXrUDsCI9Qotps/376VcuNAONGfP1sl2
9Wo70FOcRm5vi4z10Su0r1/r/tSpup9HnGpGaE4XWSczLYbM6/Hjeqr57dvhhREYs16hdZOs
m2zziFPNt29rdP9ybQerqFdocS22tVXKq1ftwISjlvQPisWPEJ8vVi9j1TGu/2Dsep86xqrj
ixf7o4rrrc3N/SuRfcXHRLxXrrQDMGbxMpm+Xr/uvoNWt62tdkMzeVu3bW/X2zY3d3d3durf
J8X7xG1/Enexbvs/75C2IZh2v2z7t2Vamdej7T1QbT88Q3gEfz9M/NEy/5288BMSpC7vw7oS
GiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiTwws8xOepl1h6/
pTLRIIHQxiimV7cxCEKDBEKDBHmh/fhRyq1b9YK92+LtL1/aO8B45YQWMZ0/X/efP9drh9hP
HocRy1nev369lI8fS/nwoZTjx9vB5syZeixum8Ly/gy65f3Jx2raMdItfqLFtIrfjnHp0uHI
ws2bNUJTjRFbfGgRUYjfpTvN6dN1/+5d3cMI5Uy0MG2aTYrFEhipvFVHWGOLD607NfzbxPrb
xIMVtvjQumuz7lrtoO7UMhZLYKQs74+J5f3ByrlGe/Cg7iO4boLFqeTly3X/8mU9BiOVE1pc
p8XEin1MsPgqe+JEXdKPU8vuOg5Garkv/Hz4sJT792tsMdWmBPf71PHXn/Qy7dSRakn/3Ze7
vH/vXg3MiiMj50cZQILlTjRYE0KDBEKDBEKDBEKDBEKDBEKDBEKDBEKDI8QTJronTcxDaNDD
vMEt7ClY/+OrAAzVrNmYaJDAk4rhCAfPzP71/6GJBj1EYPN8sRcaHGHewDpCgwRCgwRCgwRC
gwRCgwRCgwSD/4Y1jIGJBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgtXyk8Nwnfoh5/N
fQAAAABJRU5ErkJggg==]]>
							</image>
							      <image height="34" icon="true" name="ftrig34.png" width="34">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAqElEQVRYhe2VYQqAIAyF34tO
V4eqDtX51o9aRJQ5S1iwDwQR3R5vToEgCIJ3UEQqROVdUELzkcAhd/O9ijJsQsh1GE5s42Mh
FbELsd6pzP0/dqQSboRQAC0icT0vR2TtmNS7suVx5YgL3DjS5vQ5+6nUOMo8gP0EmQeNBV0D
sM8dOWIj96MxO/hbR/Zap9D6W3DjSAg5Q3Sj5a9h5h1Jdc1lHjeOBMETC4IUMr87wVtwAAAA
AElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="SR" version="1.0.0">
						      <title>Bistable, set dominant</title>
						      <descr>&lt;HTML&gt;Bistable, set dominant&lt;/br&gt;&lt;/br&gt;
&lt;img src= srscheme.png &gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="s1" type="BOOL">
									        <descr>Logic input</descr>
								</var>
								        <var name="r" type="BOOL">
									        <descr>Reset input</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="q1" type="BOOL">
									        <descr>Bistable output</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[	
	LDN		r
	AND		q1
	OR		s1
	ST		q1
]]>
						</sourceCode>
						      <images>
							      <image height="146" name="srscheme.png" width="290">
								<![CDATA[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]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="RS" version="1.0.0">
						      <title>Bistable, reset dominant</title>
						      <descr>&lt;HTML&gt;Bistable, reset dominant&lt;/br&gt;&lt;/br&gt;
&lt;img src= rsscheme.png &gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="s" type="BOOL">
									        <descr>Logic input</descr>
								</var>
								        <var name="r1" type="BOOL">
									        <descr>Reset input</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="q1" type="BOOL">
									        <descr>Bistable output</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	LD		s
	OR		q1
	ANDN	r1
	ST		q1
]]>
						</sourceCode>
						      <images>
							      <image height="146" name="rsscheme.png" width="290">
								<![CDATA[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]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="TP" version="1.0.0">
						      <title>Pulse generator</title>
						      <descr>&lt;HTML&gt;Pulse generator&lt;/br&gt;&lt;/br&gt;
&lt;img src= ptscheme.png &gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="IN" type="BOOL">
									        <descr>Timer input source</descr>
								</var>
								        <var name="PT" type="UDINT">
									        <descr>Preset time value</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Pulse output</descr>
								</var>
								        <var name="ET" type="UDINT">
									        <descr>Actual timer value</descr>
								</var>
							</outputVars>
							      <externalVars>
								        <var name="sysTimer" type="UDINT">
									        <descr>1 ms system timer</descr>
								</var>
							</externalVars>
							      <localVars>
								        <var name="timStart" type="UDINT">
									        <descr>Time value at start of counting</descr>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check if in counting	*)

	LD		Q
	JMPCN	l10
	
	(*	Update actual time *)
	LD		sysTimer
	SUB		timStart
	ST		ET	
	
	(*	Update output *)
	LD		ET
	LT		PT
	ST		Q
	RET
	
l10:

	(*	Check for input status *)

	LD		IN
	JMPCN	l11
	
	LD		ET
	GE		PT
	RETC

	LD		sysTimer
	ST		timStart
	
	LD		TRUE
	ST		Q
	
l11:
	
	(*	No input and no counting active *)
	LD		0
	ST		ET
	

]]>
						</sourceCode>
						      <images>
							      <image height="146" name="ptscheme.png" width="265">
								<![CDATA[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]]>
							</image>
							      <image height="34" icon="true" name="tp34.png" width="34">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAxklEQVRYhe2Waw6EIAyEp8bT
6aFwD8X5un/MRqBkYB+mm/RLjLFaKENbBIIgCD5DVNWwimE0UJWv+AFYhhxvYCXvm8hP2Mqn
/f5GEcDOIT7ypJ8bRSKQmvVS+4I6q619vtLrG+N+rzndKDLYCn+PG0UWqOKOS7ajuNc2s6HJ
/mh2THOiXczyAyCaE1WEd1Z7wuJZc2pss7AcMVUYWOHAGVDyliJAGwxThQXvqGqc4CYQwXZ0
zxrNSTolycflf3HFd24UCQLGE7KZdlKKljJmAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="TON" version="1.0.0">
						      <title>On-delay timer</title>
						      <descr>&lt;HTML&gt;The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.&lt;/br&gt;&lt;/br&gt;
&lt;img src= tonscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;if IN is FALSE Q is false&lt;/li&gt;
&lt;li&gt;Q becomes TRUE as IN remains TRUE for PT milliseconds&lt;/li&gt;
&lt;li&gt;Q remains TRUE until IN remains TRUE&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="IN" type="BOOL">
									        <descr>Timer input source</descr>
								</var>
								        <var name="PT" type="UDINT">
									        <descr>Preset time value (ms)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Timer output</descr>
								</var>
								        <var name="ET" type="UDINT">
									        <descr>Timer current value (ms)</descr>
								</var>
							</outputVars>
							      <externalVars>
								        <var name="sysTimer" type="UDINT">
									        <descr>1 ms system timer</descr>
								</var>
							</externalVars>
							      <localVars>
								        <var name="timStart" type="UDINT">
									        <descr>Time value at start of counting</descr>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check if in counting	*)

	LD		IN
	JMPCN	lReset

	(*	Check if Q is TRUE *)
	LD		Q
	RETC
	
	(*	Check if already in counting *)
	LD		timStart
	EQ		0
	JMPCN	lUpdate

	(*	Start of counting *)
	LD		sysTimer
	ST		timStart
	
lUpdate:

	(*	Update timer and check if time elapsed *)
	LD		sysTimer
	SUB		timStart
	ST		ET
	GE		PT
	ST		Q
	RETCN

	(*	Limit actual time value *)
	LD		PT
	ST		ET
	RET

lReset:

	(*	Reset status *)
	LD		0
	ST		ET
	ST		timStart
	LD		FALSE
	ST		Q

]]>
						</sourceCode>
						      <images>
							      <image height="146" name="tonscheme.png" width="230">
								<![CDATA[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
AAAAAElFTkSuQmCC]]>
							</image>
							      <image height="58" icon="true" name="ton1.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAA6CAYAAAD2mdrhAAAD4klEQVRoge3YT4hVdRQH8M91
akhpIVOjmxYR1K4CIUTQyQYai3YWFVFtRPtjjNbCTUQgropqksqRqU1CloS0CjSw0EBECsqN
IESLNs0kTYvSjPG1+J3nez7nvfe7902TyvvC45537znfc869vz/nd+ijjz766KOPPvqojKLt
k2dvXwj+WgWbosmuIX/887yxLqkU1lWEGxbJT/sv3V2/o+01/wX6Cfzf6DQHrlwJLpevClzz
X6DtDK/V4kUXBfPJpbxUtLuMYv5Q2ydQ1kOPAXZDuwSu7yF02/DmxYzlCvwyM3VJbvcFFmon
vhEb8CDuwx1YGc9+xU84ia9wCP8skN+eE1iO7XgRw210VsZvDcbxG97HBGZ79N/THHgSp/G6
FPypkEcVxReXtJI8Gs9O4daQTwdHT6iSwAA+wH7pzR7DCO7BTnyNc0365+LeztAZwdGw3R9c
A9XCL5/AAA7gBZzH87g/kmigVntKWiCKkJtxDOvD9nxwHVAxibIJTGCjNHZHsVe10qIWtqP4
PTjfrcBTKoEn8JI0JB7C8SoOW3AcD+MvbA0fpZCbwHLsDvkVnCjrqAmbpLdfX9hP4OWQd4ev
bOQmsB0rpPG7t4yDFmzCFLZgsun+lDSxV4SvbOQkMCit8/Cq6uV0Pfh6SX6y6VktuIWvwVzS
nATGpHX+R62rTT5ag9+CD1t0vsUP4Wsslzg3ATiYS9qCnODrqPvYkEueU0qsiuvRTM5BvImn
cROWxf0aNuOjDrZ1H6s66FyGnATuAkUxjkcUS3a4OHexg/4bUs3Tis7BF8Un+CPOFXdmxJXM
2j1oKqdbJ223Hs9ZDLXc+xM3d7G7wk9OOb1YB5q//yvinARmkKrKongrQ3/fPPfaTdoGimK/
oqjvDTMZfpA3B85gWK22W6oqu2GHNMyeif/78FpXq1T0rZeKvDMZfpD3Bb6L67pMzgvYJs2D
oZAvZNqOxPX7TP2sBA7H9dFc0h6wscVnV+QmcFY6jKytEFQu1uJeafwfyjXKSeAC3gt5l/Kt
8hwUwU06oeUOuexldALT0unruVKh5WFTcM+Er2zkJjCrsbu+jdVlnHTBao3T2LiSnYoyG9ln
UjtkKb6U2iS9Yk1wLQvuT8sSlN2Jt0kV4xCOSMOpypwowvZIcB0M7tIom8AcHsceqdKcxDda
94hUmNVQC7kZ66QNcTI49gTnXMlYUK0zNyedmo5KY7fe5zmFz6VDz9Im/aV4IAJ/DHfH/Wnp
rZceNs3otbm7XDqQb8UtmT7PSuP9HV0m7GI0d2elNuEu6RQ1ptHcXRE60xrN3cPxy17n++ij
j+sc/wLOpNwgfFLcXQAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					    <functionBlock creationDate="0" lastModifiedDate="0" name="TOF" version="1.0.0">
						      <title>Off-delay timer</title>
						      <descr>&lt;HTML&gt;The TOF block produces a delayed de-activation of the output Q with respect of the input IN. The delay time is expressed in milliseconds on the PT input.&lt;/br&gt;&lt;/br&gt;
&lt;img src= tofscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;if IN is TRUE then Q is TRUE&lt;/li&gt;
&lt;li&gt;Q becomes FALSE after PT milliseconds from IN becomes FALSE&lt;/li&gt;
&lt;li&gt;Q remains FALSE until IN remains FALSE&lt;/li&gt;
&lt;/ul&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="IN" type="BOOL">
									        <descr>Timer input source</descr>
								</var>
								        <var name="PT" type="UDINT">
									        <descr>Preset time value (ms)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="Q" type="BOOL">
									        <descr>Timer output</descr>
								</var>
								        <var name="ET" type="UDINT">
									        <descr>Timer current value (ms)</descr>
								</var>
							</outputVars>
							      <externalVars>
								        <var name="sysTimer" type="UDINT">
									        <descr>1 ms system timer</descr>
								</var>
							</externalVars>
							      <localVars>
								        <var name="timStart" type="UDINT">
									        <descr>Time value at start of counting</descr>
								</var>
							</localVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="IL">
							<![CDATA[
	(*	Check if in counting	*)

	LD		IN
	JMPC	lReset

	(*	Check if falling edge of IN	*)
	LD		Q
	RETCN

	(*	Check if already in counting *)
	LD		timStart
	EQ		0
	JMPCN	lUpdate
	
	(*	Start of counting *)
	LD		sysTimer
	ST		timStart

lUpdate:
	
	(*	Update timer and check if time elapsed *)
	LD		sysTimer
	SUB		timStart
	ST		ET
	GE		PT
	STN		Q
	RETCN
	
	(*	Limit actual time value *)
	LD		PT
	ST		ET
	RET

lReset:

	(*	Reset status *)
	LD		0
	ST		ET
	ST		timStart
	LD		TRUE
	ST		Q

]]>
						</sourceCode>
						      <images>
							      <image height="146" name="tofscheme.png" width="243">
								<![CDATA[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]]>
							</image>
							      <image height="58" icon="true" name="tof1.png" width="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAA6CAYAAAD2mdrhAAAD50lEQVRoge3ZT4jVVRQH8M9P
a2ikxTDluHEV1a4CIURQs4HGop1FRdRq0P4Yai3cRATiqqgmqRyZWglNSUirQAOLMRCRgpqN
YLRy00xTtijNGF+Le57zfL437/5+b1KU94XH78y9537POb/fPfeee4ceeuihhx566KGHyija
dfy++u5ag04reUns5GLw7M8t25d1S3y9ccsifUWG3AlVvlYp3PBfoBfA9cZiObCUKJML7Va9
lrl3w3+BtitKrRaBFwWt5FJWKo67gqK1q+0DKGuhSwc7oV0AN/cUWr1y67X05SqcnZ24LLf7
Aku1Ct2KzXgED+IurIq+X/ELTuFrHMG/S2S36wAGsAsvY2UbnVXxW4cd+A0fYgznurTfVQ48
g9N4U3J+OuRhRfHlZa0kD0ffNO4M+XRwdIUqASzHR5iU3uxxbMT92INvcL5B/3y07QmdjZiK
sZPBtbya++UDWI5DeAkX8CIeiiAWUKs9Ky0QRciNOI5NMfZCcB1SMYiyAYxhizR3h3FAtZK5
FmOH8Udwvl+Bp1QAT+MVaUo8ihNVDDbhBB7D39geNkohN4AB7Av5NZwsa6gBo9Lbry/sJ/Fq
yPvCVjZyA9iFIWn+HihjoAmjmMA2jDe0T0iJPRS2spETQJ+0zsPrqh8T687XS+RTDX214Ba2
+nJJcwIYkdb5nzSvNvlodn4bPm7S+Q4/hq2RXOLcAOBwLmkTcpyvo25jcy55TimxJp5TmZx9
eBvP4TasiPYatuKTRcbWbaxZROcK5ARwLyiKHXhcsWy3S/OXFtF/S6p5mrG480XxKf6Mc8U9
GX6lYe06Gsrp5qTtdC80h8Gmtr9we4dxV9nJKaev1YHmn/+LOCeAWaSqsijeydA/2KKtXdIu
oCgmFUV9b5jNsIO8HDiDlWq1fVJV2Qm7pWn2fPx9EG90HJWKvk1SkXcmww7yvsD38dyQyXkR
O6U8GAz5YubYjfH8IVM/K4Cj8Xwil7QLbGmy2RG5AcxJh5H1FZzKxXo8IM3/I7mDcgK4iA9C
3msJ/lnRAkVwk05ouVMuexkdw4x0+nqhlGt5GA3u2bCVjdwAzlnYXd/F2jJGOmCthdPYDiVv
KspsZJ9L1yH9+Eq6JukW64JrRXB/Vpag7E68U6oYB3FMmk5VcqKIsceC63Bwl0bZAObxFPZL
leY4vtW8R6TCrIZayI3YIG2I48GxPzjnS/qCajdz89KpaUqau/V7nml8IR16+hv0+/FwOP4k
7ov2Gemtl542jej2cndAOpBvxx2ZNuek+f6eDgl7LS53z0nXhHulU9SIhcvdodCZsXC5ezR+
2et8Dz30cJPjP37X3iBpuO6PAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
				</functionBlocks>
				    <programs/>
				    <macros/>
				    <structs/>
				    <typedefs/>
				    <enums/>
				    <subranges/>
				    <interfaces/>
			</lib>  <lib fullXml="true" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\..\..\LogicLab\Libraries\PID.plclib" version="1.0.0">
				    <descr/>
				    <libWorkspace>
					    <folder id="603" name="PID">
						      <Pou name="FT_DERIV"/>
						      <Pou name="FT_INT"/>
						      <Pou name="FT_PID"/>
						      <Pou name="DEAD_BAND"/>
						      <Pou name="SGN"/>
					</folder>
				</libWorkspace>
				    <globalVars/>
				    <retainVars/>
				    <constantVars/>
				    <functions>
					    <function name="DEAD_BAND" version="1.0.0">
						      <descr>Linear transfer function with dead zone</descr>
						      <returnValue>REAL</returnValue>
						      <vars>
							      <inputVars>
								        <var name="x" type="REAL">
									        <descr>Input value</descr>
								</var>
								        <var name="l" type="REAL">
									        <descr>Lockout value</descr>
								</var>
							</inputVars>
						</vars>
						      <sourceCode type="ST">
							<![CDATA[(*
version 1.0	2 nov 2007
programmer 	hugo
tested by		tobias

DEAD_BAND ist eine lineare bertragungsfunktion mit Totzone. Die Funktion verschiebt den positiven Teil der Kurve um +L und den negativen Teil der Kurve um -L.
DEAD_BAND = X wenn Abs(X) > L wenn Abs(X) > L
DEAD_BAND = 0 wenn Abs(X) <= L
*)

IF ABS(x) > l THEN
	DEAD_BAND := x - SGN(x) * l;
ELSE
	DEAD_BAND := 0.0;
END_IF;

(* revision history
hm		2.11.07	rev 1.0
	original version
*)

]]>
						</sourceCode>
					</function>
					    <function name="SGN" version="1.0.0">
						      <descr>Calculates the signum of X.
SGN = +1 if X &gt; 0
SGN = 0 if X = 0
SGN = -1 if X &lt; 0
</descr>
						      <returnValue>REAL</returnValue>
						      <vars>
							      <inputVars>
								        <var name="X" type="REAL"/>
							</inputVars>
						</vars>
						      <sourceCode type="ST">
							<![CDATA[
	IF X > 0.0 THEN
		SGN := 1.0;
	ELSIF X < 0.0 THEN
		SGN := -1.0;
	ELSE
		SGN := 0.0;
	END_IF;

]]>
						</sourceCode>
					</function>
				</functions>
				    <functionBlocks>
					    <functionBlock name="FT_DERIV" version="1.0.0">
						      <descr>D-link, or LZI-transfer element, which has a diferentiating
transfer behavior. At the output of FT_DERIV the derivative is over time T
in seconds. When the input signal increases in one second from 3 to 4
then the output 1 * K (K * ? X / ? T = 1 * (4-3) / 1 = 1</descr>
						      <vars>
							      <inputVars>
								        <var name="in" type="REAL">
									        <descr>Signal input</descr>
								</var>
								        <var name="K" type="REAL">
									        <descr>Derivative gain</descr>
									        <initValue>1</initValue>
								</var>
								        <var name="run" type="BOOL">
									        <descr>Block enable</descr>
									        <initValue>1</initValue>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="out" type="REAL">
									        <descr>Signal output</descr>
								</var>
							</outputVars>
							      <externalVars>
								        <var name="sysTimer" type="UDINT">
									        <descr>System clock in ms</descr>
								</var>
							</externalVars>
							      <localVars>
								        <var name="old" type="REAL"/>
								        <var name="tx" type="DWORD"/>
								        <var name="last" type="DWORD"/>
								        <var name="init" type="BOOL"/>
							</localVars>
						</vars>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="ST">
							<![CDATA[(*
version 1.3	29 oct 2007
programmer 	hugo
tested by		tobias

FT_deriv calculates the derivate over the signal "in" with Faktor "K".
a run input enables or stops the calculation, if left unconnected its true and therfore the calculation is executed.
if K is not specified the default is 1.

*)

(* read system time *)
tx := sysTimer;

(* init on firsat startup *)
IF NOT init THEN
	init := TRUE;
	old := in;
	last := tx;
END_IF;
IF run AND tx - last > 0 THEN
	out := (in - old) / TO_REAL(tx - last) * 1000.0 * K;
	last := tx;
ELSE
	out := 0.0;
	last := tx;
END_IF;
old := in;


(*
hm 3.1.2007			rev 1.1
	added init code for startup
	set the default for K to 1

hm	15. sep 2007	rev 1.2
	replaced Time() with T_PLC_US for compatibility and performance reasons
	increased accuracy and work in microseconds internally

hm 29 oct 2007	rev 1.3
	prohibit calculation when tx - last = 0 to avoid division by 0 and increase accuracy on fast systems
*)

]]>
						</sourceCode>
					</functionBlock>
					    <functionBlock name="FT_INT" version="1.0.0">
						      <descr>Integrator module</descr>
						      <vars>
							      <inputVars>
								        <var name="in" type="REAL">
									        <descr>Signal input</descr>
								</var>
								        <var name="K" type="REAL">
									        <descr>Integral gain</descr>
									        <initValue>1</initValue>
								</var>
								        <var name="run" type="BOOL">
									        <descr>Block enable</descr>
									        <initValue>1</initValue>
								</var>
								        <var name="rst" type="BOOL">
									        <descr>Block reset</descr>
								</var>
								        <var name="out_min" type="REAL">
									        <descr>Lower output limit</descr>
									        <initValue>-1E37</initValue>
								</var>
								        <var name="out_max" type="REAL">
									        <descr>Upper output limit</descr>
									        <initValue>1E37</initValue>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="out" type="REAL">
									        <descr>Signal output</descr>
								</var>
							</outputVars>
							      <externalVars>
								        <var name="sysTimer" type="UDINT">
									        <descr>System clock in ms</descr>
								</var>
							</externalVars>
							      <localVars>
								        <var name="last" type="UDINT"/>
								        <var name="in_last" type="REAL"/>
								        <var name="init" type="BOOL"/>
								        <var name="tc" type="UDINT"/>
								        <var name="out1" type="REAL"/>
								        <var name="out2" type="REAL"/>
							</localVars>
						</vars>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="ST">
							<![CDATA[(*
version 1.9	16. mar 2008
programmer 	hugo
tested by		tobias

FT_int is an integrator with input IN and factor K.
integration is only done while run = true, if run is false integration is stopped and the out remains at the last value.
if run is left unconnected, run is considered true by the function block.
the output ET will display the total integration time from last reset.
a rst input will reset output and the timer ET to 0.
the out_min and out_max values can be set to ,imit the output value range. 
the default for K is 1.
*)

(* read and store system time *)
tc := sysTimer - last;
last := sysTimer;

(* startup initialisation *)
IF rst OR NOT init THEN
	out1 := 0.0;
	out2 := 0.0;
	init := TRUE;
ELSIF run AND tc > 0 THEN
	out1 := out1 + (in + in_last) * TO_REAL(tc) * K * 0.0005;
	IF ABS(out1) > ABS(out2) THEN
		out2 := out2 + out1;
		out1:= 0.0;
	END_IF;
END_IF;

in_last := in;
out := out1 + out2;

IF out > out_max THEN
	out2 := out_max;
	out1 := 0.0;
	out := out_max;
ELSIF out < out_min THEN
	out2 := out_min;
	out1 := 0.0;
	out := out_min;
END_IF;


(*
hm 13.12.2006	rev 1.1
	changed to "trapezregel" which increases accuracy
	before out := out + in * time new: out := out + (in + in_last) / 2 * time

hm 15.1.2007		rev 1.2
	added default for k to be 1.

hm	15.9.2007		rev 1.3
	replaced time() with T_PLC_US for compatibility and performance reason
	increased internal accuracy to microseconds

hm 29. oct 2007		rev 1.4
	changed code so int will not be called is time difference is 0 to increase accuracy on systems
	with cycle times below 1ms

hm	2. dec 2007	 	rev 1.5
	changed code for better performance

hm	5. jan 2008		rev 1.6
	further improvements in performance

hm	8. feb 2008		rev 1.7
	deleted limits +/- 1000 now limit is the range of real
	added variables out1 and out2 to extend the resolution
	corrected an error with elapsed time
	deleted unusfull output ET

hm	13. mar 2008	rev 1.8
	changed preset value out_min to -1e37.
	stop integrator at the limits.

hm	16. mar 2008	rev 1.9
	added type conversion to avoid warning under codesys 3.0

*)

]]>
						</sourceCode>
					</functionBlock>
					    <functionBlock name="FT_PID" version="1.0.0">
						      <descr>&lt;HTML&gt;&lt;b&gt;FT_PID&lt;/b&gt; is a PID controller of the following formula works:&lt;/br&gt;
&lt;p align= center &gt;Y = KP * ( IN + 1/TN * INTEG( IN ) + TV * DERIV( IN ))&lt;/p&gt;
The control parameters are given in the form of KP, TN and TV, and if there are parameters KP, KI and KD they can be converted using the following formula:&lt;/br&gt;
&lt;p align= center &gt;TN = KP/KI and TV = KD/KP&lt;/p&gt;
The input values ILIM_H and ILIM_L limit the working area of the internal integrator. With RST, the internal integrator will always set to 0. The output LIM signals that the integrator runs one of the limits or ILIM_L ILIM_H.&lt;/br&gt;
The PI controller is free running and uses the trapezoidal rule to calculate the integrator for the highest accuracy and optimal speed.&lt;/br&gt;
The following graph illustrates the internal structure of the controller:&lt;/br&gt;
&lt;img src= pidscheme.png  align= center &gt;&lt;/br&gt;
The default values of the input parameters are predefned as follows:&lt;/br&gt;
&lt;ul&gt;
&lt;li&gt;KP = 1&lt;/li&gt;
&lt;li&gt;TN = 1s&lt;/li&gt;
&lt;li&gt;TV = 1s&lt;/li&gt;
&lt;li&gt;ILIM_L =-1E38&lt;/li&gt;
&lt;li&gt;ILIM_H =+1 E38&lt;/li&gt;
&lt;/ul&gt;
&lt;b&gt;Anti Wind-Up&lt;/b&gt;&lt;/br&gt;
Control modules with integrator tend to the so-called &lt;b&gt;wind-up efect&lt;/b&gt;. A wind-up means that the integrator module continuously run again because, for example, the control signal Y is at a limit and the system can not compensate the deviation, which then leads to subsequent transition into the control range until a long and time-consuming dismantling of the integrator value and the scheme only respond delayed.&lt;/br&gt;
Since the integrator is only necessary to compensate the deviation for all other control units, and the range of the integrator should be limited with the values of ILIM. The Integrator then reaches a limit and stops remaining at the last valid value.&lt;/br&gt;
For other wind-up action, the integrator can be controlled with the input IEN = FALSE any time separately, the Integrator only runs when IEN = TRUE.&lt;/br&gt;&lt;/br&gt;
&lt;b&gt;FT_PD&lt;/b&gt; can be used in conjunction with the modules CTRL_IN and CTRL_OUT to establish a PD controller.</descr>
						      <vars>
							      <inputVars>
								        <var name="actual" type="REAL">
									        <descr>Signal actual value (feedback)</descr>
								</var>
								        <var name="set_point" type="REAL">
									        <descr>Controller setpoint</descr>
								</var>
								        <var name="noise" type="REAL">
									        <descr>Noise value for filtering</descr>
								</var>
								        <var name="offset" type="REAL">
									        <descr>Output offset</descr>
								</var>
								        <var name="manual_in" type="REAL">
									        <descr>Manual signal input</descr>
								</var>
								        <var name="manual" type="BOOL">
									        <descr>Manual mode enable</descr>
								</var>
								        <var name="rst" type="BOOL">
									        <descr>Controller reset</descr>
									        <initValue>FALSE</initValue>
								</var>
								        <var name="int_band" type="REAL">
									        <descr>Integrator input working range</descr>
									        <initValue>100</initValue>
								</var>
								        <var name="KP" type="REAL">
									        <descr>Proportional gain</descr>
									        <initValue>1.0</initValue>
								</var>
								        <var name="TN" type="REAL">
									        <descr>Integral gain</descr>
									        <initValue>1.0</initValue>
								</var>
								        <var name="TV" type="REAL">
									        <descr>Derivative gain</descr>
									        <initValue>1.0</initValue>
								</var>
								        <var name="limit_L" type="REAL">
									        <descr>Output signal lower limit</descr>
									        <initValue>-1000</initValue>
								</var>
								        <var name="limit_H" type="REAL">
									        <descr>Output signal upper limit</descr>
									        <initValue>1000</initValue>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="y" type="REAL">
									        <descr>Output signal</descr>
								</var>
								        <var name="diff" type="REAL">
									        <descr>Actual error value</descr>
								</var>
								        <var name="lim" type="BOOL">
									        <descr>In-limit output status</descr>
								</var>
								        <var name="overflow" type="BOOL">
									        <descr>Integral overflow status</descr>
								</var>
							</outputVars>
							      <localVars>
								        <var name="integ" type="FT_INT"/>
								        <var name="deriv" type="FT_DERIV"/>
								        <var name="int_limit_L" type="REAL">
									        <initValue>-1000</initValue>
								</var>
								        <var name="int_limit_H" type="REAL">
									        <initValue>1000</initValue>
								</var>
							</localVars>
						</vars>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="ST">
							<![CDATA[(*
version 1.6	5 jan 2008
programmer 	hugo
tested by		tobias

FT_PID is a pid controller with manual functionality.
The PID controller works according to the fomula Y = KP * ( e + 1/TN * INTEG(e) + TV * DERIV(e)) + offset, while e = set_point - actual.
a rst will reset all internal data, while a switch to manual will cause the controller to follow the function Y = manual_in + offset.
limit_h and Limit_l set the possible output range of Y.
the output flags lim will signal that the output limits are active and overflow will signal that the integrator has reached the max or min limit.  

since rev 1.1 the "trapezregel is used for more accuracy.
rev 1.2 added selective integratin which means the integrative component is only active within a small range of the target value 
this avoids the integrator to go to limits while an input setpoint change happened and is only causing overshoots.
the int_band is by default 100 which means the int is active all the time and if set to for example to 0.1 the integrator is only active
while the input is between 0.9 and 1.1 of the set_point value.

default values for KP = 1, TN = 1, TV = 1, LIMIT_L = -1000, LIMIT_H = +1000.
*)

IF NOT rst AND NOT manual THEN
	(* calculate the process error *)
	diff := DEAD_BAND(set_point - actual, noise);
	IF ABS(diff) <= int_band AND NOT overflow AND TN > 0.0 THEN
		(* integrator is within int_band and needs to be run *)
		integ(in := diff, K := 1.0/TN, run := TRUE, rst := FALSE, out_min := int_limit_L, out_max := int_limit_H);
		(* check if integrator has reached its limits and set overflow *)
		IF integ.out >= int_limit_H OR integ.out <= int_limit_L THEN
			overflow := TRUE;
		END_IF;
	ELSE
		(* int_band is exceeded, integrator needs to be cleared *)
		integ(rst := TRUE);
	END_IF;
	(* calculate the derivative part *)
	deriv(in := diff, K := TV);
	(* add up all parts *)
	y := KP * (integ.out + deriv.out + diff);
ELSIF rst THEN
	integ(rst := TRUE);		(* reset the integrator *)
	overflow := FALSE;		(* clear the overflow flag *)
	y := (limit_H + limit_L) * 0.5 - offset;	(* set the output between limit_L and limit_L offset will be added again at the end *)
ELSIF manual THEN
	y := manual_in;
	integ(rst := TRUE);		(* make sure integrator is reset to 0 *)
	overflow := FALSE;		(* manual operation will cancel overflow because integrator was reset *)
END_IF;

(* add offset to Y *)
y := y + offset;

(* limit the outputs and set the lim flag if necessary *)
IF y > limit_H THEN
	y := limit_H;
	lim := TRUE;
ELSIF y < limit_L THEN
	y := limit_L;
	lim := TRUE;
ELSE
	lim := FALSE;
END_IF;



(* revision history

hm 1.12.2006	 	rev 1.1
	changed algorithm to trapezregel for higher accuracy.

hm 3.1.2007		rev 1.2
	added integ_band to select when the integrator is active.

hm	3.3.2007		rev 1.3
	added default values to inputs KP, TN, TV, LIMIT_L und LIMIT_H.

hm 31.oct 2007	rev 1.4
	total rewrite of the module to avoid failures when one of the limits is 0

hm	3.11.2007	rev 1.5
	added noise input to filter noise
	added output diff
	set limit output false when output is within limits
	overfolw was not set correctly

hm	5. jan 2008	rev 1.6
	improved code for better performance
*)

]]>
						</sourceCode>
						      <images>
							      <image height="258" name="pidscheme.png" width="502">
								<![CDATA[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]]>
							</image>
							      <image height="100" icon="true" name="pid1.png" width="75">
								<![CDATA[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]]>
							</image>
						</images>
					</functionBlock>
				</functionBlocks>
				    <programs/>
				    <macros/>
				    <structs/>
				    <typedefs/>
				    <enums/>
				    <subranges/>
				    <interfaces/>
			</lib>  <lib fullXml="false" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\Libraries\FileSystem.pll"><![CDATA[	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	FS_OpenMode: ( { DE:"File open mode" }
		FM_RT, { DE:"Read text file" }
		FM_WT, { DE:"Write new text file" }
		FM_AT, { DE:"Append to an existing text file" }
		FM_RB, { DE:"Read binary file" }
		FM_WB, { DE:"Write binary file" }
		FM_AB, { DE:"Append binary file" }
		FM_RUT, { DE:"Read/update text file" }
		FM_WUT, { DE:"Write/update new text file" }
		FM_AUT, { DE:"Append/update to an existing text file" }
		FM_RUB, { DE:"Read/update binary file" }
		FM_WUB, { DE:"Write/update binary file" }
		FM_AUB { DE:"Append/update binary file" }
	);

	FS_SeekMode: ( { DE:"File seek mode" }
		SEEK_SET, { DE:"Move cursor to the initial position of the stream" }
		SEEK_CUR, { DE:"Current position of the cursor" }
		SEEK_END  { DE:"Move cursor to the end of the stream" }
	);

END_TYPE


	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	FS_FILE_HANDLE : DINT; 
	FS_FIND_HANDLE : DINT; 
END_TYPE


	(*********************)
	(*                   *)
	(*     FUNCTIONS     *)
	(*                   *)
	(*********************)

FUNCTION FS_FileExists : BOOL
{ DE:"Check if the specified file exists or not
	The function returns a BOOL with the following meanings
	TRUE = Specified file exists.
	FALSE =	Specified file does not exists or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"File name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_DeleteFile : BOOL
{ DE:"Delete a file.
	The function returns a BOOL with the following meaning:
	TRUE = File deleted.
	FALSE =	Cannot delete file or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"File name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_OpenFile : FS_FILE_HANDLE
{ DE:"Open a file in the specified mode.
	The function returns an UDINT with the following meaning:
	0 = No file found or Invalid calling task
	Otherwise = handle of the file.
" }
        
	VAR_INPUT
		name	: STRING;		{ DE:"File name" }
		mode	: FS_OpenMode;	{ DE:"File open mode" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_OpenFileSync : FS_FILE_HANDLE
{ DE:"Open a file with SYNC mode on (every write ends with sync)
	The function returns an UDINT with the following meaning:
	0 = No file found.
	-1 = Invalid calling task
	Otherwise = handle of the file.
" }
        
	VAR_INPUT
		name	: STRING;		{ DE:"File name" }
		mode	: FS_OpenMode;	{ DE:"File open mode" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CloseFile : BOOL
{ DE:"Close the specified file.
	The function returns a BOOL with the following meaning:
	TRUE = File closed.
	FALSE = An error occurred or invalid calling task
" }
        
	VAR_INPUT
		handle	: FS_FILE_HANDLE;	{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_SeekFile : BOOL
{ DE:"Seek a position into the file.
	TRUE = Cursor position set.
	FALSE = An error occurred or invalid calling task
" }
        
	VAR_INPUT
		handle	: FS_FILE_HANDLE;	{ DE:"Handle of the file" }
		seekmode : FS_SeekMode;	{ DE:"Seek position" }
		offset	: DINT;		{ DE:"Offset from specified position" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_WriteFile : UDINT
{ DE:"Write binary data to the specified file.
The function returns the number of bytes written, or
	0 = Error writing
	-1 = Invalid calling task
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		data : DWORD;		{ DE:"Buffer to write" }
		len : UDINT;		{ DE:"Data length" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_ReadFile : UDINT
{ DE:"Read binary data from the specified file.
The function returns the number of bytes read, or
	0 = Error reading
	-1 = Invalid calling task
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		data : DWORD;		{ DE:"Buffer for data read" }
		len : UDINT;		{ DE:"Data length" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_WriteString : BOOL
{ DE:"Write a STRING to the specified file. Returns FALSE if error or invalid calling task" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		str : STRING;		{ DE:"String to write" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_ReadString : BOOL
{ DE:"Read a STRING from the specified file. Returns FALSE if error or invalid calling task" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		str : STRING;		{ DE:"String for data read" }
		len : UDINT;		{ DE:"Data length" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FileEOF : BOOL
{ DE:"Test if end of file is reached.
The function returns a BOOL with the following meaning:
	TRUE	=	End of file reached.
	FALSE	=	End of file not reached yet.
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FileTell : DINT
{ DE:"Returns the actual position of the file:
	-1 in case of error.
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION


FUNCTION FS_FindFirstFile : FS_FIND_HANDLE
{ DE:"Searches for files on the disk, starting on path and using the specified filter with wildcard.
Returns an handle that can be passed to FS_Find* functions, or 0 if no files found; returns -1 for invalid calling task" }
	VAR_INPUT
		path: STRING;  {DE:"Starting path for seaching"}
		filter: STRING;  {DE:"Filter with wildcards"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FindNextFile : BOOL
{ DE:"Searches the next matching file. Returns FALSE if no more files are found or invalid calling task" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FindClose : BOOL
{ DE:"Close a search handle" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_GetFileName : STRING
{ DE:"Returns the name of a matching file of a search" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_GetFileSize : UDINT
{ DE:"Returns the size of a matching file of a search" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_IsDirectory : BOOL
{ DE:"Returns if matching file is a directory" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_IsWritable : BOOL
{ DE:"Returns if matching file is writable" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_GetFileTime : BOOL
{ DE:"Returns the date and time of a matching file of a search" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
		day: @USINT;
		month: @USINT;
		year: @UINT;
		dayOfWeek: @UINT;
		hours: @USINT;
		minutes: @USINT;
		seconds: @USINT;
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CopyFile : BOOL
{ DE:"Copy a file" }
	VAR_INPUT
		src: STRING;
		dest: STRING;
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CopyFileSync : BOOL
{ DE:"Copy a file with SYNC mode on (every segment write ends with sync)" }
	VAR_INPUT
		src: STRING;
		dest: STRING;
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_MoveFile : BOOL
{ DE:"Move or rename a file" }
	VAR_INPUT
		src: STRING;
		dest: STRING;
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_DirExists : BOOL
{ DE:"Check if the specified directory exists or not
	The function returns a BOOL with the following meanings
	TRUE = Specified directory exists.
	FALSE =	Specified directory does not exists or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"Directory name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CreateDir : BOOL
{ DE:"Create specified directory if not exists
	The function returns a BOOL with the following meanings
	TRUE = Specified directory created.
	FALSE =	Cannot create directory or directory already exists or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"Directory name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Flush : BOOL
{ DE:"Force writing on specified handle.
	The function returns a BOOL with the following meaning:
	TRUE = flush ok
	FALSE = An error occurred or invalid calling task
" }
        
	VAR_INPUT
		handle	: FS_FILE_HANDLE;	{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Sync : BOOL
{ DE:"Sync all modifies on external drivers (only POSIX compatible targets)" }
	VAR_INPUT
		dmy: BOOL;
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION


FUNCTION FS_GetFreeSpace : DINT
{ DE:"Returns the free space in Kbytes of the volume path specified:
	-1 in case of error.
" }
	VAR_INPUT
		path	: STRING;	{ DE:"Path name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION


FUNCTION FS_Unmount : BOOL
{ DE:"Unmount the mount point specified" }
	VAR_INPUT
		mountpoint	: STRING;	{ DE:"Mountpoint name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE
	FS_ERROR: (
		FS_NOT_IMPL_OR_NOT_SUPP		:= -100, {DE: "Not implemented or not supported"}
		FS_REALTIME_NOT_ALLOWED		:= -1,	{DE: "Realtime task not allowed"}
		FS_NOT_MOUNTED				:= -2,	{DE: "Mountpoint not mounted"}
		FS_NOERR					:= 0,	{DE: "No error" }
		EPERM 						:= 1,	{DE: "Operation not permitted" }
		ENOENT 						:= 2,	{DE: "No such file or directory" }
		ESRCH 						:= 3,	{DE: "No such process" }
		EINTR 						:= 4,	{DE: "Interrupted system call" }
		EIO 						:= 5,	{DE: "Input/output error" }
		ENXIO 						:= 6,	{DE: "No such device or address" }
		E2BIG 						:= 7,	{DE: "Argument list too long" }
		ENOEXEC 					:= 8,	{DE: "Exec format error" }
		EBADF 						:= 9,	{DE: "Bad file descriptor" }
		ECHILD 						:= 10, 	{DE: "No child processes" }
		EAGAIN 						:= 11,  {DE: "Resource temporarily unavailable" }
		ENOMEM						:= 12,  {DE: "Cannot allocate memory" }
		EACCES 						:= 13,  {DE: "Permission denied" }
		EFAULT 						:= 14,  {DE: "Bad address" }
		ENOTBLK 					:= 15,  {DE: "Block device required" }
		EBUSY						:= 16,  {DE: "Device or resource busy" }
		EEXIST						:= 17,  {DE: "File exists" }
		EXDEV 						:= 18,  {DE: "Invalid cross-device link" }
		ENODEV 						:= 19,  {DE: "No such device" }
		ENOTDIR 					:= 20,  {DE: "Not a directory" }
		EISDIR 						:= 21,  {DE: "Is a directory" }
		EINVAL 						:= 22,  {DE: "Invalid argument" }
		ENFILE 						:= 23,  {DE: "Too many open files in system" }
		EMFILE 						:= 24,  {DE: "Too many open files" }
		ENOTTY 						:= 25,  {DE: "Inappropriate ioctl for device" }
		ETXTBSY 					:= 26,  {DE: "Text file busy" }
		EFBIG 						:= 27,  {DE: "File too large" }
		ENOSPC 						:= 28,  {DE: "No space left on device" }
		ESPIPE 						:= 29,  {DE: "Illegal seek" }
		EROFS 						:= 30,  {DE: "Read-only file system" }
		EMLINK 						:= 31,  {DE: "Too many links" }
		EPIPE 						:= 32,  {DE: "Broken pipe" }
		EDOM 						:= 33,  {DE: "Numerical argument out of domain" }
		ERANGE 						:= 34,  {DE: "Numerical result out of range" }
		EDEADLK 					:= 35,  {DE: "Resource deadlock avoided" }
		ENAMETOOLONG 				:= 36,  {DE: "File name too long" }
		ENOLCK 						:= 37,  {DE: "No locks available" }
		ENOSYS 						:= 38,  {DE: "Function not implemented" }
		ENOTEMPTY 					:= 39,  {DE: "Directory not empty" }
		ELOOP 						:= 40,  {DE: "Too many levels of symbolic links" }
		ENOMSG 						:= 42,  {DE: "No message of desired type" }
		EIDRM 						:= 43,  {DE: "Identifier removed" }
		ECHRNG 						:= 44,  {DE: "Channel number out of range" }
		EL2NSYNC 					:= 45,  {DE: "Level 2 not synchronized" }
		EL3HLT 						:= 46,  {DE: "Level 3 halted" }
		EL3RST 						:= 47,  {DE: "Level 3 reset" }
		ELNRNG 						:= 48,  {DE: "Link number out of range" }
		EUNATCH 					:= 49,  {DE: "Protocol driver not attached" }
		ENOCSI 						:= 50,  {DE: "No CSI structure available" }
		EL2HLT 						:= 51,  {DE: "Level 2 halted" }
		EBADE 						:= 52,  {DE: "Invalid exchange" }
		EBADR 						:= 53,  {DE: "Invalid request descriptor" }
		EXFULL 						:= 54,  {DE: "Exchange full" }
		ENOANO 						:= 55,  {DE: "No anode" }
		EBADRQC 					:= 56,  {DE: "Invalid request code" }
		EBADSLT 					:= 57,  {DE: "Invalid slot" }
		EBFONT 						:= 59,  {DE: "Bad font file format" }
		ENOSTR 						:= 60,  {DE: "Device not a stream" }
		ENODATA 					:= 61,  {DE: "No data available" }
		ETIME 						:= 62,  {DE: "Timer expired" }
		ENOSR 						:= 63,  {DE: "Out of streams resources" }
		ENONET 						:= 64,  {DE: "Machine is not on the network" }
		ENOPKG 						:= 65,  {DE: "Package not installed" }
		EREMOTE 					:= 66,  {DE: "Object is remote" }
		ENOLINK 					:= 67,  {DE: "Link has been severed" }
		EADV 						:= 68,  {DE: "Advertise error" }
		ESRMNT 						:= 69,  {DE: "Srmount error" }
		ECOMM 						:= 70,  {DE: "Communication error on send" }
		EPROTO 						:= 71,  {DE: "Protocol error" }
		EMULTIHOP 					:= 72,  {DE: "Multihop attempted" }
		EDOTDOT 					:= 73,  {DE: "RFS specific error" }
		EBADMSG 					:= 74,  {DE: "Bad message" }
		EOVERFLOW 					:= 75,  {DE: "Value too large for defined data type" }
		ENOTUNIQ 					:= 76,  {DE: "Name not unique on network" }
		EBADFD 						:= 77,  {DE: "File descriptor in bad state" }
		EREMCHG 					:= 78,  {DE: "Remote address changed" }
		ELIBACC 					:= 79,  {DE: "Can not access a needed shared library" }
		ELIBBAD 					:= 80,  {DE: "Accessing a corrupted shared library" }
		ELIBSCN 					:= 81,  {DE: ".lib section in a.out corrupted" }
		ELIBMAX 					:= 82,  {DE: "Attempting to link in too many shared libraries" }
		ELIBEXEC 					:= 83,  {DE: "Cannot exec a shared library directly" }
		EILSEQ 						:= 84,  {DE: "Invalid or incomplete multibyte or wide character" }
		ERESTART 					:= 85,  {DE: "Interrupted system call should be restarted" }
		ESTRPIPE 					:= 86,  {DE: "Streams pipe error" }
		EUSERS 						:= 87,	{DE: "Too many users" }
		ENOTSOCK 					:= 88, 	{DE: "Socket operation on non-socket" }
		EDESTADDRREQ 				:= 89, 	{DE: "Destination address required" }
		EMSGSIZE 					:= 90, 	{DE: "Message too long" }
		EPROTOTYPE 					:= 91, 	{DE: "Protocol wrong type for socket" }
		ENOPROTOOPT 				:= 92, 	{DE: "Protocol not available" }
		EPROTONOSUPPORT 			:= 93, 	{DE: "Protocol not supported" }
		ESOCKTNOSUPPORT 			:= 94, 	{DE: "Socket type not supported" }
		EOPNOTSUPP 					:= 95, 	{DE: "Operation not supported" }
		EPFNOSUPPORT 				:= 96, 	{DE: "Protocol family not supported" }
		EAFNOSUPPORT 				:= 97, 	{DE: "Address family not supported by protocol" }
		EADDRINUSE 					:= 98, 	{DE: "Address already in use" }
		EADDRNOTAVAIL 				:= 99, 	{DE: "Cannot assign requested address" }
		ENETDOWN 					:= 100,	{DE: "Network is down" }
		ENETUNREACH 				:= 101,	{DE: "Network is unreachable" }
		ENETRESET 					:= 102,	{DE: "Network dropped connection on reset" }
		ECONNABORTED 				:= 103,	{DE: "Software caused connection abort" }
		ECONNRESET 					:= 104,	{DE: "Connection reset by peer" }
		ENOBUFS 					:= 105,	{DE: "No buffer space available" }
		EISCONN 					:= 106,	{DE: "Transport endpoint is already connected" }
		ENOTCONN 					:= 107,	{DE: "Transport endpoint is not connected" }
		ESHUTDOWN 					:= 108, {DE: "Cannot send after transport endpoint shutdown" }
		ETOOMANYREFS 				:= 109, {DE: "Too many references: cannot splice" }
		ETIMEDOUT 					:= 110, {DE: "Connection timed out" }
		ECONNREFUSED 				:= 111, {DE: "Connection refused" }
		EHOSTDOWN 					:= 112, {DE: "Host is down" }
		EHOSTUNREACH 				:= 113, {DE: "No route to host" }
		EALREADY 					:= 114, {DE: "Operation already in progress" }
		EINPROGRESS 				:= 115, {DE: "Operation now in progress" }
		ESTALE 						:= 116, {DE: "Stale file handle" }
		EUCLEAN 					:= 117, {DE: "Structure needs cleaning" }
		ENOTNAM 					:= 118, {DE: "Not a XENIX named type file" }
		ENAVAIL						:= 119, {DE: "No XENIX semaphores available" }
		EISNAM 						:= 120, {DE: "Is a named type file" }
		EREMOTEIO 					:= 121, {DE: "Remote I/O error" }
		EDQUOT 						:= 122, {DE: "Disk quota exceeded" }
		ENOMEDIUM 					:= 123, {DE: "No medium found" }
		EMEDIUMTYPE 				:= 124, {DE: "Wrong medium type" }
		ECANCELED 					:= 125, {DE: "Operation canceled" }
		ENOKEY 						:= 126, {DE: "Required key not available" }
		EKEYEXPIRED 				:= 127, {DE: "Key has expired" }
		EKEYREVOKED 				:= 128, {DE: "Key has been revoked" }
		EKEYREJECTED 				:= 129, {DE: "Key was rejected by service" }
		EOWNERDEAD 					:= 130, {DE: "Owner died" }
		ENOTRECOVERABLE 			:= 131, {DE: "State not recoverable" }
		ERFKILL 					:= 132, {DE: "Operation not possible due to RF-kill" }
		EHWPOISON 					:= 133 {DE: "Memory page has hardware error" }
	);
END_TYPE


VAR_GLOBAL
	{G:"Diagnostics"}
	FS_LastError AT %MD60311.0 : FS_ERROR;
END_VAR
]]></lib>
      <lib fullXml="false" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\LLXPlugin_Alarms\PLC\Alarms.pll"><![CDATA[
VAR_GLOBAL 

	{ G:"Global status" }
	sysAlarmCfgOk AT %MB60040.0 : BOOL;	{ DE:"Alarm manager properly configured" }
	sysAlarmActive AT %MB60040.1 : BOOL;	{ DE:"At least one alarm is active (associated condition holds true)" }
	sysAlarmWaitAck AT %MB60040.2 : BOOL;	{ DE:"No alarm is active but at least one alarm is waiting for acknowledgement" }

	{ G:"Counters" }
	sysAlarmCount AT %MW60041.0 : UINT;	{ DE:"Number of active alarms" }

END_VAR


	(*********************)
	(*                   *)
	(*     FUNCTIONS     *)
	(*                   *)
	(*********************)

FUNCTION sysAlarm_InitConfiguration : BOOL
{ DE:"Init configuration phase, specifying configuration name" }

	VAR_INPUT
	name : STRING[ 128 ]; { DE:"Configuration name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_EndConfiguration : BOOL
{ DE:"End configuration phase. After this call, all configuration functions will not work anymore." }

	VAR_INPUT
	dummy : USINT; 
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_GlobalAck : BOOL
{ DE:"This function acknowledges all alarms waiting for acknowledge" }

	VAR_INPUT
		dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_AddAlarmGroup : BOOL
{ DE:"Creates a new alarm group, specifying its unique ID and label." }
	
	VAR_INPUT
		
		id : UINT;	{ DE:"Alarm code" }
		label : STRING[ 128 ];	{ DE:"Alarm ID" }
		
	END_VAR
	
	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmGroup_GetLabel : STRING
{ DE:"This function returns the label associated to the alarm group identified by its ID" }
	
	VAR_INPUT
		id : UINT;	{ DE:"Alarm group ID" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_AddBooleanFlagAlarm : BOOL
{ DE:"Creates a new alarm condition, based on the value of a variable of type BOOL, specifying its name. Returns an handle to the new alarm condition. Must be called between Alarms_InitConfiguration and Alarms_EndConfiguration." }

	VAR_INPUT
		
		code : UINT;	{ DE:"Alarm code" }
		label : STRING[ 128 ];	{ DE:"Alarm ID" }
		ack : ALARM_ACK_TYPE;	{ DE:"Type of alarm acknowledgement (manual or auto)" }
		groupId : UINT;	{ DE:"Alarm group" }
		level : USINT;		{ DE:"Alarm level (the lower the value the higher the alarm priority)" }
		address : DWORD;	{ DE:"Physical address of the variable of type BOOL representing the alarm condition status (if TRUE, alarm is active)" }
		
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetLabel : STRING
{ DE:"This function returns the label associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetTime : BOOL
{ DE:"This function returns date and time of the event associated to the alarm identified by its code" }

	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
		day: @USINT;
		month: @USINT;
		year: @UINT;
		dayOfWeek: @UINT;
		hours: @USINT;
		minutes: @USINT;
		seconds: @USINT;
	END_VAR
	
	{CODE:EMBEDDED}

END_FUNCTION

FUNCTION Alarm_GetGroup : UINT
{ DE:"This function returns the alarm group ID associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetLevel : USINT
{ DE:"This function returns the alarm level associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetAckType : ALARM_ACK_TYPE
{ DE:"This function returns the alarm ACK type (AUTO/MANUAL) associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_Ack : BOOL
{ DE:"This function acknowledges the alarm identified by its code" }

	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_IsWaitingForAck : BOOL
{ DE:"This function returns TRUE if the alarm identified by its code is waiting for acknowledgement" }

	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_CreateAlarmQuery : ALARM_QUERY_HND
{ DE:"This function creates a new query and returns a handle to it" }

	VAR_INPUT
		dummy : USINT;	{ DE:"Not used" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_Query : ALARM_QUERY_RESULT_HND
{ DE:"This function actually performs the query and returns a handle to the query result" }

	VAR_INPUT
                query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_FilterByGroup : BOOL
{ DE:"This function sets a filter on alarm group" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		groupId : UINT;	{ DE:"Alarm priority value by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_FilterByLevel : BOOL
{ DE:"This function sets a filter on alarm priority" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		level : USINT;	{ DE:"Alarm priority value by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_SortByTime : BOOL
{ DE:"This function sets alarm activation timestamp as the criterion by which query result has to be sorted" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		desc : BOOL;	{ DE:"Ascending/Descending order" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_SortByGroup : BOOL
{ DE:"This function sets the group ID as the criterion by which query result has to be sorted" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		desc : BOOL;	{ DE:"Ascending/Descending order" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_SortByLevel : BOOL
{ DE:"This function sets alarm priority as the criterion by which query result has to be sorted" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		desc : BOOL;	{ DE:"Ascending/Descending order" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_Release : BOOL
{ DE:"This function release the query: its handle becomes invalid" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_GetCount : UINT
{ DE:"This function returns the number of records of the query result" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_SetWindow : BOOL
{ DE:"This function builds a window on the query result" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
		first : UINT;	{ DE:"First element of the window" }
		size : UINT;	{ DE:"Number of elements in the window" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_First : BOOL
{ DE:"This function moves the query result to the first element" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_Current : BOOL
{ DE:"This function returns TRUE if the current element of the query result is valid" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_Next : BOOL
{ DE:"This function moves the query result to the next element" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_GetAlarm : UINT
{ DE:"This function returns the alarm code associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_Release : BOOL
{ DE:"This function release the query result: its handle becomes invalid" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_EnableLog : BOOL
{ DE:"This function enables/disables the alarm log" }

	VAR_INPUT
		enable : BOOL;	{ DE:"If TRUE, alarm log is enabled; it is disabled, otherwise" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_ResetLog : BOOL
{ DE:"This function resets the alarm log" }

	VAR_INPUT
		dummy : USINT;	{ DE:"Not used" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_CreateAlarmLogQuery : ALARM_LOG_QUERY_HND
{ DE:"This function creates a new query and returns a handle to it" }

	VAR_INPUT
		dummy : USINT;	{ DE:"Not used" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_Query : ALARM_LOG_QUERY_RESULT_HND
{ DE:"This function actually performs the query and returns a handle to the query result" }

	VAR_INPUT
                query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_FilterByAlarm : BOOL
{ DE:"This function sets a filter on alarm" }

	VAR_INPUT
		query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
		code : UINT;	{ DE:"Alarm code by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_FilterByGroup : BOOL
{ DE:"This function sets a filter on alarm group" }

	VAR_INPUT
		query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
		groupId : UINT;	{ DE:"Alarm group ID by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_Release : BOOL
{ DE:"This function release the query: its handle becomes invalid" }

	VAR_INPUT
		query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetCount : UINT
{ DE:"This function returns the number of records of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_SetWindow : BOOL
{ DE:"This function builds a window on the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
		first : UINT;	{ DE:"First element of the window" }
		size : UINT;	{ DE:"Number of elements in the window" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_First : BOOL
{ DE:"This function moves the query result to the first element" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_Current : BOOL
{ DE:"This function returns TRUE if the current element of the query result is valid" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_Next : BOOL
{ DE:"This function moves the query result to the next element" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetEvent : ALARM_LOG_EVENT
{ DE:"This function returns the event code associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetAlarm : UINT
{ DE:"This function returns the alarm code associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetTime : BOOL
{ DE:"This function returns date and time of the event associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
		day: @USINT;
		month: @USINT;
		year: @UINT;
		dayOfWeek: @UINT;
		hours: @USINT;
		minutes: @USINT;
		seconds: @USINT;
	END_VAR
	
	{CODE:EMBEDDED}

END_FUNCTION

FUNCTION AlarmLogQueryResult_Release : BOOL
{ DE:"This function release the query result: its handle becomes invalid" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION


	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	ALARM_QUERY_HND : DWORD;
	ALARM_QUERY_RESULT_HND : DWORD;
	ALARM_LOG_QUERY_HND : DWORD;
	ALARM_LOG_QUERY_RESULT_HND : DWORD;
END_TYPE


	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	ALARM_ACK_TYPE : (
		ACK_MANUAL := 1,
		ACK_AUTO := 2
	);

	ALARM_LOG_EVENT : (
		LOG_EVENT_ACTIVATION := 1,
		LOG_EVENT_DEACTIVATION := 2,
		LOG_EVENT_ACK := 3,
		LOG_EVENT_ACK_ATTEMPT := 4
	);
	
END_TYPE

]]></lib>
      <lib fullXml="false" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\LLXPlugin_Recipes\PLC\Recipes.pll"><![CDATA[
	(*********************)
	(*                   *)
	(*     FUNCTIONS     *)
	(*                   *)
	(*********************)

FUNCTION Recipes_InitConfiguration : BOOL

{ DE:"Init configuration phase, specifying configuration name" }

	VAR_INPUT
	name : STRING; { DE:"Configuration name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_EndConfiguration : BOOL

{ DE:"End configuration phase. After this call, all configuration functions will not work anymore." }

	VAR_INPUT
	dummy : USINT; 
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_GetConfigurationName : STRING

{ DE:"Get configuration name, specified with Recipes_InitConfiguration" }

	VAR_INPUT
	dummy : USINT; 
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_CreateDefinition : RECIPE_DEFINITION_HANDLE

{ DE:"Creates a new recipe definition, specifying its name. Returns an handle to the new recipe. Must be called between Recipes_InitConfiguration and Recipes_EndConfiguration." }

	VAR_INPUT
	name : STRING; { DE:"New recipe definition name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_GetDefinition : RECIPE_DEFINITION_HANDLE

{ DE:"Returns an handle to an existing recipe definition, searching by its name." }

	VAR_INPUT
	name : STRING; { DE:"Recipe definition name to search" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_AddVariable : BOOL
{ DE:"(DEPRECATED) Adds a new variable to a recipe definition. Must be called between Recipes_InitConfiguration and Recipes_EndConfiguration." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Variable name" }
	type : RECIPE_DATA_TYPE; { DE:"Type of the variable" }
	address : DWORD; { DE:"Variable physical address" }
	strsize : DWORD; { DE:"Variable size for STRINGs" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION Recipes_AddNewVariable : BOOL
{ DE:"Adds a new variable to a recipe definition. Must be called between Recipes_InitConfiguration and Recipes_EndConfiguration." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Variable name" }
	type : RECIPE_DATA_TYPE; { DE:"Type of the variable" }
	address : DWORD; { DE:"Variable physical address" }
	strsize : DWORD; { DE:"Variable size for STRINGs" }
	format : STRING; { DE:"Format (for preview only)" }
	description : STRING; { DE:"Variable description" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION



FUNCTION Recipes_Load : RECIPE_RESULT

{ DE:"Loads values saved in the specified recipe in the corresponding variables. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_Save : RECIPE_RESULT

{ DE:"Saves values saved to the specified recipe with the corresponding variables. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_Delete : RECIPE_RESULT

{ DE:"Delete the specified recipe from disk. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION



FUNCTION Recipes_QueueLoadRequest : RECIPE_REQUEST_HANDLE

{ DE:"Queues a load recipe request, that will be executed asynchronously. Returns an handle of the operation, that can be used to poll for result and termination with RecipeRequest_GetStatus or just closed with RecipeRequest_CloseHandle (that must be called in any case to avoid memory leaks)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_QueueSaveRequest : RECIPE_REQUEST_HANDLE

{ DE:"Queues a save recipe request, that will be executed asynchronously. Returns an handle of the operation, that can be used to poll for result and termination with RecipeRequest_GetStatus or just closed with RecipeRequest_CloseHandle (that must be called in any case to avoid memory leaks)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_QueueDeleteRequest : RECIPE_REQUEST_HANDLE

{ DE:"Queues a delete recipe request, that will be executed asynchronously. Returns an handle of the operation, that can be used to poll for result and termination with RecipeRequest_GetStatus or just closed with RecipeRequest_CloseHandle (that must be called in any case to avoid memory leaks)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION


FUNCTION RecipeRequest_GetStatus : RECIPE_RESULT

{ DE:"Returns the execution or termination state of the specified request handle, returned by Recipes_Queue*Request functions family." }

	VAR_INPUT
	recipeRequest : RECIPE_REQUEST_HANDLE; { DE:"Recipe request handle" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION RecipeRequest_CloseHandle : BOOL

{ DE:"Closes the specified request handle. After this call the handle and RecipeRequest_GetStatus can not be used anymore" }

	VAR_INPUT
	recipeRequest : RECIPE_REQUEST_HANDLE; { DE:"Recipe request handle" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_GetName : STRING
{ DE:"Gets the name of the specified recipe" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_First : BOOL
{ DE:"Goes to first recipe definition to iterate on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_Current : BOOL
{ DE:"Checks if there is a valid recipe definition to iterate on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_Next : BOOL
{ DE:"Goes to next recipe definition to iterate on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_GetHandle : RECIPE_DEFINITION_HANDLE
{ DE:"Gets the handle of current recipe while iterating on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION Recipes_GetFileList : RECIPE_FILELIST_HANDLE
{ DE:"Gets the list of existing files for the specified recipe" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_First : BOOL
{ DE:"Goes to first file in the list to iterate on them" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_Next : BOOL
{ DE:"Goes to next file in the list to iterate on them" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_Current : BOOL
{ DE:"Checks if there is a valid file in the list to iterate on them" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_GetFileName : STRING
{ DE:"Gets the file name of the current file in the list" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_CloseHandle : BOOL
{ DE:"Closes the specified list of files of the recipe" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION Recipes_LoadPreview : RECIPE_RESULT
{ DE:"Loads values saved in the specified recipe for preview only. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION RecipeDef_First : BOOL
{ DE:"Goes to first variabile in the recipe definition to iterate on them" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_Next : BOOL
{ DE:"Goes to next variabile in the recipe definition to iterate on them" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_Current : BOOL
{ DE:"Checks if there is a valid variabile in the recipe definition to iterate on them" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_GetVarName : STRING
{ DE:"Gets the name of the current variable in the recipe definition" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_GetPreviewValue : STRING
{ DE:"Gets the preview value of the current variable in the recipe definition ('---' if the preview value is not valid)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_GetDescription : STRING
{ DE:"Gets the description of the current variable in the recipe definition" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION



	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	RECIPE_DEFINITION_HANDLE : DWORD; 
	RECIPE_REQUEST_HANDLE : DWORD; 
	RECIPE_FILELIST_HANDLE : DWORD; 
END_TYPE

	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	RECIPE_DATA_TYPE: ( 
		recUndefined := 19,
		recBool := 1,
		recSInt := 2,
		recInt := 5,
		recDInt := 9,
		recLInt := 12,
		recUSInt := 3,
		recUInt := 6,
		recUDInt := 10,
		recULInt := 13,
		recReal := 15,
		recLReal := 16,
		recByte := 4,
		recWord := 7,
		recDWord := 11,
		recLWord := 14,
		recString := 17
	);

	RECIPE_RESULT: (
		RECIPE_OK := 0,
		RECIPE_INPROGRESS := 1,
		RECIPE_ERROR_IO := 2,
		RECIPE_ERROR_PARAMS := 3,
		RECIPE_ERROR_NOFILE := 4,
		RECIPE_ERROR_INVALIDTASK := 5
	);
	
END_TYPE

]]></lib>
      <lib fullXml="false" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\Libraries\Serial.pll"><![CDATA[	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	SERIAL_HANDLE : DINT; 
END_TYPE

	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	SERIAL_OPT: ( { DE:"COM option that can be set using Serial_SetOption, Serial_GetOption or Serial_ConfigPort functions" }
		SERIAL_OPT_PORT				:=1,	{ DE:"COM port number" }
		SERIAL_OPT_BAUDRATE			:=2,	{ DE:"Baudrate (supported values: 115200, 57600, 38400, 19200, 9600, 4800, 2400)" }
		SERIAL_OPT_PARITY			:=3,	{ DE:"Parity (0 = NO Parity, 1 = ODD parity, 2 = EVEN parity, 3 = MARK parity, 4 = SPACE parity)" }
		SERIAL_OPT_BYTESIZE			:=4,	{ DE:"Bytesize (7, 8)" }
		SERIAL_OPT_STOPBITS			:=5,	{ DE:"Stopbits (0 = 1 stopbit, 1 = 1.5 stopbits, 2 = 2 stopbits)" }
		SERIAL_OPT_RX_TIMEOUT		:=6,	{ DE:"Rx timeout (Default 1000)" }
		SERIAL_OPT_XONXOFF_ENA		:=7,	{ DE:"XON/XOFF software flow control enabled (TRUE/FALSE. Default FALSE)" }
		SERIAL_OPT_RTSCTS_ENA		:=8,		{ DE:"RTS/CTS hardware flow control enabled (TRUE/FALSE. Default FALSE)" }
		SERIAL_OPT_USBSERIAL		:=11	{ DE:"USB-SERIAL setting (0 = not enabled, 1 = Standard class, 2 = Communication class )" }
	);

END_TYPE

TYPE

	SERIAL_RET: ( { DE:"COM return value definitions." }
		SERIAL_OK							:=0,	{ DE:"OK" }
		SERIAL_ERR_NOT_OPENED				:=-1,	{ DE:"ERR Port is not opened" }
		SERIAL_ERR_NOT_CONFIGURED			:=-2,	{ DE:"ERR Port is not configured" }
		SERIAL_ERR_ALREADY_OPENED			:=-3,	{ DE:"ERR Port is already opened" }
		SERIAL_ERR_ALREADY_CONFIGURED		:=-4,	{ DE:"ERR Port is already configured" }
		SERIAL_ERR_INVALID_VALUE			:=-5,	{ DE:"ERR Invalid value specified" }
		SERIAL_ERR_INVALID_OPTION			:=-6,	{ DE:"ERR Invalid option specified" }
		SERIAL_ERR_MAX_PORT_OPENED			:=-7,	{ DE:"ERR Max number of port opened" }
		SERIAL_ERR_CANNOT_OPEN				:=-8,	{ DE:"ERR Cannot open port" }
		SERIAL_ERR_CANNOT_CLOSE				:=-9,	{ DE:"ERR Cannot close port" }
		SERIAL_ERR_READ						:=-10,	{ DE:"ERR Read" }
		SERIAL_ERR_READ_TIMEOUT				:=-11,	{ DE:"ERR Read timeout" }
		SERIAL_ERR_NOT_SUPPORTED_OPTION		:=-12,	{ DE:"ERR Option is not supported for the current architecture" }
		SERIAL_ERR_INVALID_VALUE_BAUDRATE	:=-13,	{ DE:"ERR invalid baudrate value specified" }
		SERIAL_ERR_INVALID_VALUE_PARITY 	:=-14,	{ DE:"ERR invalid parity value specified" }
		SERIAL_ERR_INVALID_VALUE_BYTESIZE	:=-15,	{ DE:"ERR invalid bytesize value specified" }
		SERIAL_ERR_INVALID_VALUE_STOPBITS	:=-16,	{ DE:"ERR invalid stopbits value specified" }
		SERIAL_ERR_NOT_ALLOWED_IN_IOTASK	:=-17,	{ DE:"ERR operation not allowed in high priority task" }
		SERIAL_ERR_BUFFER					:=-18	{ DE:"ERR buffer is too small" }
	);

END_TYPE

TYPE

	SERIAL_BAUDRATE: ( { DE:"Available baudrate" }
		SERIAL_BAUDRATE_2400	:=2400,		{ DE:"Baudrate 2400" }
		SERIAL_BAUDRATE_4800	:=4800,		{ DE:"Baudrate 4800" }
		SERIAL_BAUDRATE_9600	:=9600,		{ DE:"Baudrate 9600" }
		SERIAL_BAUDRATE_19200	:=19200,	{ DE:"Baudrate 19200" }
		SERIAL_BAUDRATE_38400	:=38400,	{ DE:"Baudrate 38400" }
		SERIAL_BAUDRATE_57600	:=57600,	{ DE:"Baudrate 57600" }
		SERIAL_BAUDRATE_115200	:=115200	{ DE:"Baudrate 115200" }
	);

END_TYPE

TYPE

	SERIAL_PARITY: ( { DE:"Available parity settings" }
		SERIAL_NOPARITY		:=0,	{ DE:"Parity NONE" }
		SERIAL_ODDPARITY	:=1,	{ DE:"Parity ODD" }
		SERIAL_EVENPARITY	:=2,	{ DE:"Parity EVEN" }
		SERIAL_MARKPARITY	:=3,	{ DE:"Parity MARK" }
		SERIAL_SPACEPARITY	:=4		{ DE:"Parity SPACE" }
	);

END_TYPE

TYPE

	SERIAL_BYTESIZE: ( { DE:"Available bytesize settings" }
		SERIAL_BYTESIZE_7	:=7,	{ DE:"Bytesize 7" }
		SERIAL_BYTESIZE_8	:=8		{ DE:"Bytesize 8" }
	);

END_TYPE

TYPE

	SERIAL_STOPBITS: ( { DE:"Available stopbits settings" }
		SERIAL_ONESTOPBIT	:=0,	{ DE:"One stopbit" }
		SERIAL_TWOSTOPBITS	:=2		{ DE:"Two stopbits" }
	);

END_TYPE

TYPE

	SERIAL_USBSERIAL_CLASS: ( { DE:"Available usb-serial classes" }
		SERIAL_USBSERIAL_CLASS_STANDARD			:=1,		{ DE:"Standard class" }
		SERIAL_USBSERIAL_CLASS_COMMUNICATION	:=2		{ DE:"Communication class" }
		
	);

END_TYPE

	(************************)
	(*                   	*)
	(*     FUNCTIONS        *)
	(*                   	*)
	(************************)
	
FUNCTION Serial_ConfigPort : SERIAL_HANDLE
	
	{ DE:"Configure port settings.
If port has been configured (or opened) value returned is a SERIAL_HANDLE >= 0, otherwise is a SERIAL_RET error code." }
	
	VAR_INPUT
	port : USINT; { DE:"The number of the port (eg: 2 for COM2)" }
	baudrate : SERIAL_BAUDRATE; { DE:"One of the SERIAL_BAUDRATE supported values" }
	parity : SERIAL_PARITY; { DE:"One of the SERIAL_PARITY supported values" }
	bytesize : SERIAL_BYTESIZE; { DE:"One of the SERIAL_BYTESIZE supported values" }
	stopbits : SERIAL_STOPBITS; { DE:"One of the SERIAL_STOPBITS supported values" }
	open : BOOL; { DE:"If TRUE open the COM port with the values passed as parameters and the other default options." }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_ConfigPortByName : SERIAL_HANDLE
	
	{ DE:"Configure port settings.
If port has been configured (or opened) value returned is a SERIAL_HANDLE >= 0, otherwise is a SERIAL_RET error code." }
	
	VAR_INPUT
	port_dev : STRING[64]; { DE:"The name of the port device (eg: /dev/ttyUSB0)" }
	baudrate : SERIAL_BAUDRATE; { DE:"One of the SERIAL_BAUDRATE supported values" }
	parity : SERIAL_PARITY; { DE:"One of the SERIAL_PARITY supported values" }
	bytesize : SERIAL_BYTESIZE; { DE:"One of the SERIAL_BYTESIZE supported values" }
	stopbits : SERIAL_STOPBITS; { DE:"One of the SERIAL_STOPBITS supported values" }
	open : BOOL; { DE:"If TRUE open the COM port with the values passed as parameters and the other default options." }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_SetOption : SERIAL_RET
	
	{ DE:"Change setting for the specified option.
SERIAL_OK if the option has been set, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	option : SERIAL_OPT; { DE:"The SERIAL_OPT to set" }
	value : DINT; { DE:"Value depends on the option specified" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetOption : DINT
	
	{ DE:"Get port configuration settings.
Returns a value >= 0 with the value of the option if can be retrieved, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	option : SERIAL_OPT; { DE:"The SERIAL_OPT to get." }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_OpenPort : SERIAL_RET
	
	{ DE:"Open the specified port using the configured settings.
Returns SERIAL_OK if the option has been opened, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_ClosePort : SERIAL_RET
	
	{ DE:"Function to close the specified port.
Returns SERIAL_OK if the port has been closed, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_PutBuff : SERIAL_RET
	
	{ DE:"Send 1 or more BYTE data.
The number of bytes put on the serial otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	buff : @BYTE; { DE:"The address of the TX buffer. Address can be retrieved using ADR operator" }
	len : UINT; { DE:"The number of bytes to send" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetBuff : SERIAL_RET
	
	{ DE:"Receive the specified number of BYTEs.
Returns a value >= 0 indicating the bytes received, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	buff : @BYTE; { DE:"The address of the array of BYTE in which to put the received data. Address can be retrieved using ADR operator" }
	len : UINT; { DE:"The number of BYTEs to receive" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetBuff_tmo : SERIAL_RET
	
	{ DE:"Receive the specified number of BYTEs. It is also possible to specify the timeout.
Returns a value >= 0 indicating the bytes received, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	buff : @BYTE; { DE:"The address of the array of BYTE in which to put the received data. Address can be retrieved using ADR operator" }
	len : UINT; { DE:"The number of BYTEs to receive" }
	tmo : UINT; { DE:"Timeout in ms specified for current function" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION


FUNCTION Serial_PutString : SERIAL_RET
	
	{ DE:"Send a STRING.
Returns the number of characters put on the serial otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	str : STRING; { DE:"The STRING to transmit" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_PutByte : SERIAL_RET
	
	{ DE:"Send a single BYTE value.
Returns 1 if the BYTE can be put on the serial bus, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	val : BYTE; { DE:"The BYTE value to send" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetByte : SERIAL_RET
	
	{ DE:"Receive a single byte. 
Returns 1 if the BYTE has been received, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	val : @BYTE; { DE:"The address of the BYTE in which to put the received data. Address is retrieved using ADR operator" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetByte_tmo : SERIAL_RET
	
	{ DE:"Receive a single byte specifying the timeout. " }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	val : @BYTE; { DE:"The address of the BYTE in which to put the received data" }
	tmo : UINT; { DE:"Timeout in ms for the current function only" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

	(************************)
	(*                   	*)
	(*     FUNCTIONS BLOCK  *)
	(*                   	*)
	(************************)


FUNCTION_BLOCK Serial_GetString
	
	{ DE:"Receive a STRING.
Returns a value > 0 indicates the number of bytes received (including termination character), otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	str : UDINT; { DE:"The address of a STRING in which to put the received data" }
	len : UINT; { DE:"The max of characters of the string. The size of the string as indicated in the declaration of the STRING variable is the max size that can be indicated." }
	term : UDINT; { DE:"The address of a STRING in which to put the termination character" }
	END_VAR
	
	VAR_OUTPUT
	esi : SERIAL_RET; { DE:"Operation result" } 
	hasTerm : BOOL; { DE:"true if the string has the terminator char " } 
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK Serial_GetString_tmo
	
	{ DE:"Receive a STRING. It is also possible to specify the timeout.
Returns a value > 0 indicates the number of bytes received (including null character), otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	str : UDINT; { DE:"The address of a STRING in which to put the received data" }
	len : UINT; { DE:"The max of characters of the string. The size of the string as indicated in the declaration of the STRING variable is the max size that can be indicated." }
	term : UDINT; { DE:"The address of a STRING in which to put the termination character" }
	tmo : UINT; { DE:"Timeout in ms specified for current function" }
	END_VAR
	
	VAR_OUTPUT
	esi : SERIAL_RET; { DE:"Operation result" } 
	hasTerm : BOOL; { DE:"true if the string has the terminator char " } 
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION_BLOCK

]]></lib>
      <lib fullXml="true" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\Libraries\PLCConnect.plclib" version="1.0.2">
				    <descr/>
				    <libWorkspace>
					    <folder descr="" genCryptedChildren="false" id="15" libGeneration="true" name="PLCConnect" password="" version="1.0.0">
						      <Definition name="PLCCONNECTMASTERSTATUS"/>
						      <Definition genHidden="false" name="PLCCONNECTENDPOINTSTATUS"/>
						      <GlobalVars name="PLCConnectVariables"/>
						      <Definition name="PLCCONNECTERROR"/>
					</folder>
				</libWorkspace>
				    <globalVars>
					    <group name="PLCConnectVariables">
						      <var name="sysPLCConnectMasterStatus" type="PLCCONNECTMASTERSTATUS">
							      <address index="60096" subIndex="0" type="M" typeVar="B"/>
						</var>
						      <var dim0="100" name="sysPLCConnectEndpointsStatus" type="PLCCONNECTENDPOINTSTATUS">
							      <address index="60097" subIndex="0" type="M" typeVar="B"/>
						</var>
					</group>
				</globalVars>
				    <retainVars>
					    <group name="PLCConnectVariables"/>
				</retainVars>
				    <constantVars>
					    <group name="PLCConnectVariables"/>
				</constantVars>
				    <iecVarsDeclaration>
					    <group name="PLCConnectVariables">
						      <iecDeclaration active="FALSE"/>
					</group>
				</iecVarsDeclaration>
				    <functions/>
				    <functionBlocks/>
				    <programs/>
				    <macros/>
				    <structs>
					    <struct name="PLCCONNECTENDPOINTSTATUS" version="1.0.0">
						      <vars>
							      <var name="configured" type="BOOL">
								        <descr>The endpoint have been correctly configured</descr>
							</var>
							      <var name="_spare0" type="BOOL">
								        <descr>Spare field</descr>
							</var>
							      <var name="_spare1" type="BOOL">
								        <descr>Spare field</descr>
							</var>
							      <var name="_spare2" type="BOOL">
								        <descr>Spare field</descr>
							</var>
							      <var name="numInputVars" type="UINT">
								        <descr>Number of input variables</descr>
							</var>
							      <var name="numOutputVars" type="UINT">
								        <descr>Number of output variables</descr>
							</var>
							      <var name="error" type="PLCCONNECTERROR">
								        <descr>Last error on endpoint</descr>
							</var>
						</vars>
					</struct>
					    <struct name="PLCCONNECTMASTERSTATUS" version="1.0.0">
						      <vars>
							      <var name="configured" type="BOOL">
								        <descr>The master have been correctly configured</descr>
							</var>
							      <var name="network_ok" type="BOOL">
								        <descr>The master is running and all the endpoints are online</descr>
							</var>
							      <var name="numConfiguredEndpoints" type="UINT">
								        <descr>Number of configured endpoints</descr>
							</var>
							      <var name="numRunningEndpoints" type="UINT">
								        <descr>Number of running endpoints</descr>
							</var>
							      <var name="_spare" type="UINT">
								        <descr>Spare Field</descr>
							</var>
							      <var name="error" type="PLCCONNECTERROR">
								        <descr>Last error</descr>
							</var>
						</vars>
					</struct>
				</structs>
				    <typedefs/>
				    <enums>
					    <enum name="PLCCONNECTERROR" version="1.0.0">
						      <elements>
							      <element name="sr_DATA_EXCHANGE_GENERIC">
								        <descr>Data exchange generic error</descr>
								        <value>-743</value>
							</element>
							      <element name="sr_OUTPUT_ACCESS_MISMATCH">
								        <descr>Wrong remote output tag access rights</descr>
								        <value>-742</value>
							</element>
							      <element name="sr_NO_OUTPUT_TAGACCESS">
								        <descr>Failure retrieving remote output tag access rights</descr>
								        <value>-741</value>
							</element>
							      <element name="sr_OUTPUT_SIZE_MISMATCH">
								        <descr>Wrong remote output tag size</descr>
								        <value>-740</value>
							</element>
							      <element name="sr_NO_OUTPUT_TAGSIZE">
								        <descr>Failure retrieving remote output tag size</descr>
								        <value>-739</value>
							</element>
							      <element name="sr_OUTPUT_TYPE_MISMATCH">
								        <descr>Wrong remote output tag type</descr>
								        <value>-738</value>
							</element>
							      <element name="sr_NO_OUTPUT_TAGTYPE">
								        <descr>Failure retrieving remote output tag type</descr>
								        <value>-737</value>
							</element>
							      <element name="sr_NO_OUTPUT_TAG">
								        <descr>Failure retrieving remote output tag</descr>
								        <value>-736</value>
							</element>
							      <element name="sr_INPUT_SIZE_MISMATCH">
								        <descr>Wrong remote input tag size</descr>
								        <value>-735</value>
							</element>
							      <element name="sr_NO_INPUT_TAGSIZE">
								        <descr>Failure retrieving remote input tag size</descr>
								        <value>-734</value>
							</element>
							      <element name="sr_INPUT_TYPE_MISMATCH">
								        <descr>Wrong remote input tag type</descr>
								        <value>-733</value>
							</element>
							      <element name="sr_NO_INPUT_TAGTYPE">
								        <descr>Failure retrieving remote input tag type</descr>
								        <value>-732</value>
							</element>
							      <element name="sr_NO_INPUT_TAG">
								        <descr>Failure retrieving remote input tag</descr>
								        <value>-731</value>
							</element>
							      <element name="sr_NO_CONNECTION">
								        <descr>No connection with endpoint</descr>
								        <value>-730</value>
							</element>
							      <element name="sr_CFG_WRONG_ENDPOINT">
								        <descr>Endpoint not present in main config file</descr>
								        <value>-719</value>
							</element>
							      <element name="sr_CFG_NO_SYMSIZE">
								        <descr>Missing size for local variable</descr>
								        <value>-718</value>
							</element>
							      <element name="sr_CFG_NO_SYMTYPE">
								        <descr>Missing type for local variable</descr>
								        <value>-717</value>
							</element>
							      <element name="sr_CFG_NO_SYMADDRESS">
								        <descr>Missing address for local variable</descr>
								        <value>-716</value>
							</element>
							      <element name="sr_CFG_NO_SYMLOCAL">
								        <descr>Missing symbol in local symbol table</descr>
								        <value>-715</value>
							</element>
							      <element name="sr_CFG_NO_LOCAL">
								        <descr>Missed an endpoint local variable</descr>
								        <value>-714</value>
							</element>
							      <element name="sr_CFG_NO_REMOTE">
								        <descr>Missed an endpoint remote variable</descr>
								        <value>-713</value>
							</element>
							      <element name="sr_CFG_NO_PLC_AREA">
								        <descr>Missed endpoint plc area</descr>
								        <value>-712</value>
							</element>
							      <element name="sr_CFG_WRONG_PARAMS">
								        <descr>Wrong endpoint protocol parameters</descr>
								        <value>-711</value>
							</element>
							      <element name="sr_CFG_NO_PARAMS">
								        <descr>Missed endpoint protocol parameters</descr>
								        <value>-710</value>
							</element>
							      <element name="sr_CFG_WRONG_PROTO">
								        <descr>Wrong endpoint protocol</descr>
								        <value>-709</value>
							</element>
							      <element name="sr_CFG_NO_PROTO">
								        <descr>Missed endpoint protocol</descr>
								        <value>-708</value>
							</element>
							      <element name="sr_CFG_NO_NAME">
								        <descr>Missed endpoint name</descr>
								        <value>-707</value>
							</element>
							      <element name="sr_CFG_GET_SYM_API">
								        <descr>Fail to load LLSymbols direct access API</descr>
								        <value>-706</value>
							</element>
							      <element name="sr_CFG_ALLOC">
								        <descr>Configuration alloc</descr>
								        <value>-705</value>
							</element>
							      <element name="sr_CFG_VERSION">
								        <descr>Configuration version mismatch</descr>
								        <value>-704</value>
							</element>
							      <element name="sr_CFG_EMPTY">
								        <descr>Empty configuration</descr>
								        <value>-703</value>
							</element>
							      <element name="sr_CFG_FILE">
								        <descr>File I/O Error</descr>
								        <value>-702</value>
							</element>
							      <element name="sr_OUT_OF_MEMORY">
								        <descr>Out of memory</descr>
								        <value>-701</value>
							</element>
							      <element name="sr_OK">
								        <descr>No error</descr>
								        <value>0</value>
							</element>
						</elements>
					</enum>
				</enums>
				    <subranges/>
				    <interfaces/>
			</lib>  <lib fullXml="false" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\Libraries\COPM.pll"><![CDATA[
	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE
	COPM_CMD: ( { DE:"CANOpen master command" }
		NMT_START_CS := 1, { DE:"Start remote node" }
		NMT_STOP_CS := 2, { DE:"Stop remote node" }
		NMT_PRE_OP_CS := 128, { DE:"Enter pre operational" }
		NMT_RESET_ND_CS := 129, { DE:"Reset node" }
		NMT_RESET_COM_CS := 130 { DE:"Reset communication" }
	);
END_TYPE

TYPE
	COPM_ESI_VALUE: ( { DE:"Return value from CANOpen function call" }
		COPM_E_OK			:=0,		{ DE:"Successful command" }
		COPM_E_GENERIC		:=-200,		{ DE:"Not specified error" }
		COPM_E_NODE			:=-201		{ DE:"Not valid node" }		
	);
END_TYPE

TYPE
	COPM_EVENT_ID: ( { DE:"Event type id" }
		COPM_EVENT_MASTER_RESYNC :=0, { DE: "Resync event signaled for master (in resync task)" }
		COPM_EVENT_SLAVE_RESYNC :=1, { DE: "Resync event signaled for slave (in resync task)" }
		COPM_EVENT_EMERGENCY :=2, { DE: "Emergency event signaled in notify event task" }
		COPM_EVENT_NODE_STATUS_CHANGED :=3, { DE: "Node status changed event signaled in notify event task" }
		COPM_EVENT_SDO_FAIL :=4, { DE: "SDO parametrization fail event signaled in notify event task" }
		COPM_EVENT_PDO_ERROR :=5 { DE: "PDO received is not as expected" }
	);
END_TYPE 

TYPE
	COPM_EVENT_PDO_ERROR_DESCR: ( { DE:"Event PDO error id" }
		COPM_EVENT_PDO_ERROR_DESCR_NONE := 0, { DE: "No error specified" }
		COPM_EVENT_PDO_ERROR_DESCR_PDO_RX_CAN_LEN_LT_PDO_CFG := 1 { DE: "PDO RX size less than PDO size configured" }
	);
END_TYPE 

TYPE
	COPM_BOOT_ERR: ( { DE:"Boot error" }
		COPM_BOOT_OK := 0, { DE: "Boot error none" }
		COPM_BOOT_ERR_A_SLAVE_NOT_FOUND := 1, { DE: "The slave no longer exists in the Network" }
		COPM_BOOT_ERR_B_DEVICETYPE_NO_RESPONSE := 2, { DE: "No response on access to Actual Device Type (object 1000h) received" }
		COPM_BOOT_ERR_C_DEVICETYPE_MISMATCH := 3, { DE: "Actual Device Type (object 1000h) of the slave node did not match with the expected DeviceTypeIdentification in object 1F84h" }
		COPM_BOOT_ERR_D_VENDORID_MISMATCH := 4, { DE: "Actual Vendor ID (object 1018h) of the slave node did not match with the expected Vendor ID in object 1F85h" }
		COPM_BOOT_ERR_E_SLAVE_HB_STATE_NOT_RECEIVED := 5, { DE: "Slave node did not respond with its state during Check node state process. Slave is a heartbeat producer" }
		COPM_BOOT_ERR_F_SLAVE_NMT_STATE_NOT_RECEIVED := 6, { DE: "Slave node did not respond with its state during Check node state process. Slave is a Node Guard slave (NMT slave)" }
		COPM_BOOT_ERR_G_DATETIME_NOT_CONFIGURED := 7, { DE: "It was requested to verify the application software version, but the expected version date and time values were not configured in objects 1F53h and 1F54h respectively" }
		COPM_BOOT_ERR_H_DATETIME_NOT_MATCH_UPD_NOT_ALLOWED := 8, { DE: "Actual application software version Date or Time (object 1F52h) did not match with the expected date and time values in objects 1F53h and 1F54h respectively. Automatic software update was not allowed" }
		COPM_BOOT_ERR_I_DATETIME_NOT_MATCH_UPD_FAILED := 9, { DE: "Actual application software version Date or Time (object 1027h) did not match with the expected date and time values in objects 1F53h and 1F54h respectively and automatic software update failed" }
		COPM_BOOT_ERR_J_AUTO_CFG_DOWNLOAD_FAILED := 10, { DE: "Automatic configuration download failed" }
		COPM_BOOT_ERR_K_SLAVE_STATE_NOT_RECEIVED_ERR_CTRL := 11, { DE: "The slave node did not send its heartbeat message during Start Error Control Service although it was reported to be a heartbeat producer" }
		COPM_BOOT_ERR_L_SLAVE_NOT_OPERATIONAL := 12, { DE: "Slave was initially operational. (CANopen manager may resume operation with other nodes)" }
		COPM_BOOT_ERR_M_PRODUCTCODE_MISMATCH := 13, { DE: "Actual ProductCode (object 1018h) of the slave node did not match with the expected Product Code in object 1F86H" }
		COPM_BOOT_ERR_N_REVNUM_MISMATCH := 14, { DE: "Actual RevisionNumber (object 1018h) of the slave node did not match with the expected RevisionNumber in object 1F87H" }
		COPM_BOOT_ERR_O_SERIALNUM_MISMATCH := 15 { DE: "Actual SerialNumber (object 1018h) of the slave node did not match with the expected SerialNumber in object 1F88H" }
	);
END_TYPE

TYPE
	COPM_NET_STATUS: ( { DE: "CANopen node status" }
		COPM_NET_ST_UNKOWN			:= 0, { DE: "Unknown status or booting" }
		COPM_NET_ST_MISSING			:= 1, { DE:	"Missing" }
		COPM_NET_ST_STOPPED			:= 4, { DE:	"Stopped" }
		COPM_NET_ST_OPERATIONAL		:= 5, { DE:	"Operational" }
		COPM_NET_ST_RESET			:= 6, { DE: "Reset" }
		COPM_NET_ST_RESET_COMM		:= 7, { DE: "Reset command" }
		COPM_NET_ST_PRE_OPERATIONAL := 127 { DE: "Pre operational" }
	);
END_TYPE

TYPE
	COPM_MST_STATUS: ( { DE: "CANopen master status" }	
		COPM_MST_ST_UNKNOWN			:= 0, { DE: "Not configured" }
		COPM_MST_ST_NOT_INITIALIZED	:= 1, { DE: "Not initialized" }
		COPM_MST_ST_RESET			:= 2, { DE: "Resetted. Ready to start parametrization" }
		COPM_MST_ST_BOOTING_NETWORK	:= 3, { DE: "Network parametrization in progress" }
		COPM_MST_ST_BOOTUP_ERROR	:= 4, { DE: "Network parametrization ended with error. One or more mandatory slave missing. Cannot enter operational." }
		COPM_MST_ST_STOPPED			:= 5, { DE: "Stopped" }
		COPM_MST_ST_PRE_OPERATIONAL	:= 6, { DE: "Pre operational" }
		COPM_MST_ST_OPERATIONAL		:= 7  { DE: "Operational" }
	);
END_TYPE

TYPE
    COPMNODESTATUS : STRUCT 
	cfg : BOOL := FALSE; { DE:"Configurated" }
	pres : BOOL := FALSE; { DE:"Present and in operational status" }
	reserved_0 : WORD; { DE:"Reserved for further use" }
	netStat : COPM_NET_STATUS; { DE: "Status of the node in the network" }
	missCnt : UINT; { DE: "Miss counter" }
	emrgCode : WORD; { DE: "Emergency code" }
	emrgReg	: BYTE; { DE: "Emergency register" }
	emrgAdd1 : BYTE; { DE: "Emergency additional code" }
	emrgAdd2 : BYTE; { DE: "Emergency additional code" }
	emrgAdd3 : BYTE; { DE: "Emergency additional code" }
	emrgAdd4 : BYTE; { DE: "Emergency additional code" }
	emrgAdd5 : BYTE; { DE: "Emergency additional code" }
	emrgCnt : UINT; { DE: "Emergency counter" }
	syncPdoMissCnt : UINT; { DE: "Count of expected sync PDO Tx from node to master missed" }
	syncPdoMissLast : WORD; { DE: "Last sync PDO Tx expected from node to master missed" }
	bootErr : COPM_BOOT_ERR; { DE: "Boot error code" }
	reserved_1 : BYTE; { DE:"Reserved for further use" }
	mandatory : BOOL; { DE: "Mandatory node" }
	assigned : BOOL; { DE: "Slave node assigned to master network by COPM master configurator" }
	identityObjMask : BYTE; { DE: "bit 0: deviceId will be checked,
                                       bit 1: vendorId will be checked, 
                                       bit 2: productCode will be checked,
                                       bit 3: revisionNumber will be checked,
                                       bit 4: serialNumber will be checked" }
	deviceId : DWORD; { DE: "deviceId value read from target" }
	vendorId : DWORD; { DE: "deviceId value read from target" }
	productCode : DWORD; { DE: "deviceId value read from target" }
	revisionNumber : DWORD; { DE: "deviceId value read from target" }
	serialNumber : DWORD; { DE: "deviceId value read from target" }	
    END_STRUCT;
END_TYPE

TYPE
    COPMMASTERSTATUS : STRUCT 
	can_chn : USINT; { DE: "CAN channel ID" }
	node : USINT; { DE: "CANopen node number for the master" }	
	netStat : UINT;	{ DE: "Status of the network. DEPRECATED: use masterStat" }	
	
	masterStat : COPM_MST_STATUS;	{ DE: "Status of the master node" }

	initOk : BOOL; { DE: "CANopen driver and low level services inited TRUE" }
	runOk : BOOL; { DE: "Ready to run or running TRUE" }
	netCfgExec : BOOL; { DE: "Configuration of the network done TRUE" }
	netCfgOk : BOOL; { DE: "Configuration succesfully done if TRUE" }
	
	rqBoot : BOOL; { DE: "Pending request of boot if TRUE" }
	rqStart : BOOL; { DE: "Pending request of start if TRUE" }
	rqStop : BOOL; { DE: "Pending request of stop if TRUE" }
	rqPre : BOOL; { DE: "Pending request of enter preoperational if TRUE" }
	
	exchRx : BOOL; { DE: "PDO Rx active if TRUE" }
	exchTx : BOOL; { DE: "PDO Tx active if TRUE" }
	
	n_slavesCfg : UINT;	{ DE: "Number of slaves parametrized (or riparametrized)" }
	n_pdotxa : UINT; { DE: "Number of async PDO managed by master in TX" }
	n_pdotxs : UINT; { DE: "Number of async PDO managed by master in TX" }
	n_pdorxa : UINT; { DE: "Number of sync PDO managed by master in RX" }
	n_pdorxs : UINT; { DE: "Number of sync PDO managed by master in RX" }
    END_STRUCT;	
END_TYPE

TYPE
    COPMRESYNC : STRUCT
	event_id : COPM_EVENT_ID; { DE: "COPM_EVENT_MASTER_RESYNC or COPM_EVENT_SLAVE_RESYNC values allowed" }
	can_chn : USINT; { DE: "Channel ID: 0 for master on CAN0 channel, 1 for master on CAN1 channel" }
	node_id : USINT; { DE: "CANopen assigned node ID" }
	is_master : BOOL; { DE: "if COPM_EVENT_MASTER_RESYNC this is TRUE, otherwise it is FALSE" }
	ready_to_start : BOOL; { DE: "Indicates if it is ready to start. If this is the master, value is TRUE if all mandatories slaves have been configured. If it is a slave node this flag is true if parametrization succedeed" }
    END_STRUCT;
END_TYPE

TYPE
    COPMEMERGENCY : STRUCT
	event_id : COPM_EVENT_ID; { DE: "COPM_EVENT_EMERGENCY" }
	can_chn : USINT; { DE: "Channel ID: 0 for master on CAN0 channel, 1 for master on CAN1 channel" }
	node_id : USINT; { DE: "CANopen assigned node ID" }
	emrgCode : WORD; { DE: "Emergency code" }
	emrgReg : BYTE; { DE: "Emergency register" }
	emrgAdd1 : BYTE; { DE: "Emergency additional code" }
	emrgAdd2 : BYTE; { DE: "Emergency additional code" }
	emrgAdd3 : BYTE; { DE: "Emergency additional code" }
	emrgAdd4 : BYTE; { DE: "Emergency additional code" }
	emrgAdd5 : BYTE; { DE: "Emergency additional code" }
    END_STRUCT;	
END_TYPE

TYPE
    COPMNODESTATUSCHANGED : STRUCT
	event_id : COPM_EVENT_ID; { DE: "COPM_EVENT_NODE_STATUS_CHANGED" }
	can_chn : USINT; { DE: "Channel ID: 0 for master on CAN0 channel, 1 for master on CAN1 channel" }
	node_id : USINT; { DE: "CANopen assigned node ID" }
	netStat_from : UINT; { DE: "Previous status of the node in the network" }
	netStat_to : UINT; { DE: "Current status of the node in the network" }
    END_STRUCT;
END_TYPE

TYPE
    COPMSDOFAIL : STRUCT
	event_id : COPM_EVENT_ID; { DE: "COPM_EVENT_SDO_FAIL" }
	can_chn : USINT; { DE: "Channel ID: 0 for master on CAN0 channel, 1 for master on CAN1 channel" }
	node_id : USINT; { DE: "CANopen assigned node ID" }
	rw : USINT;	{ DE: "0: SDO Read / Upload; 1: SDO Write / Download" }
	obj_len : USINT; { DE: "Object size in bytes" }
	obj_index : WORD; { DE: "Object index" }
	obj_subindex : USINT; { DE: "Object subindex" }
	error_code: BYTE; { DE: "Bootup error code" }
	abort_code: DWORD; { DE: "SDO abort code" }
	data : DWORD; { DE: "Data readed if rw field is 0 and abort_code is 0, data to write if rw is 1" }
	data_expected : DWORD; { DE: "Expected data to read if rw is 0, data to write if rw is 1" }	
    END_STRUCT;	
END_TYPE

TYPE
    COPMPDOERR : STRUCT
	event_id : COPM_EVENT_ID; { DE: "COPM_EVENT_PDO_ERROR" }
	error : COPM_EVENT_PDO_ERROR_DESCR; { DE: "PDO error description COPM_EVENT_PDO_ERROR_DESCR"}
	can_chn : USINT; { DE: "Channel ID: 0 for master on CAN0 channel, 1 for master on CAN1 channel" }
	node_id : USINT; { DE: "CANopen assigned node ID" }
	cobid : WORD;	{ DE: "COB-ID of the PDO" }
	len : USINT; { DE: "Number of bytes of the PDO" }
	rtr : BOOL; { DE: "CAN RTR flag" }
	data : ARRAY[ 0..7 ] OF BYTE; { DE: "CAN message data"}
    END_STRUCT;	
END_TYPE

TYPE
	COPMSDOSCHEDULINGDIAGNO : STRUCT
	index : WORD;			{ DE: "object index" }
	subIndex : BYTE;		{ DE: "object subIndex" }
	len : USINT;			{ DE: "len in bytes" }
	value : UDINT;			{ DE: "value read/written if ris = COPM_E_OK otherwise is 0" }
	timestamp : UDINT;		{ DE: "timestamp ms of the end of the request" }
	dirWrite : BOOL;		{ DE: "direction: FALSE read, TRUE write" }
	count : UINT;			{ DE: "count" }
	ris : COPM_ESI_VALUE;		{ DE: "result of the request, one of the COPM_ESI_VALUE values" }
	abortCode : DWORD;		{ DE: "abort code" }
	END_STRUCT;
END_TYPE
	
TYPE
	COPMSDOSCHEDULINGDIAGNO_SLAVE : STRUCT
	lastSDO_OK : COPMSDOSCHEDULINGDIAGNO;	{ DE: "This structure show the last SDO scheduled succesfully managed" }	
	lastSDO_ERR : COPMSDOSCHEDULINGDIAGNO;	{ DE: "This structure show the last SDO scheduled error" }	
	END_STRUCT;
END_TYPE

{ ALLOCATE:sysCOPMNodeStatus }
{ ALLOCATE:sysCOPMMasterStatus }
{ ALLOCATE:sysCOPMResyncInfo }
{ ALLOCATE:sysCOPMEmergencyEvent }
{ ALLOCATE:sysCOPMNodeStatusChangedEvent }
{ ALLOCATE:sysCOPMSDOFailEvent }
{ ALLOCATE:sysCOPMPDOErrEvent }
{ ALLOCATE:sysCOPMSDOSchedulingDiagno }

VAR_GLOBAL

{G:"CANOpen Master"}

sysCOPMSDOFailEvent AT %IB60036.0 : COPMSDOFAIL;
	{ DE: "This struct is filled just before an occurred parametrization SDO fail is signaled to PLC task" }
	
sysCOPMNodeStatusChangedEvent AT %IB60035.0 : COPMNODESTATUSCHANGED;
	{ DE: "This struct is filled just before a node status change is signaled to PLC task" }
	
sysCOPMEmergencyEvent AT %IB60034.0 : COPMEMERGENCY;
	{ DE: "This struct is filled just before an occurred emergency event is signaled to PLC task" }
	
sysCOPMPDOErrEvent AT %IB60038.0 : COPMPDOERR;
	{ DE: "This struct is filled just before a malformed PDO RX event is signaled to PLC task" }
	
sysCOPMEventID AT %IB60033.0 : COPM_EVENT_ID;
	{ DE: "This value is set with the event ID value. The struct corresponding to the ID set can be used in the notify event task when it is executed" }
	
sysCOPMResyncInfo AT %IB60032.0 : COPMRESYNC;
	{ DE: "This struct is filled just before a master/slave resync event" }

sysCOPMMasterStatus	AT %IB60031.0 : COPMMASTERSTATUS;
	{ DE:"See structure definition COPMMASTERSTATUS" }

{G:"CANOpen Master"}
sysCOPMNodeStatus	AT %IB60030.0 : ARRAY[ 0..127 ] OF COPMNODESTATUS;
	{ DE:"See structure definition COPMNODESTATUS" }

{G:"CANOpen Master"}
sysCOPMSDOSchedulingDiagno	AT %IB60039.0 : ARRAY[ 0..127 ] OF COPMSDOSCHEDULINGDIAGNO_SLAVE;
	{ DE: "This structure show for each node the last SDO scheduled succeded and failed" }

END_VAR

        (*********************)
        (*                   *)
        (*     FUNCTIONS     *)
        (*                   *)
        (*********************)

FUNCTION sysCOPM_Command : BOOL
	{ DE:"COPM net control for master COPM_MASTER_0 only. Use sysCOPM2_Command if more than a network is supported by target." }
	VAR_INPUT
		cs : COPM_CMD;	{ DE:"Command" }
		tmo : UDINT;	{ DE:"Time out" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION sysCOPM_Sdo_OpenChn : UDINT
	{ DE:"COPM Open SDO channel (OBSOLETE, should not be used anymore!)" }
	VAR_INPUT
		dummy  : BOOL;  { DE:"Dummy arg" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION sysCOPM_Sdo_CloseChn : BOOL
	{ DE:"COPM Close SDO channel (OBSOLETE, should not be used anymore!)" }
	VAR_INPUT
		hdlr  : UDINT;  { DE:"SDO Handle" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION sysCOPM_AttachUnconfiguredNode : BOOL
	{ DE:"COPM retry to connect a node not configured at network startup" }
	VAR_INPUT
		node : USINT;	{ DE:"Slave node" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION sysCOPM_ResetEmergency : BOOL
	{ DE:"Reset emergency in diagnostic and if specified send NMT_START_CS to specified node of COPM_MASTER_0 network" }
	VAR_INPUT
		node : USINT;	{ DE:"Slave node" }
		cs : COPM_CMD;	{ DE:"Command NMT_START_CS or 0 value to send no NMT commands" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION

        (***************************)
        (*                         *)
        (*     FUNCTION BLOCKS     *)
        (*                         *)
        (***************************)

FUNCTION_BLOCK sysCOPM_Sdo_DownloadRequest
	{ DE:"COPM write object on remote node" }
	VAR_INPUT
		hdlr  : UDINT;  { DE:"SDO Handle (OBSOLETE, should not be used anymore!)" }
		index : WORD; { DE:"Object index"}
		sindex : USINT; { DE:"Object sub-index"}
		node : USINT; { DE:"Node ID"}
		len : UDINT; { DE:"Object data len"}
		value : DINT; { DE:"Value"}
		tmo : UDINT; { DE:"Time out"}
	END_VAR
	VAR_OUTPUT
		esi : COPM_ESI_VALUE; { DE:"Operation result" }
		abort_code : DWORD; { DE:"Abort code from the slave" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION_BLOCK

FUNCTION_BLOCK sysCOPM_Sdo_UploadRequest
	{ DE:"COPM read object on remote node" }
	VAR_IN_OUT
		len : UDINT; { DE:"Object data len" }
	END_VAR
	VAR_INPUT
		hdlr : UDINT; { DE:"SDO Handle (OBSOLETE, should not be used anymore!)" }
		index : WORD; { DE:"Object index" }
		sindex : USINT; { DE:"Object sub-index" }
		node : USINT; { DE:"Node ID" }
		tmo : UDINT; { DE:"Time out" }
	END_VAR
	VAR_OUTPUT
		esi : COPM_ESI_VALUE; { DE:"Operation result" }
		abort_code : DWORD; { DE:"Abort code from the slave" }
		res_dword : DWORD; { DE:"Data read" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION_BLOCK
]]></lib>
      <lib fullXml="true" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\Libraries\ModbusRTU.plclib" version="1.0.0">
				    <descr>ModbusRTU library</descr>
				    <libWorkspace>
					    <folder id="161" name="ModbusRTU">
						      <GlobalVars name="Modbus_RTU_Master"/>
						      <folder name="Definitions">
							      <folder name="Structures">
								        <Definition name="MBMNODESTATUS"/>
							</folder>
							      <folder name="Enumerations">
								        <Definition name="MB_RTU_NETWORK_ID"/>
								        <Definition name="MB_DATA_TYPE"/>
								        <Definition name="MB_ESI_VALUE"/>
								        <Definition name="MB_ASYNC_RQ_STATUS"/>
								        <Definition name="MB_COMPORT_SETTING_DATABITS_ENUM"/>
								        <Definition name="MB_COMPORT_SETTING_PARITY_ENUM"/>
								        <Definition name="MB_COMPORT_SETTING_RIS_ENUM"/>
								        <Definition name="MB_COMPORT_SETTING_STOPBITS_ENUM"/>
							</folder>
						</folder>
						      <folder name="Single master commands">
							      <Pou name="ModbusRTU_WriteReg_S"/>
							      <Pou name="ModbusRTU_ReadReg_RW"/>
							      <Pou name="ModbusRTU_ReadReg_RO"/>
							      <Pou name="ModbusRTU_Active"/>
							      <Pou name="ModbusRTU_WriteReg_M"/>
						</folder>
						      <folder name="Multi master commands">
							      <Pou name="ModbusRTUNet_WriteReg_S_Async"/>
							      <Pou name="ModbusRTUNet_WriteReg_M"/>
							      <Pou name="ModbusRTUNet_ReadReg_RW_Async"/>
							      <Pou name="ModbusRTUNet_ReadReg_RO"/>
							      <Pou name="ModbusRTUNet_Active"/>
							      <Pou name="ModbusRTUNet_ReadReg_RW"/>
							      <Pou name="ModbusRTUNet_WriteReg_S"/>
							      <Pou name="ModbusRTUNet_WriteReg_M_Async"/>
							      <Pou name="ModbusRTUNet_ReadReg_RO_Async"/>
						</folder>
						      <folder name="Raw commands">
							      <Pou name="ModbusRTU_ReadHoldingRegs_Async"/>
							      <Pou name="ModbusRTU_WriteSingleCoil"/>
							      <Pou name="ModbusRTU_WriteMultRegs"/>
							      <Pou name="ModbusRTU_ReadDiscrInputs"/>
							      <Pou name="ModbusRTU_ReadCoils_Async"/>
							      <Pou name="ModbusRTU_ReadHoldingRegs"/>
							      <Pou name="ModbusRTU_ReadInputRegs_Async"/>
							      <Pou name="ModbusRTU_WriteSingleReg_Async"/>
							      <Pou name="ModbusRTU_ReadDiscrInputs_Async"/>
							      <Pou name="ModbusRTU_ReadInputRegs"/>
							      <Pou name="ModbusRTU_ReadCoils"/>
							      <Pou name="ModbusRTU_WriteMultCoils_Async"/>
							      <Pou name="ModbusRTU_WriteMultCoils"/>
							      <Pou name="ModbusRTU_WriteMultRegs_Async"/>
							      <Pou name="ModbusRTU_WriteSingleReg"/>
							      <Pou name="ModbusRTU_WriteSingleCoil_Async"/>
						</folder>
						      <folder name="Port settings">
							      <Pou name="ModbusRTU_GetComPortInfo"/>
							      <Pou name="ModbusRTU_ChangeComPortSettings"/>
						</folder>
					</folder>
				</libWorkspace>
				    <globalVars>
					    <group excludeFromBuild="FALSE" name="Modbus_RTU_Master">
						      <var dim0="248" name="sysMbMRtuNodeStatus" type="MBMNODESTATUS">
							      <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_0.
It is a structure of type MBMNODESTATUS composed by the following fields:
	cfg :       BOOL; Configurated
	pres :      BOOL; Present
	active : BOOL; Indicate if node is active on network
	miss :      BOOL; Slave failure
	address : UINT; Address
	missCnt:    UINT; Number of Task Timed cycles with Slave failure
	state :     INT; Slave failure error code
	netStat :   UINT; Status of the node in the network

state could have the following meanings:
(valid only if miss is TRUE )
	MB_E_PROTOCOL               -320    Protocol error
	MB_E_IDE                    -321    Ide not match                        
	MB_E_ILLEGALFUNCTION        -322    Illegal function                        
	MB_E_ILLEGALDATAADDR        -323    Illegal data address                    
	MB_E_ILLEGALDATAVALUE       -324    Illegal data value                      
	MB_E_SLAVEDEVICEFAILURE     -325    Slave device failure                    
	MB_E_ACKNOWLEDGE            -326    Acknowledge                             
	MB_E_SLAVEDEVICEBUSY        -327    Slave device busy                       
	MB_E_MEMORYPARITYERROR      -328    Memory parity error                     
	MB_E_GATEWAYPATHUNAV        -329    Gateway path unavailable                
	MB_E_GATEWAYDEVICEFAILED    -330    Gateway target device failed to respond 
	MB_E_TIMEOUT                -331    Time out richiesta
	MB_E_ILLEGALDATAPROTOCOL    -332    Illegal data value in protocol
	MB_E_SWITCHEDOFF            -335    Node is switched off	
	
netStat can have the following meanings:
(node == 0, master)
	MB_MST_NOT_READY            0    Not ready
	MB_MST_READY                1    Ready
	MB_MST_START                2    Start
	MB_MST_STOP                 3    Stop
	MB_MST_RUN                  4    Run
	MB_MST_STOPPED              5    Stopped
	MB_MST_ERROR                6    Error
	
(node &gt;= 1, slave)
	MB_SLV_DISCONNECTED         0    Disconnected
	MB_SLV_OPENCONN             1    Connection opened
	MB_SLV_CLOSECONN            2    Connection closed
	MB_SLV_PAR                  3    Parameters setting
	MB_SLV_RUN                  4    Running</descr>
							      <address index="60010" subIndex="0" type="I" typeVar="B"/>
						</var>
						      <var dim0="248" name="sysMbMRtuNodeStatus_1" type="MBMNODESTATUS">
							      <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_1.
It is a structure of type MBMNODESTATUS composed by the following fields:
	cfg :       BOOL; Configurated
	pres :      BOOL; Present
	active : BOOL; Indicate if node is active on network
	miss :      BOOL; Slave failure
	address : UINT; Address
	missCnt:    UINT; Number of Task Timed cycles with Slave failure
	state :     INT; Slave failure error code
	netStat :   UINT; Status of the node in the network

state could have the following meanings:
(valid only if miss is TRUE )
	MB_E_PROTOCOL               -320    Protocol error
	MB_E_IDE                    -321    Ide not match                        
	MB_E_ILLEGALFUNCTION        -322    Illegal function                        
	MB_E_ILLEGALDATAADDR        -323    Illegal data address                    
	MB_E_ILLEGALDATAVALUE       -324    Illegal data value                      
	MB_E_SLAVEDEVICEFAILURE     -325    Slave device failure                    
	MB_E_ACKNOWLEDGE            -326    Acknowledge                             
	MB_E_SLAVEDEVICEBUSY        -327    Slave device busy                       
	MB_E_MEMORYPARITYERROR      -328    Memory parity error                     
	MB_E_GATEWAYPATHUNAV        -329    Gateway path unavailable                
	MB_E_GATEWAYDEVICEFAILED    -330    Gateway target device failed to respond 
	MB_E_TIMEOUT                -331    Time out richiesta
	MB_E_ILLEGALDATAPROTOCOL    -332    Illegal data value in protocol
	MB_E_SWITCHEDOFF            -335    Node is switched off	
	
netStat can have the following meanings:
(node == 0, master)
	MB_MST_NOT_READY            0    Not ready
	MB_MST_READY                1    Ready
	MB_MST_START                2    Start
	MB_MST_STOP                 3    Stop
	MB_MST_RUN                  4    Run
	MB_MST_STOPPED              5    Stopped
	MB_MST_ERROR                6    Error
	
(node &gt;= 1, slave)
	MB_SLV_DISCONNECTED         0    Disconnected
	MB_SLV_OPENCONN             1    Connection opened
	MB_SLV_CLOSECONN            2    Connection closed
	MB_SLV_PAR                  3    Parameters setting
	MB_SLV_RUN                  4    Running</descr>
							      <address index="60010" subIndex="2976" type="I" typeVar="B"/>
						</var>
						      <var dim0="248" name="sysMbMRtuNodeStatus_2" type="MBMNODESTATUS">
							      <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_2.
It is a structure of type MBMNODESTATUS composed by the following fields:
	cfg :       BOOL; Configurated
	pres :      BOOL; Present
	active : BOOL; Indicate if node is active on network
	miss :      BOOL; Slave failure
	address : UINT; Address
	missCnt:    UINT; Number of Task Timed cycles with Slave failure
	state :     INT; Slave failure error code
	netStat :   UINT; Status of the node in the network

state could have the following meanings:
(valid only if miss is TRUE )
	MB_E_PROTOCOL               -320    Protocol error
	MB_E_IDE                    -321    Ide not match                        
	MB_E_ILLEGALFUNCTION        -322    Illegal function                        
	MB_E_ILLEGALDATAADDR        -323    Illegal data address                    
	MB_E_ILLEGALDATAVALUE       -324    Illegal data value                      
	MB_E_SLAVEDEVICEFAILURE     -325    Slave device failure                    
	MB_E_ACKNOWLEDGE            -326    Acknowledge                             
	MB_E_SLAVEDEVICEBUSY        -327    Slave device busy                       
	MB_E_MEMORYPARITYERROR      -328    Memory parity error                     
	MB_E_GATEWAYPATHUNAV        -329    Gateway path unavailable                
	MB_E_GATEWAYDEVICEFAILED    -330    Gateway target device failed to respond 
	MB_E_TIMEOUT                -331    Time out richiesta
	MB_E_ILLEGALDATAPROTOCOL    -332    Illegal data value in protocol
	MB_E_SWITCHEDOFF            -335    Node is switched off	
	
netStat can have the following meanings:
(node == 0, master)
	MB_MST_NOT_READY            0    Not ready
	MB_MST_READY                1    Ready
	MB_MST_START                2    Start
	MB_MST_STOP                 3    Stop
	MB_MST_RUN                  4    Run
	MB_MST_STOPPED              5    Stopped
	MB_MST_ERROR                6    Error
	
(node &gt;= 1, slave)
	MB_SLV_DISCONNECTED         0    Disconnected
	MB_SLV_OPENCONN             1    Connection opened
	MB_SLV_CLOSECONN            2    Connection closed
	MB_SLV_PAR                  3    Parameters setting
	MB_SLV_RUN                  4    Running</descr>
							      <address index="60010" subIndex="5952" type="I" typeVar="B"/>
						</var>
						      <var dim0="248" name="sysMbMRtuNodeStatus_3" type="MBMNODESTATUS">
							      <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_3.
It is a structure of type MBMNODESTATUS composed by the following fields:
	cfg :       BOOL; Configurated
	pres :      BOOL; Present
	active : BOOL; Indicate if node is active on network
	miss :      BOOL; Slave failure
	address : UINT; Address
	missCnt:    UINT; Number of Task Timed cycles with Slave failure
	state :     INT; Slave failure error code
	netStat :   UINT; Status of the node in the network

state could have the following meanings:
(valid only if miss is TRUE )
	MB_E_PROTOCOL               -320    Protocol error
	MB_E_IDE                    -321    Ide not match                        
	MB_E_ILLEGALFUNCTION        -322    Illegal function                        
	MB_E_ILLEGALDATAADDR        -323    Illegal data address                    
	MB_E_ILLEGALDATAVALUE       -324    Illegal data value                      
	MB_E_SLAVEDEVICEFAILURE     -325    Slave device failure                    
	MB_E_ACKNOWLEDGE            -326    Acknowledge                             
	MB_E_SLAVEDEVICEBUSY        -327    Slave device busy                       
	MB_E_MEMORYPARITYERROR      -328    Memory parity error                     
	MB_E_GATEWAYPATHUNAV        -329    Gateway path unavailable                
	MB_E_GATEWAYDEVICEFAILED    -330    Gateway target device failed to respond 
	MB_E_TIMEOUT                -331    Time out richiesta
	MB_E_ILLEGALDATAPROTOCOL    -332    Illegal data value in protocol
	MB_E_SWITCHEDOFF            -335    Node is switched off	
	
netStat can have the following meanings:
(node == 0, master)
	MB_MST_NOT_READY            0    Not ready
	MB_MST_READY                1    Ready
	MB_MST_START                2    Start
	MB_MST_STOP                 3    Stop
	MB_MST_RUN                  4    Run
	MB_MST_STOPPED              5    Stopped
	MB_MST_ERROR                6    Error
	
(node &gt;= 1, slave)
	MB_SLV_DISCONNECTED         0    Disconnected
	MB_SLV_OPENCONN             1    Connection opened
	MB_SLV_CLOSECONN            2    Connection closed
	MB_SLV_PAR                  3    Parameters setting
	MB_SLV_RUN                  4    Running</descr>
							      <address index="60010" subIndex="8928" type="I" typeVar="B"/>
						</var>
					</group>
				</globalVars>
				    <retainVars>
					    <group excludeFromBuild="FALSE" name="Modbus_RTU_Master"/>
				</retainVars>
				    <constantVars>
					    <group excludeFromBuild="FALSE" name="Modbus_RTU_Master"/>
				</constantVars>
				    <iecVarsDeclaration>
					    <group name="Modbus_RTU_Master">
						      <iecDeclaration active="FALSE"/>
					</group>
				</iecVarsDeclaration>
				    <functions>
					    <function creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_Active" version="1.0.0">
						      <descr>It is possible to deactivate a node in the network with netId=0. Deprecated, use ModbusRTUNet_Active instead</descr>
						      <returnValue>BOOL</returnValue>
						      <vars>
							      <inputVars>
								        <var name="node" type="USINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="active" type="BOOL">
									        <descr>Activate node in network</descr>
								</var>
							</inputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <sourceCode type="EMBEDDED"/>
					</function>
					    <function creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_Active" version="1.0.0">
						      <descr>It is possible to activate/deactivate a node in the specified network</descr>
						      <returnValue>BOOL</returnValue>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network</descr>
								</var>
								        <var name="node" type="USINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="active" type="BOOL">
									        <descr>Activate node in network</descr>
								</var>
							</inputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <sourceCode type="EMBEDDED"/>
					</function>
					    <function creationDate="1575024867" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ChangeComPortSettings" version="1.0.0">
						      <title>Change COM port setting</title>
						      <descr>&lt;HTML&gt;It is possible to change port setting of a dedicated modbus RTU master COM port.&lt;br&gt;
It is possible to change parity, databits and stopbits. It is not possible to assign a different COM port.&lt;br&gt;
A valid port must be specified for modbus RTU master in configuration tool.</descr>
						      <returnValue>MB_COMPORT_SETTING_RIS_ENUM</returnValue>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="baudrate" type="UDINT">
									        <descr>Baudrate value</descr>
								</var>
								        <var name="parity" type="MB_COMPORT_SETTING_PARITY_ENUM">
									        <descr>Parity value</descr>
								</var>
								        <var name="databits" type="MB_COMPORT_SETTING_DATABITS_ENUM">
									        <descr>Databits value</descr>
								</var>
								        <var name="stopbits" type="MB_COMPORT_SETTING_STOPBITS_ENUM">
									        <descr>Stopbits value</descr>
								</var>
							</inputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <sourceCode type="EMBEDDED"/>
					</function>
				</functions>
				    <functionBlocks>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_WriteReg_S" version="1.0.0">
						      <descr>Write modbus register using WriteSingleRegister modbus command. For network with netId=0. Deprecated, use ModbusRTUNet_WriteReg_S instead</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_ReadReg_RW" version="1.0.0">
						      <descr>Read rw modbus register using ReadHoldingRegister modbus command. For network with netId=0. Deprecated, use ModbusRTUNet_ReadReg_RW instead</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_ReadReg_RO" version="1.0.0">
						      <descr>Read ro modbus register using ReadInputRegister modbus command. For network with netId=0. Deprecated, use ModbusRTUNet_ReadReg_RO instead</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_WriteReg_M" version="1.0.0">
						      <descr>Write modbus register using WriteMultipleRegisters modbus command. For network with netId=0. Deprecated, use ModbusRTUNet_WriteReg_M instead</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_S_Async" version="1.0.0">
						      <descr>Write modbus register using WriteSingleRegister modbus command asynchronously, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_M" version="1.0.0">
						      <descr>Write modbus register using WriteMultipleRegisters modbus command, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RW_Async" version="1.0.0">
						      <descr>Read rw modbus register using ReadHoldingRegister modbus command asynchronously, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RO" version="1.0.0">
						      <descr>Read ro modbus register using ReadInputRegister modbus command, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RW" version="1.0.0">
						      <descr>Read rw modbus register using ReadHoldingRegister modbus command, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_S" version="1.0.0">
						      <descr>Write modbus register using WriteSingleRegister modbus command, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_M_Async" version="1.0.0">
						      <descr>Write modbus register using WriteMultipleRegisters modbus command asynchronously, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RO_Async" version="1.0.0">
						      <descr>Read ro modbus register using ReadInputRegister modbus command asynchronously, from a node of the specified network</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
								</var>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MB_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadHoldingRegs_Async" version="1.0.0">
						      <title>Read holding registers - FC 03 modbus function - Async call</title>
						      <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleCoil" version="1.0.0">
						      <title>Write single coil - FC 05 modbus function</title>
						      <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddr" type="UINT">
									        <descr>Coil address</descr>
								</var>
								        <var name="coilValue" type="UINT">
									        <descr>Coil value. 0 or 1 value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultRegs" version="1.0.0">
						      <title>Write multiple registers - FC 16 modbus function</title>
						      <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved1" type="UINT"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the output buffer with registers values to transmit</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadDiscrInputs" version="1.0.0">
						      <title>Read discrete inputs - FC 02 modbus function</title>
						      <descr>&lt;HTML&gt;Read discrete inputs from target using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="discrInputStart" type="UINT">
									        <descr>Discrete input start address</descr>
								</var>
								        <var name="discrInputsNum" type="UINT">
									        <descr>Number of discrete inputs to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadCoils_Async" version="1.0.0">
						      <title>Read multiple coils - FC 01 modbus function - Async call</title>
						      <descr>Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddrStart" type="UINT">
									        <descr>Coil start address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadHoldingRegs" version="1.0.0">
						      <title>Read holding registers - FC 03 modbus function</title>
						      <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadInputRegs_Async" version="1.0.0">
						      <title>Read input registers - FC 04 modbus function - Async call</title>
						      <descr>&lt;HTML&gt;Read input registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleReg_Async" version="1.0.0">
						      <title>Write single register - FC 06 modbus function</title>
						      <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddr" type="UINT">
									        <descr>Register address</descr>
								</var>
								        <var name="regValue" type="UINT">
									        <descr>Register value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadDiscrInputs_Async" version="1.0.0">
						      <title>Read discrete inputs - FC 02 modbus function - Async call</title>
						      <descr>&lt;HTML&gt;Read discrete inputs from target using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="discrInputStart" type="UINT">
									        <descr>Discrete input start address</descr>
								</var>
								        <var name="discrInputsNum" type="UINT">
									        <descr>Number of discrete inputs to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadInputRegs" version="1.0.0">
						      <title>Read input registers - FC 04 modbus function</title>
						      <descr>&lt;HTML&gt;Read input registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadCoils" version="1.0.0">
						      <title>Read multiple coils - FC 01 modbus function</title>
						      <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddrStart" type="UINT">
									        <descr>Coil start address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultCoils_Async" version="1.0.0">
						      <title>Write multiple coils - FC 15 modbus function - Async call</title>
						      <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="coilStart" type="UINT">
									        <descr>First coil address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the input buffer (coils are packed as bit)</descr>
								</var>
								        <var name="pDataBoolIn" type="@BOOL">
									        <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultCoils" version="1.0.0">
						      <title>Write multiple coils - FC 15 modbus function</title>
						      <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="coilStart" type="UINT">
									        <descr>First coil address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the input buffer (coils are packed as bit)</descr>
								</var>
								        <var name="pDataBoolIn" type="@BOOL">
									        <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultRegs_Async" version="1.0.0">
						      <title>Write multiple registers - FC 16 modbus function - Async call</title>
						      <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved1" type="UINT"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the output buffer with registers values to transmit</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleReg" version="1.0.0">
						      <title>Write single register - FC 06 modbus function</title>
						      <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddr" type="UINT">
									        <descr>Register address</descr>
								</var>
								        <var name="regValue" type="UINT">
									        <descr>Register value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleCoil_Async" version="1.0.0">
						      <title>Write single coil - FC 05 modbus function - Async call</title>
						      <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Function block must be run the first time to set the request, then must be executed to check if request is completed.&lt;br&gt;
asyncRqStatus can be used to check the status of the request.&lt;br&gt;
When asyncRqStatus is MB_ASYN_RQ_STATUS_DONE, esi field can be checked and received data are filled into provided buffer&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddr" type="UINT">
									        <descr>Coil address</descr>
								</var>
								        <var name="coilValue" type="UINT">
									        <descr>Coil value. 0 or 1 value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MB_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1575025743" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_GetComPortInfo" version="1.0.0">
						      <title>Get actual communication port settings</title>
						      <descr>&lt;HTML&gt;Get communication port settings of a dedicated Modbus RTU master COM port.</descr>
						      <vars>
							      <inputVars>
								        <var name="netId" type="MB_RTU_NETWORK_ID">
									        <descr>Network id</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="isModbusPort" type="BOOL">
									        <descr>Indcate if port is used by Modbus RTU Master</descr>
								</var>
								        <var name="isOpened" type="BOOL">
									        <descr>Port is opened and used by Modbus RTU Master</descr>
								</var>
								        <var name="isReopening" type="BOOL">
									        <descr>Request to reopen port with different settings is in progress</descr>
								</var>
								        <var name="comNumber" type="USINT">
									        <descr>Com number</descr>
								</var>
								        <var length="32" name="comString" type="STRING">
									        <descr>Com string</descr>
								</var>
								        <var name="baudrate" type="UDINT">
									        <descr>Baudrate value</descr>
								</var>
								        <var name="parity" type="MB_COMPORT_SETTING_PARITY_ENUM">
									        <descr>Parity value</descr>
								</var>
								        <var name="databits" type="MB_COMPORT_SETTING_DATABITS_ENUM">
									        <descr>Databits value</descr>
								</var>
								        <var name="stopbits" type="MB_COMPORT_SETTING_STOPBITS_ENUM">
									        <descr>Stopbits value</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
				</functionBlocks>
				    <programs/>
				    <macros/>
				    <structs>
					    <struct name="MBMNODESTATUS" version="1.0.0">
						      <vars>
							      <var name="cfg" type="BOOL">
								        <descr>Configurated</descr>
							</var>
							      <var name="pres" type="BOOL">
								        <descr>Present</descr>
							</var>
							      <var name="active" type="BOOL">
								        <descr>Indicate if node is active on network</descr>
							</var>
							      <var name="miss" type="BOOL">
								        <descr>Slave failure</descr>
							</var>
							      <var name="address" type="UINT">
								        <descr>Address</descr>
							</var>
							      <var name="missCnt" type="UINT">
								        <descr>Number of Task Timed cycles with Slave failure</descr>
							</var>
							      <var name="state" type="INT">
								        <descr>Slave failure error code</descr>
							</var>
							      <var name="netStat" type="UINT">
								        <descr>Status of the node in the network</descr>
							</var>
						</vars>
						      <iecDeclaration active="FALSE"/>
					</struct>
				</structs>
				    <typedefs/>
				    <enums>
					    <enum name="MB_RTU_NETWORK_ID" version="1.0.0">
						      <descr>Modbus RTU Network ID</descr>
						      <elements>
							      <element name="MB_RTU_NETWORK_0">
								        <descr>Network 0</descr>
								        <value>0</value>
							</element>
							      <element name="MB_RTU_NETWORK_1">
								        <descr>Network 1</descr>
								        <value>1</value>
							</element>
							      <element name="MB_RTU_NETWORK_2">
								        <descr>Network 2</descr>
								        <value>2</value>
							</element>
							      <element name="MB_RTU_NETWORK_3">
								        <descr>Network 3</descr>
								        <value>3</value>
							</element>
							      <element name="MB_RTU_NETWORKS">
								        <descr>Maximum number of networks supported</descr>
								        <value>4</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MB_DATA_TYPE" version="1.0.0">
						      <descr>Data types for modbus call</descr>
						      <elements>
							      <element name="DATA_T_SINT">
								        <descr>SINT</descr>
								        <value>0</value>
							</element>
							      <element name="DATA_T_USINT">
								        <descr>USINT</descr>
								        <value>1</value>
							</element>
							      <element name="DATA_T_BYTE">
								        <descr>BYTE</descr>
								        <value>2</value>
							</element>
							      <element name="DATA_T_INT">
								        <descr>INT</descr>
								        <value>3</value>
							</element>
							      <element name="DATA_T_UINT">
								        <descr>UINT</descr>
								        <value>4</value>
							</element>
							      <element name="DATA_T_WORD">
								        <descr>WORD</descr>
								        <value>5</value>
							</element>
							      <element name="DATA_T_DINT">
								        <descr>DINT</descr>
								        <value>6</value>
							</element>
							      <element name="DATA_T_UDINT">
								        <descr>UDINT</descr>
								        <value>7</value>
							</element>
							      <element name="DATA_T_DWORD">
								        <descr>DWORD</descr>
								        <value>8</value>
							</element>
							      <element name="DATA_T_REAL">
								        <descr>REAL</descr>
								        <value>9</value>
							</element>
							      <element name="DATA_T_BOOL">
								        <descr>BOOL</descr>
								        <value>10</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MB_ESI_VALUE" version="1.0.0">
						      <descr>Return value from modbus function call</descr>
						      <elements>
							      <element name="MB_E_OK">
								        <descr>Successful command</descr>
								        <value>0</value>
							</element>
							      <element name="MB_E_NODE">
								        <descr>Not valid node</descr>
								        <value>-301</value>
							</element>
							      <element name="MB_E_NODENOTEXIST">
								        <descr>Not assigned node</descr>
								        <value>-303</value>
							</element>
							      <element name="MB_E_DATATYPE">
								        <descr>Data type parameter not valid</descr>
								        <value>-311</value>
							</element>
							      <element name="MB_E_PROTOCOL">
								        <descr>Protocol error</descr>
								        <value>-320</value>
							</element>
							      <element name="MB_E_IDE">
								        <descr>Ide doesn't match</descr>
								        <value>-321</value>
							</element>
							      <element name="MB_E_ILLEGALFUNCTION">
								        <descr>Illegal function</descr>
								        <value>-322</value>
							</element>
							      <element name="MB_E_ILLEGALDATAADDR">
								        <descr>Illegal data address</descr>
								        <value>-323</value>
							</element>
							      <element name="MB_E_ILLEGALDATAVALUE">
								        <descr>Illegal data value</descr>
								        <value>-324</value>
							</element>
							      <element name="MB_E_SLAVEDEVICEFAILURE">
								        <descr>Slave device failure</descr>
								        <value>-325</value>
							</element>
							      <element name="MB_E_ACKNOWLEDGE">
								        <descr>Acknowledge</descr>
								        <value>-326</value>
							</element>
							      <element name="MB_E_SLAVEDEVICEBUSY">
								        <descr>Slave device busy</descr>
								        <value>-327</value>
							</element>
							      <element name="MB_E_MEMORYPARITYERROR">
								        <descr>Memory parity error</descr>
								        <value>-328</value>
							</element>
							      <element name="MB_E_GATEWAYPATHUNAV">
								        <descr>Gateway path unavailable</descr>
								        <value>-329</value>
							</element>
							      <element name="MB_E_GATEWAYDEVICEFAILED">
								        <descr>Gateway target device failed to respond</descr>
								        <value>-330</value>
							</element>
							      <element name="MB_E_TIMEOUT">
								        <descr>Time out richiesta</descr>
								        <value>-331</value>
							</element>
							      <element name="MB_E_ILLEGALDATAPROTOCOL">
								        <descr>Illegal data value in protocol</descr>
								        <value>-332</value>
							</element>
							      <element name="MB_E_SWITCHEDOFF">
								        <descr>Node is switched off</descr>
								        <value>-335</value>
							</element>
							      <element name="MB_E_NOTALLOWEDINTIMEDTASK">
								        <descr>Function cannot be called in a timed task</descr>
								        <value>-336</value>
							</element>
							      <element name="MB_E_NEGATIVEACKNOWLEDGE">
								        <descr>Negative acknowledge</descr>
								        <value>-337</value>
							</element>
							      <element name="MB_E_CHECKSUM">
								        <descr>Checksum</descr>
								        <value>-338</value>
							</element>
							      <element name="MB_E_NETWORK">
								        <descr>Invalid network id specified</descr>
								        <value>-339</value>
							</element>
							      <element name="MB_E_CMDBUFFERSIZEERROR">
								        <descr>Invalid command buffer size error</descr>
								        <value>-340</value>
							</element>
							      <element name="MB_E_CMDBUFFERERROR">
								        <descr>Invalid command buffer error</descr>
								        <value>-341</value>
							</element>
							      <element name="MB_E_CMDBUFFERTOOSMALL">
								        <descr>Buffer too small</descr>
								        <value>-342</value>
							</element>
							      <element name="MB_E_CMDSAMEBUFFER">
								        <descr>Same buffer specified</descr>
								        <value>-343</value>
							</element>
							      <element name="MB_E_CMDPARAMERROR">
								        <descr>Invalid parameter specified</descr>
								        <value>-344</value>
							</element>
							      <element name="MB_E_NOCONNSLOTAVAILABLE">
								        <descr>Connection error</descr>
								        <value>-345</value>
							</element>
							      <element name="MB_E_NOCONNSYSTEMBUSY">
								        <descr>System busy</descr>
								        <value>-346</value>
							</element>
							      <element name="MB_E_REQUESTMISMATCH">
								        <descr>Request mismatch</descr>
								        <value>-347</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MB_ASYNC_RQ_STATUS" version="1.0.0">
						      <descr>Status of the async request</descr>
						      <elements>
							      <element name="MB_ASYNC_RQ_UNKNOWN">
								        <descr>Initial or unknown status</descr>
								        <value>0</value>
							</element>
							      <element name="MB_ASYNC_RQ_ERROR">
								        <descr>Error in setting request</descr>
								        <value>1</value>
							</element>
							      <element name="MB_ASYNC_RQ_SET">
								        <descr>Status take this value when request is successfully set</descr>
								        <value>2</value>
							</element>
							      <element name="MB_ASYNC_RQ_BUSY">
								        <descr>Request in progress</descr>
								        <value>3</value>
							</element>
							      <element name="MB_ASYNC_RQ_DONE">
								        <descr>Request completed. Command result can be checked. Other requests can be done</descr>
								        <value>4</value>
							</element>
							      <element name="MB_ASYNC_RQ_MISMATCH">
								        <descr>Request set by user and processed mismatch from actual frame command</descr>
								        <value>5</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MB_COMPORT_SETTING_DATABITS_ENUM" version="1.0.0">
						      <elements>
							      <element name="MB_COMPORT_SETTING_DATABITS_7">
								        <descr>Databits 7</descr>
								        <value>7</value>
							</element>
							      <element name="MB_COMPORT_SETTING_DATABITS_8">
								        <descr>Databits 8</descr>
								        <value>8</value>
							</element>
							      <element name="MB_COMPORT_SETTING_DATABITS_UNKNOWN">
								        <descr>Unknown</descr>
								        <value>255</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MB_COMPORT_SETTING_PARITY_ENUM" version="1.0.0">
						      <elements>
							      <element name="MB_COMPORT_SETTING_PARITY_NONE">
								        <descr>Parity none</descr>
								        <value>0</value>
							</element>
							      <element name="MB_COMPORT_SETTING_PARITY_ODD">
								        <descr>Parity odd</descr>
								        <value>1</value>
							</element>
							      <element name="MB_COMPORT_SETTING_PARITY_EVEN">
								        <descr>Parity error</descr>
								        <value>2</value>
							</element>
							      <element name="MB_COMPORT_SETTING_PARITY_UNKNOWN">
								        <descr>Unknown</descr>
								        <value>255</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MB_COMPORT_SETTING_RIS_ENUM" version="1.0.0">
						      <elements>
							      <element name="MB_COMPORT_SETTING_RIS_OK">
								        <descr>Ok</descr>
								        <value>0</value>
							</element>
							      <element name="MB_COMPORT_SETTING_ERR_INVALID_NETID">
								        <descr>Invalid network id specified</descr>
								        <value>1</value>
							</element>
							      <element name="MB_COMPORT_SETTING_ERR_NO_MODBUS">
								        <descr>Modbus master not running on this network</descr>
								        <value>2</value>
							</element>
							      <element name="MB_COMPORT_SETTING_ERR_PARAM_PARITY">
								        <descr>Parity error</descr>
								        <value>3</value>
							</element>
							      <element name="MB_COMPORT_SETTING_ERR_PARAM_DATABITS">
								        <descr>Databits error</descr>
								        <value>4</value>
							</element>
							      <element name="MB_COMPORT_SETTING_ERR_PARAM_STOPBITS">
								        <descr>Stopbits error</descr>
								        <value>5</value>
							</element>
							      <element name="MB_COMPORT_SETTING_ERR_REQUEST_ALREADY_SET">
								        <descr>Request to change port settings already in progress</descr>
								        <value>6</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MB_COMPORT_SETTING_STOPBITS_ENUM" version="1.0.0">
						      <elements>
							      <element name="MB_COMPORT_SETTING_STOPBITS_1">
								        <descr>One stopbit</descr>
								        <value>1</value>
							</element>
							      <element name="MB_COMPORT_SETTING_STOPBITS_2">
								        <descr>Two stopbits</descr>
								        <value>2</value>
							</element>
							      <element name="MB_COMPORT_SETTING_STOPBITS_UNKNOWN">
								        <descr>Unknown setting</descr>
								        <value>255</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
				</enums>
				    <subranges/>
				    <interfaces/>
			</lib>  <lib fullXml="true" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\Libraries\ModbusTCP.plclib" version="1.0.0">
				    <descr>ModbusTCP master library</descr>
				    <libWorkspace>
					    <folder id="49" name="ModbusTCP">
						      <folder name="Definitions">
							      <folder name="Enumerations">
								        <Definition name="MBTCP_ASYNC_RQ_STATUS"/>
								        <Definition name="MBTCP_DATA_TYPE"/>
								        <Definition name="MBTCP_ESI_VALUE"/>
							</folder>
							      <folder name="Structures">
								        <Definition name="MBMTCPNODESTATUS"/>
							</folder>
						</folder>
						      <GlobalVars name="Modbus_TCP_Master"/>
						      <folder name="Raw commands">
							      <Pou name="ModbusTCP_WriteSingleReg_Async"/>
							      <Pou name="ModbusTCP_WriteMultRegs"/>
							      <Pou name="ModbusTCP_WriteSingleCoil"/>
							      <Pou name="ModbusTCP_WriteSingleCoil_Async"/>
							      <Pou name="ModbusTCP_ReadInputRegs_Async"/>
							      <Pou name="ModbusTCP_ReadDiscrInputs"/>
							      <Pou name="ModbusTCP_ReadDiscrInputs_Async"/>
							      <Pou name="ModbusTCP_ReadHoldingRegs"/>
							      <Pou name="ModbusTCP_ReadInputRegs"/>
							      <Pou name="ModbusTCP_ReadHoldingRegs_Async"/>
							      <Pou name="ModbusTCP_WriteMultCoils"/>
							      <Pou name="ModbusTCP_WriteSingleReg"/>
							      <Pou name="ModbusTCP_ReadCoils"/>
							      <Pou name="ModbusTCP_ReadCoils_Async"/>
							      <Pou name="ModbusTCP_WriteMultCoils_Async"/>
							      <Pou name="ModbusTCP_WriteMultRegs_Async"/>
						</folder>
						      <folder name="Network commands">
							      <Pou name="ModbusTCP_WriteReg_M_Async"/>
							      <Pou name="ModbusTCP_ReadReg_RO_Async"/>
							      <Pou name="ModbusTCP_ReadReg_RO"/>
							      <Pou name="ModbusTCP_WriteReg_M"/>
							      <Pou name="ModbusTCP_ReadReg_RW"/>
							      <Pou name="ModbusTCP_WriteReg_S_Async"/>
							      <Pou name="ModbusTCP_ReadReg_RW_Async"/>
							      <Pou name="ModbusTCP_WriteReg_S"/>
						</folder>
					</folder>
				</libWorkspace>
				    <globalVars>
					    <group excludeFromBuild="FALSE" name="Modbus_TCP_Master">
						      <var dim0="248" name="sysMbMTcpNodeStatus" type="MBMTCPNODESTATUS">
							      <descr>System Modbus Master TCP communication status. It is a structure of type MBMTCPNODESTATUS composed
by the following fields:
	cfg :       BOOL; Configurated
	pres :      BOOL; Present
	active : BOOL; Indicate if node is active on network
	miss :      BOOL; Slave failure
	ip : STRING; IP address
	address : UINT; Subnet Address
	missCnt:    UINT; Number of Task Timed cycles with Slave failure
	state : INT; Slave failure error code
	netStat : UINT; Status of the node in the network

state could have the following meanings:
(valid only if miss is TRUE )
	MB_E_PROTOCOL               -320    Protocol error
	MB_E_IDE                    -321    Ide not match                        
	MB_E_ILLEGALFUNCTION        -322    Illegal function                        
	MB_E_ILLEGALDATAADDR        -323    Illegal data address                    
	MB_E_ILLEGALDATAVALUE       -324    Illegal data value                      
	MB_E_SLAVEDEVICEFAILURE     -325    Slave device failure                    
	MB_E_ACKNOWLEDGE            -326    Acknowledge                             
	MB_E_SLAVEDEVICEBUSY        -327    Slave device busy                       
	MB_E_MEMORYPARITYERROR      -328    Memory parity error                     
	MB_E_GATEWAYPATHUNAV        -329    Gateway path unavailable                
	MB_E_GATEWAYDEVICEFAILED    -330    Gateway target device failed to respond 
	MB_E_TIMEOUT                -331    Time out richiesta
	MB_E_ILLEGALDATAPROTOCOL    -332    Illegal data value in protocol
	MB_E_COMMUNICATION          -333    Communication error
	MB_E_CONNECTION             -334    Connection error	
	
netStat can have the following meanings:
(node == 0, master)
	MB_MST_NOT_READY            0    Not ready
	MB_MST_READY                1    Ready
	MB_MST_START                2    Start
	MB_MST_STOP                 3    Stop
	MB_MST_RUN                  4    Run
	MB_MST_STOPPED              5    Stopped
	MB_MST_ERROR                6    Error
	
(node &gt;= 1, slave)
	MB_SLV_DISCONNECTED         0    Disconnected
	MB_SLV_OPENCONN             1    Connection opened
	MB_SLV_CLOSECONN            2    Connection closed
	MB_SLV_PAR                  3    Parameters setting
	MB_SLV_RUN                  4    Running
	MB_SLV_WAITCONN             5    Waiting for connection establishment</descr>
							      <address index="60020" subIndex="0" type="I" typeVar="B"/>
						</var>
					</group>
				</globalVars>
				    <retainVars>
					    <group excludeFromBuild="FALSE" name="Modbus_TCP_Master"/>
				</retainVars>
				    <constantVars>
					    <group excludeFromBuild="FALSE" name="Modbus_TCP_Master"/>
				</constantVars>
				    <iecVarsDeclaration>
					    <group name="Modbus_TCP_Master">
						      <iecDeclaration active="FALSE"/>
					</group>
				</iecVarsDeclaration>
				    <functions/>
				    <functionBlocks>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleReg_Async" version="1.0.0">
						      <title>Write single register - FC 06 modbus function</title>
						      <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddr" type="UINT">
									        <descr>Register address</descr>
								</var>
								        <var name="regValue" type="UINT">
									        <descr>Register value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultRegs" version="1.0.0">
						      <title>Write multiple registers - FC 16 modbus function</title>
						      <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the output buffer with registers values to transmit</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleCoil" version="1.0.0">
						      <title>Write single coil - FC 05 modbus function</title>
						      <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddr" type="UINT">
									        <descr>Coil address</descr>
								</var>
								        <var name="coilValue" type="UINT">
									        <descr>Coil value. 0 or 1 value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleCoil_Async" version="1.0.0">
						      <title>Write single coil - FC 05 modbus function</title>
						      <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddr" type="UINT">
									        <descr>Coil address</descr>
								</var>
								        <var name="coilValue" type="UINT">
									        <descr>Coil value. 0 or 1 value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadInputRegs_Async" version="1.0.0">
						      <title>Read holding registers - FC 03 modbus function</title>
						      <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="UINT"/>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadDiscrInputs" version="1.0.0">
						      <title>Read multiple coils - FC 01 modbus function</title>
						      <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="discrInputStart" type="UINT">
									        <descr>Discrete input start address</descr>
								</var>
								        <var name="discrInputsNum" type="UINT">
									        <descr>Number of discrete inputs to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadDiscrInputs_Async" version="1.0.0">
						      <title>Read multiple coils - FC 01 modbus function</title>
						      <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="discrInputStart" type="UINT">
									        <descr>Discrete input start address</descr>
								</var>
								        <var name="discrInputsNum" type="UINT">
									        <descr>Number of discrete inputs to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadHoldingRegs" version="1.0.0">
						      <title>Read holding registers - FC 03 modbus function</title>
						      <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="UINT"/>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadInputRegs" version="1.0.0">
						      <title>Read holding registers - FC 03 modbus function</title>
						      <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="UINT"/>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadHoldingRegs_Async" version="1.0.0">
						      <title>Read holding registers - FC 03 modbus function</title>
						      <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="UINT"/>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Number of bytes of data received stored in pDataOut</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultCoils" version="1.0.0">
						      <title>Write multiple coils - FC 15 modbus function</title>
						      <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="coilStart" type="UINT">
									        <descr>First coil address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the input buffer (coils are packed as bit)</descr>
								</var>
								        <var name="pDataBoolIn" type="@BOOL">
									        <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleReg" version="1.0.0">
						      <title>Write single register - FC 06 modbus function</title>
						      <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="regAddr" type="UINT">
									        <descr>Register address</descr>
								</var>
								        <var name="regValue" type="UINT">
									        <descr>Register value</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadCoils" version="1.0.0">
						      <title>Read multiple coils - FC 01 modbus function</title>
						      <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddrStart" type="UINT">
									        <descr>Coil start address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadCoils_Async" version="1.0.0">
						      <title>Read multiple coils - FC 01 modbus function</title>
						      <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="coilAddrStart" type="UINT">
									        <descr>Coil start address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils to read</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
								</var>
								        <var name="pDataOut" type="DWORD">
									        <descr>Address of the output buffer (coils will be packed as bit)</descr>
								</var>
								        <var name="pDataBoolOut" type="@BOOL">
									        <descr>Address of the output buffer (each coil requires a BOOL)</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="sizeOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataOut buffer</descr>
								</var>
								        <var name="sizeBoolOut" type="UINT">
									        <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
								</var>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultCoils_Async" version="1.0.0">
						      <title>Write multiple coils - FC 15 modbus function</title>
						      <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="coilStart" type="UINT">
									        <descr>First coil address</descr>
								</var>
								        <var name="coilsNum" type="UINT">
									        <descr>Number of coils</descr>
								</var>
								        <var name="_reserved1" type="WORD"/>
								        <var name="sizeIn" type="UINT">
									        <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
								</var>
								        <var name="sizeBoolIn" type="UINT">
									        <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the input buffer (coils are packed as bit)</descr>
								</var>
								        <var name="pDataBoolIn" type="@BOOL">
									        <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultRegs_Async" version="1.0.0">
						      <title>Write multiple registers - FC 16 modbus function</title>
						      <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
						      <vars>
							      <inputVars>
								        <var length="15" name="IPAddress" type="STRING">
									        <descr>IP address</descr>
								</var>
								        <var name="TCPPort" type="UINT">
									        <descr>TCP port</descr>
								</var>
								        <var name="modbusAddr" type="UINT">
									        <descr>Modbus network node address</descr>
								</var>
								        <var name="_reserved" type="WORD"/>
								        <var name="regAddrStart" type="UINT">
									        <descr>Register start address</descr>
								</var>
								        <var name="regNum" type="UINT">
									        <descr>Number of registers</descr>
								</var>
								        <var name="sizeIn" type="UINT">
									        <descr>Max size in bytes of the output buffer</descr>
								</var>
								        <var name="pDataIn" type="DWORD">
									        <descr>Address of the output buffer with registers values to transmit</descr>
								</var>
								        <var name="timeoutMs" type="UINT">
									        <descr>Timeout in ms</descr>
								</var>
								        <var name="waitBeforeSendMs" type="UINT">
									        <descr>Wait before send in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Result of the command. One of the MB_ESI_VALUE</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Async request result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885197" name="ModbusTCP_WriteReg_M_Async" version="1.0.0">
						      <descr>Write modbus register using WriteMultipleRegisters modbus command asynchronously</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCP_ReadReg_RO_Async" version="1.0.0">
						      <descr>Read ro modbus register using ReadInputRegister modbus command asynchronously</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCP_ReadReg_RO" version="1.0.0">
						      <descr>Read ro modbus register using ReadInputRegister modbus command</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885187" name="ModbusTCP_WriteReg_M" version="1.0.0">
						      <descr>Write modbus register using WriteMultipleRegisters modbus command</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCP_ReadReg_RW" version="1.0.0">
						      <descr>Read rw modbus register using ReadHoldingRegister modbus command</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885230" name="ModbusTCP_WriteReg_S_Async" version="1.0.0">
						      <descr>Write modbus register using WriteSingleRegister modbus command asynchronously</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCP_ReadReg_RW_Async" version="1.0.0">
						      <descr>Read rw modbus register using ReadHoldingRegister modbus command asynchronously</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
								        <var name="res_dword" type="DWORD">
									        <descr>Result is always put in a dword</descr>
								</var>
								        <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
									        <descr>Status of the async request</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885216" name="ModbusTCP_WriteReg_S" version="1.0.0">
						      <descr>Write modbus register using WriteSingleRegister modbus command</descr>
						      <vars>
							      <inputVars>
								        <var name="node" type="UINT">
									        <descr>The index of the node in the network</descr>
								</var>
								        <var name="reg_addr" type="UINT">
									        <descr>The address of the register to read</descr>
								</var>
								        <var name="data_type" type="MBTCP_DATA_TYPE">
									        <descr>The type of the data to read</descr>
								</var>
								        <var name="data_raw" type="DWORD">
									        <descr>Data to be written</descr>
								</var>
								        <var name="tmo" type="UDINT">
									        <descr>Timeout in ms</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="esi" type="MBTCP_ESI_VALUE">
									        <descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
				</functionBlocks>
				    <programs/>
				    <macros/>
				    <structs>
					    <struct name="MBMTCPNODESTATUS" version="1.0.0">
						      <vars>
							      <var name="cfg" type="BOOL">
								        <descr>Configurated</descr>
							</var>
							      <var name="pres" type="BOOL">
								        <descr>Present</descr>
							</var>
							      <var name="active" type="BOOL">
								        <descr>Indicate if node is active on network</descr>
							</var>
							      <var name="miss" type="BOOL">
								        <descr>Slave failure</descr>
							</var>
							      <var length="19" name="ip" type="STRING">
								        <descr>IP address</descr>
							</var>
							      <var name="address" type="UINT">
								        <descr>Subnet Address</descr>
							</var>
							      <var name="missCnt" type="UINT">
								        <descr>Number of Task Timed cycles with Slave failure</descr>
							</var>
							      <var name="state" type="INT">
								        <descr>Slave failure error code</descr>
							</var>
							      <var name="netStat" type="UINT">
								        <descr>Status of the node in the network</descr>
							</var>
						</vars>
						      <iecDeclaration active="FALSE"/>
					</struct>
				</structs>
				    <typedefs/>
				    <enums>
					    <enum name="MBTCP_ASYNC_RQ_STATUS" version="1.0.0">
						      <descr>Status of the async request</descr>
						      <elements>
							      <element name="MBTCP_ASYNC_RQ_UNKNOWN">
								        <descr>Initial or unknown status</descr>
								        <value>0</value>
							</element>
							      <element name="MBTCP_ASYNC_RQ_ERROR">
								        <descr>Error in setting request</descr>
								        <value>1</value>
							</element>
							      <element name="MBTCP_ASYNC_RQ_SET">
								        <descr>Status take this value when request is successfully set</descr>
								        <value>2</value>
							</element>
							      <element name="MBTCP_ASYNC_RQ_BUSY">
								        <descr>Request in progress</descr>
								        <value>3</value>
							</element>
							      <element name="MBTCP_ASYNC_RQ_DONE">
								        <descr>Request completed. Command result can be checked. Other requests can be done</descr>
								        <value>4</value>
							</element>
							      <element name="MBTCP_ASYNC_RQ_MISMATCH">
								        <descr>Request set by user and processed mismatch from actual frame command</descr>
								        <value>5</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MBTCP_DATA_TYPE" version="1.0.0">
						      <descr>Data types for modbus call</descr>
						      <elements>
							      <element name="MBTCP_DATA_T_SINT">
								        <descr>SINT</descr>
								        <value>0</value>
							</element>
							      <element name="MBTCP_DATA_T_USINT">
								        <descr>USINT</descr>
								        <value>1</value>
							</element>
							      <element name="MBTCP_DATA_T_BYTE">
								        <descr>BYTE</descr>
								        <value>2</value>
							</element>
							      <element name="MBTCP_DATA_T_INT">
								        <descr>INT</descr>
								        <value>3</value>
							</element>
							      <element name="MBTCP_DATA_T_UINT">
								        <descr>UINT</descr>
								        <value>4</value>
							</element>
							      <element name="MBTCP_DATA_T_WORD">
								        <descr>WORD</descr>
								        <value>5</value>
							</element>
							      <element name="MBTCP_DATA_T_DINT">
								        <descr>DINT</descr>
								        <value>6</value>
							</element>
							      <element name="MBTCP_DATA_T_UDINT">
								        <descr>UDINT</descr>
								        <value>7</value>
							</element>
							      <element name="MBTCP_DATA_T_DWORD">
								        <descr>DWORD</descr>
								        <value>8</value>
							</element>
							      <element name="MBTCP_DATA_T_REAL">
								        <descr>REAL</descr>
								        <value>9</value>
							</element>
							      <element name="MBTCP_DATA_T_BOOL">
								        <descr>BOOL</descr>
								        <value>10</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MBTCP_ESI_VALUE" version="1.0.0">
						      <descr>Return value from modbus function call</descr>
						      <elements>
							      <element name="MBTCP_E_NETWORK">
								        <descr>Invalid network id specified</descr>
								        <value>-339</value>
							</element>
							      <element name="MBTCP_E_CHECKSUM">
								        <descr>Checksum</descr>
								        <value>-338</value>
							</element>
							      <element name="MBTCP_E_NEGATIVEACKNOWLEDGE">
								        <descr>Negative acknowledge</descr>
								        <value>-337</value>
							</element>
							      <element name="MBTCP_E_NOTALLOWEDINTIMEDTASK">
								        <descr>Function cannot be called in a timed task</descr>
								        <value>-336</value>
							</element>
							      <element name="MBTCP_E_SWITCHEDOFF">
								        <descr>Node is switched off</descr>
								        <value>-335</value>
							</element>
							      <element name="MBTCP_E_CONNECTION">
								        <descr>Cannot connect to slave</descr>
								        <value>-334</value>
							</element>
							      <element name="MBTCP_E_COMMUNICATION">
								        <descr>Communication error</descr>
								        <value>-333</value>
							</element>
							      <element name="MBTCP_E_ILLEGALDATAPROTOCOL">
								        <descr>Illegal data value in protocol</descr>
								        <value>-332</value>
							</element>
							      <element name="MBTCP_E_TIMEOUT">
								        <descr>Time out richiesta</descr>
								        <value>-331</value>
							</element>
							      <element name="MBTCP_E_GATEWAYDEVICEFAILED">
								        <descr>Gateway target device failed to respond</descr>
								        <value>-330</value>
							</element>
							      <element name="MBTCP_E_GATEWAYPATHUNAV">
								        <descr>Gateway path unavailable</descr>
								        <value>-329</value>
							</element>
							      <element name="MBTCP_E_MEMORYPARITYERROR">
								        <descr>Memory parity error</descr>
								        <value>-328</value>
							</element>
							      <element name="MBTCP_E_SLAVEDEVICEBUSY">
								        <descr>Slave device busy</descr>
								        <value>-327</value>
							</element>
							      <element name="MBTCP_E_ACKNOWLEDGE">
								        <descr>Acknowledge</descr>
								        <value>-326</value>
							</element>
							      <element name="MBTCP_E_SLAVEDEVICEFAILURE">
								        <descr>Slave device failure</descr>
								        <value>-325</value>
							</element>
							      <element name="MBTCP_E_ILLEGALDATAVALUE">
								        <descr>Illegal data value</descr>
								        <value>-324</value>
							</element>
							      <element name="MBTCP_E_ILLEGALDATAADDR">
								        <descr>Illegal data address</descr>
								        <value>-323</value>
							</element>
							      <element name="MBTCP_E_ILLEGALFUNCTION">
								        <descr>Illegal function</descr>
								        <value>-322</value>
							</element>
							      <element name="MBTCP_E_IDE">
								        <descr>Ide doesn't match</descr>
								        <value>-321</value>
							</element>
							      <element name="MBTCP_E_PROTOCOL">
								        <descr>Protocol error</descr>
								        <value>-320</value>
							</element>
							      <element name="MBTCP_E_DATATYPE">
								        <descr>Data type parameter not valid</descr>
								        <value>-311</value>
							</element>
							      <element name="MBTCP_E_NODENOTEXIST">
								        <descr>Not assigned node</descr>
								        <value>-303</value>
							</element>
							      <element name="MBTCP_E_NODE">
								        <descr>Not valid node</descr>
								        <value>-301</value>
							</element>
							      <element name="MBTCP_E_OK">
								        <descr>Successful command</descr>
								        <value>0</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
				</enums>
				    <subranges/>
				    <interfaces/>
			</lib>  <lib fullXml="true" link="true" name="c:\program files (x86)\axel pc tools\catalog\rasppi_2p2\rasppi\..\Libraries\MQTTLib.plclib" version="1.0.0">
				    <descr>MQTT Publish and Subscribe library</descr>
				    <libWorkspace>
					    <folder name="MQTTLib">
						      <Definition name="MQTT_Error"/>
						      <Pou name="MQTT_Ping"/>
						      <Pou name="MQTT_Publish"/>
						      <Definition name="MQTT_DataType"/>
						      <Pou name="MQTT_Subscribe"/>
						      <Pou name="MQTT_ConnectionOpen"/>
						      <Pou name="MQTT_ConnectionClose"/>
						      <Pou name="MQTT_GetConnErrorState"/>
						      <Definition name="MQTTEngineStatus"/>
						      <Definition name="MQTTEndpointStatus"/>
						      <GlobalVars name="Variables"/>
					</folder>
				</libWorkspace>
				    <globalVars>
					    <group excludeFromBuild="FALSE" name="Variables">
						      <var name="sysMQTTEngineStatus" type="MQTTEngineStatus">
							      <address index="60098" subIndex="0" type="M" typeVar="B"/>
						</var>
						      <var dim0="100" name="sysMQTTEndpointStatus" type="MQTTEndpointStatus">
							      <address index="60099" subIndex="0" type="M" typeVar="B"/>
						</var>
					</group>
				</globalVars>
				    <retainVars>
					    <group excludeFromBuild="FALSE" name="Variables"/>
				</retainVars>
				    <constantVars>
					    <group excludeFromBuild="FALSE" name="Variables"/>
				</constantVars>
				    <iecVarsDeclaration>
					    <group name="Variables">
						      <iecDeclaration active="FALSE"/>
					</group>
				</iecVarsDeclaration>
				    <functions>
					    <function creationDate="1592411969" excludeFromBuild="FALSE" lastModifiedDate="1593507208" name="MQTT_GetConnErrorState" version="1.0.0">
						      <title>Get state of an mqtt connection</title>
						      <descr>Open connections gets MQTTE_Ok</descr>
						      <returnValue>MQTT_Error</returnValue>
						      <vars>
							      <inputVars>
								        <var name="connHandle" type="INT">
									        <descr>Connection Handle</descr>
								</var>
							</inputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <sourceCode type="EMBEDDED"/>
					</function>
					    <function creationDate="1592406764" excludeFromBuild="FALSE" lastModifiedDate="1593507208" name="MQTT_ConnectionClose" version="1.0.0">
						      <title>Connection Close</title>
						      <descr>Close an MQTT Connection</descr>
						      <returnValue>MQTT_Error</returnValue>
						      <vars>
							      <inputVars>
								        <var name="connHandle" type="INT">
									        <descr>Connection Handle</descr>
								</var>
							</inputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <sourceCode type="EMBEDDED"/>
					</function>
					    <function creationDate="1592406585" excludeFromBuild="FALSE" lastModifiedDate="1594721258" name="MQTT_ConnectionOpen" version="1.0.0">
						      <title>Open MQTT Connection</title>
						      <descr>Estabilish a connection with a mqtt broker,
needs username, password and a unique connection name</descr>
						      <returnValue>INT</returnValue>
						      <vars>
							      <inputVars>
								        <var name="server" type="STRING">
									        <descr>server : port</descr>
								</var>
								        <var name="username" type="STRING">
									        <descr>Username</descr>
								</var>
								        <var name="password" type="STRING">
									        <descr>Password</descr>
								</var>
								        <var name="clientname" type="STRING">
									        <descr>Unique client name</descr>
								</var>
								        <var name="tls" type="BOOL">
									        <descr>Enable TLS communication</descr>
								</var>
								        <var name="commonNameServer" type="STRING">
									        <descr>Required for TLS communication</descr>
								</var>
							</inputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <sourceCode type="EMBEDDED"/>
					</function>
				</functions>
				    <functionBlocks>
					    <functionBlock creationDate="1591258468" excludeFromBuild="FALSE" lastModifiedDate="1593507208" name="MQTT_Subscribe" version="1.0.0">
						      <title>Subscribe</title>
						      <descr>Subscribe to mqtt single topic</descr>
						      <vars>
							      <inputVars>
								        <var name="connHandle" type="INT">
									        <descr>Connection Handle</descr>
								</var>
								        <var length="63" name="topic" type="STRING">
									        <descr>Single topic</descr>
								</var>
								        <var name="QoS" type="USINT">
									        <descr>Subscribe Quality of Service (upper bound for message QoS)</descr>
									        <initValue>0</initValue>
								</var>
								        <var name="dataType" type="MQTT_DataType">
									        <descr>Data type</descr>
								</var>
								        <var name="dataSize" type="UINT">
									        <descr>Data size needed for MQTTDT_RAW</descr>
								</var>
								        <var name="dataOutAddr" type="ULINT">
									        <descr>Data address for MQTTDT_RAW</descr>
								</var>
								        <var name="stop" type="BOOL">
									        <descr>Stop/Unsubscribe command</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="error" type="MQTT_Error">
									        <descr>Error code</descr>
								</var>
								        <var name="done" type="BOOL">
									        <descr>Done flag</descr>
								</var>
								        <var name="busy" type="BOOL">
									        <descr>Busy flag</descr>
								</var>
								        <var name="newData" type="BOOL">
									        <descr>New data flag</descr>
								</var>
								        <var name="dischargedValues" type="BOOL">
									        <descr>Overflow flag</descr>
								</var>
								        <var name="dataOutBool" type="BOOL">
									        <descr>Output boolean value</descr>
								</var>
								        <var name="dataOutInt" type="LINT">
									        <descr>Output int value</descr>
								</var>
								        <var name="dataOutReal" type="LREAL">
									        <descr>Output real value</descr>
								</var>
								        <var length="63" name="dataOutString" type="STRING">
									        <descr>Output string value</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1591257472" excludeFromBuild="FALSE" lastModifiedDate="1594735452" name="MQTT_Publish" version="1.0.0">
						      <title>Publish</title>
						      <descr>Publish a single mqtt topic value</descr>
						      <vars>
							      <inputVars>
								        <var name="connHandle" type="INT">
									        <descr>Connection Handle</descr>
								</var>
								        <var length="63" name="topic" type="STRING">
									        <descr>Single topic</descr>
								</var>
								        <var name="dataType" type="MQTT_DataType">
									        <descr>Data Type</descr>
								</var>
								        <var name="dataSize" type="UINT">
									        <descr>Size needed for type MQTTDT_RAW</descr>
									        <initValue>0</initValue>
								</var>
								        <var name="dataInBool" type="BOOL">
									        <descr>Input boolean value</descr>
								</var>
								        <var name="dataInInt" type="ULINT">
									        <descr>Input int value</descr>
								</var>
								        <var name="dataInReal" type="LREAL">
									        <descr>Input real value</descr>
								</var>
								        <var length="63" name="dataInString" type="STRING">
									        <descr>Input string value</descr>
								</var>
								        <var name="dataInAddr" type="ULINT">
									        <descr>Input RAW address</descr>
									        <initValue>0</initValue>
								</var>
								        <var name="QoS" type="USINT">
									        <descr>Quality of Service (0,1,2)</descr>
									        <initValue>0</initValue>
								</var>
								        <var name="retained" type="BOOL"/>
							</inputVars>
							      <outputVars>
								        <var name="error" type="MQTT_Error">
									        <descr>Error code</descr>
								</var>
								        <var name="done" type="BOOL">
									        <descr>Done flag</descr>
								</var>
								        <var name="busy" type="BOOL">
									        <descr>Busy flag</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
					    <functionBlock creationDate="1591257225" excludeFromBuild="FALSE" lastModifiedDate="1593507208" name="MQTT_Ping" version="1.0.0">
						      <title>Ping</title>
						      <descr>Ping a broker to check the connection state</descr>
						      <vars>
							      <inputVars>
								        <var name="connHandle" type="INT">
									        <descr>Connection Handle</descr>
								</var>
							</inputVars>
							      <outputVars>
								        <var name="error" type="MQTT_Error">
									        <descr>Error code</descr>
								</var>
								        <var name="done" type="BOOL">
									        <descr>Done flag</descr>
								</var>
								        <var name="busy" type="BOOL">
									        <descr>Busy flag</descr>
								</var>
							</outputVars>
						</vars>
						      <iecDeclaration active="FALSE"/>
						      <interfaces/>
						      <methods/>
						      <sourceCode type="EMBEDDED"/>
					</functionBlock>
				</functionBlocks>
				    <programs/>
				    <macros/>
				    <structs>
					    <struct name="MQTTEndpointStatus" version="1.0.0">
						      <vars>
							      <var name="configured" type="BOOL"/>
							      <var name="handle" type="INT"/>
							      <var name="connectionState" type="MQTT_Error"/>
							      <var name="numPublishItems" type="UDINT"/>
							      <var name="numSubscribeItems" type="UDINT"/>
							      <var name="lastError" type="MQTT_Error"/>
							      <var name="errorPublishIdx" type="UDINT"/>
							      <var name="errorSubscribeIdx" type="UDINT"/>
						</vars>
						      <iecDeclaration active="FALSE"/>
					</struct>
					    <struct name="MQTTEngineStatus" version="1.0.0">
						      <vars>
							      <var name="configured" type="BOOL"/>
							      <var name="network_ok" type="BOOL"/>
							      <var name="numConfiguredEndpoints" type="UDINT"/>
							      <var name="numRunningEndpoints" type="UDINT"/>
							      <var name="ErrorCode" type="DINT"/>
						</vars>
						      <iecDeclaration active="FALSE"/>
					</struct>
				</structs>
				    <typedefs/>
				    <enums>
					    <enum name="MQTT_DataType" version="1.0.0">
						      <elements>
							      <element name="MQTTDT_BOOL">
								        <value>0</value>
							</element>
							      <element name="MQTTDT_SINT">
								        <value>1</value>
							</element>
							      <element name="MQTTDT_USINT">
								        <value>2</value>
							</element>
							      <element name="MQTTDT_INT">
								        <value>3</value>
							</element>
							      <element name="MQTTDT_UINT">
								        <value>4</value>
							</element>
							      <element name="MQTTDT_DINT">
								        <value>5</value>
							</element>
							      <element name="MQTTDT_UDINT">
								        <value>6</value>
							</element>
							      <element name="MQTTDT_LINT">
								        <value>7</value>
							</element>
							      <element name="MQTTDT_ULINT">
								        <value>8</value>
							</element>
							      <element name="MQTTDT_REAL">
								        <value>9</value>
							</element>
							      <element name="MQTTDT_LREAL">
								        <value>10</value>
							</element>
							      <element name="MQTTDT_STRING">
								        <value>11</value>
							</element>
							      <element name="MQTTDT_RAW">
								        <value>12</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
					    <enum name="MQTT_Error" version="1.0.0">
						      <title>MQTT error codes</title>
						      <elements>
							      <element name="MQTTE_Ok">
								        <descr>No error</descr>
								        <value>0</value>
							</element>
							      <element name="MQTTE_ConnectionError">
								        <descr>Connection Error</descr>
								        <value>1</value>
							</element>
							      <element name="MQTTE_InvalidPar">
								        <descr>Invalid Par</descr>
								        <value>2</value>
							</element>
							      <element name="MQTTE_ConnectionClosed">
								        <descr>Connection Closed</descr>
								        <value>3</value>
							</element>
							      <element name="MQTTE_ConnectionOpening">
								        <descr>Connection Opening</descr>
								        <value>4</value>
							</element>
							      <element name="MQTTE_ConnectionClosing">
								        <descr>Connection Closing</descr>
								        <value>5</value>
							</element>
							      <element name="MQTTE_PingResourcesBusy">
								        <descr>Ping Resources Busy</descr>
								        <value>6</value>
							</element>
							      <element name="MQTTE_PublishResourcesBusy">
								        <descr>Publish Resources Busy</descr>
								        <value>7</value>
							</element>
							      <element name="MQTTE_SubscribeResourcesBusy">
								        <descr>Subscribe Resources Busy</descr>
								        <value>8</value>
							</element>
							      <element name="MQTTE_InvalidTopic">
								        <descr>Invalid Topic</descr>
								        <value>9</value>
							</element>
							      <element name="MQTTE_TlsError">
								        <descr>TLS Error</descr>
								        <value>10</value>
							</element>
						</elements>
						      <iecDeclaration active="FALSE"/>
					</enum>
				</enums>
				    <subranges/>
				    <interfaces/>
			</lib>  <lib fullXml="false" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../Libraries/FileSystem.pll"><![CDATA[	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	FS_OpenMode: ( { DE:"File open mode" }
		FM_RT, { DE:"Read text file" }
		FM_WT, { DE:"Write new text file" }
		FM_AT, { DE:"Append to an existing text file" }
		FM_RB, { DE:"Read binary file" }
		FM_WB, { DE:"Write binary file" }
		FM_AB, { DE:"Append binary file" }
		FM_RUT, { DE:"Read/update text file" }
		FM_WUT, { DE:"Write/update new text file" }
		FM_AUT, { DE:"Append/update to an existing text file" }
		FM_RUB, { DE:"Read/update binary file" }
		FM_WUB, { DE:"Write/update binary file" }
		FM_AUB { DE:"Append/update binary file" }
	);

	FS_SeekMode: ( { DE:"File seek mode" }
		SEEK_SET, { DE:"Move cursor to the initial position of the stream" }
		SEEK_CUR, { DE:"Current position of the cursor" }
		SEEK_END  { DE:"Move cursor to the end of the stream" }
	);

END_TYPE


	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	FS_FILE_HANDLE : DINT; 
	FS_FIND_HANDLE : PVOID; 
END_TYPE


	(*********************)
	(*                   *)
	(*     FUNCTIONS     *)
	(*                   *)
	(*********************)

FUNCTION FS_FileExists : BOOL
{ DE:"Check if the specified file exists or not
	The function returns a BOOL with the following meanings
	TRUE = Specified file exists.
	FALSE =	Specified file does not exists or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"File name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_DeleteFile : BOOL
{ DE:"Delete a file.
	The function returns a BOOL with the following meaning:
	TRUE = File deleted.
	FALSE =	Cannot delete file or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"File name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_OpenFile : FS_FILE_HANDLE
{ DE:"Open a file in the specified mode.
	The function returns an UDINT with the following meaning:
	0 = No file found or Invalid calling task
	Otherwise = handle of the file.
" }
        
	VAR_INPUT
		name	: STRING;		{ DE:"File name" }
		mode	: FS_OpenMode;	{ DE:"File open mode" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_OpenFileSync : FS_FILE_HANDLE
{ DE:"Open a file with SYNC mode on (every write ends with sync)
	The function returns an UDINT with the following meaning:
	0 = No file found.
	-1 = Invalid calling task
	Otherwise = handle of the file.
" }
        
	VAR_INPUT
		name	: STRING;		{ DE:"File name" }
		mode	: FS_OpenMode;	{ DE:"File open mode" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CloseFile : BOOL
{ DE:"Close the specified file.
	The function returns a BOOL with the following meaning:
	TRUE = File closed.
	FALSE = An error occurred or invalid calling task
" }
        
	VAR_INPUT
		handle	: FS_FILE_HANDLE;	{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_SeekFile : BOOL
{ DE:"Seek a position into the file.
	TRUE = Cursor position set.
	FALSE = An error occurred or invalid calling task
" }
        
	VAR_INPUT
		handle	: FS_FILE_HANDLE;	{ DE:"Handle of the file" }
		seekmode : FS_SeekMode;	{ DE:"Seek position" }
		offset	: DINT;		{ DE:"Offset from specified position" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_WriteFile : UDINT
{ DE:"Write binary data to the specified file.
The function returns the number of bytes written, or
	0 = Error writing
	-1 = Invalid calling task
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		data : PVOID;		{ DE:"Buffer to write" }
		len : UDINT;		{ DE:"Data length" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_ReadFile : UDINT
{ DE:"Read binary data from the specified file.
The function returns the number of bytes read, or
	0 = Error reading
	-1 = Invalid calling task
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		data : PVOID;		{ DE:"Buffer for data read" }
		len : UDINT;		{ DE:"Data length" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_WriteString : BOOL
{ DE:"Write a STRING to the specified file. Returns FALSE if error or invalid calling task" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		str : STRING;		{ DE:"String to write" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_ReadString : BOOL
{ DE:"Read a STRING from the specified file. Returns FALSE if error or invalid calling task" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
		str : STRING;		{ DE:"String for data read" }
		len : UDINT;		{ DE:"Data length" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FileEOF : BOOL
{ DE:"Test if end of file is reached.
The function returns a BOOL with the following meaning:
	TRUE	=	End of file reached.
	FALSE	=	End of file not reached yet.
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FileTell : DINT
{ DE:"Returns the actual position of the file:
	-1 in case of error.
" }

	VAR_INPUT
		handle : FS_FILE_HANDLE;		{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION


FUNCTION FS_FindFirstFile : FS_FIND_HANDLE
{ DE:"Searches for files on the disk, starting on path and using the specified filter with wildcard.
Returns an handle that can be passed to FS_Find* functions, or 0 if no files found; returns -1 for invalid calling task" }
	VAR_INPUT
		path: STRING;  {DE:"Starting path for seaching"}
		filter: STRING;  {DE:"Filter with wildcards"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FindNextFile : BOOL
{ DE:"Searches the next matching file. Returns FALSE if no more files are found or invalid calling task" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_FindClose : BOOL
{ DE:"Close a search handle" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_GetFileName : STRING
{ DE:"Returns the name of a matching file of a search" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_GetFileSize : UDINT
{ DE:"Returns the size of a matching file of a search" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_IsDirectory : BOOL
{ DE:"Returns if matching file is a directory" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_IsWritable : BOOL
{ DE:"Returns if matching file is writable" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Find_GetFileTime : BOOL
{ DE:"Returns the date and time of a matching file of a search" }
	VAR_INPUT
		handle: FS_FIND_HANDLE;  {DE:"Handle returned by FS_FindFirstFile"}
		day: @USINT; {DE:"day (1..31)"}
		month: @USINT; {DE:"month (1..12)"}
		year: @UINT; {DE:"year (e.g. 2022)"}
		dayOfWeek: @UINT; {DE:"day of week (0..6, 0=sunday)"}
		hours: @USINT; {DE:"hours (0..23)"}
		minutes: @USINT; {DE:"minutes (0..59)"}
		seconds: @USINT; {DE:"seconds (0..59)"}
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CopyFile : BOOL
{ DE:"Copy a file" }
	VAR_INPUT
		src: STRING; { DE:"Source file name to be copied" }
		dest: STRING; { DE:"Destination file name" }
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CopyFileSync : BOOL
{ DE:"Copy a file with SYNC mode on (every segment write ends with sync)" }
	VAR_INPUT
		src: STRING; { DE:"Source file name to be copied" }
		dest: STRING; { DE:"Destination file name" }
	END_VAR
	
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_MoveFile : BOOL
{ DE:"Move or rename a file" }
	VAR_INPUT
		src: STRING; { DE:"Source file name to be moved or renamed" }
		dest: STRING; { DE:"Destination file name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_DirExists : BOOL
{ DE:"Check if the specified directory exists or not
	The function returns a BOOL with the following meanings
	TRUE = Specified directory exists.
	FALSE =	Specified directory does not exists or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"Directory name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_CreateDir : BOOL
{ DE:"Create specified directory if not exists
	The function returns a BOOL with the following meanings
	TRUE = Specified directory created.
	FALSE =	Cannot create directory or directory already exists or invalid calling task.
" }
        
	VAR_INPUT
		name	: STRING;	{ DE:"Directory name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Flush : BOOL
{ DE:"Force writing on specified handle.
	The function returns a BOOL with the following meaning:
	TRUE = flush ok
	FALSE = An error occurred or invalid calling task
" }
        
	VAR_INPUT
		handle	: FS_FILE_HANDLE;	{ DE:"Handle of the file" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

FUNCTION FS_Sync : BOOL
{ DE:"Sync all modifies on external drivers (only POSIX compatible targets)" }
	VAR_INPUT
		dmy: BOOL; { DE:"Dummy value" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION


FUNCTION FS_GetFreeSpace : DINT
{ DE:"Returns the free space in Kbytes of the volume path specified:
	-1 in case of error.
" }
	VAR_INPUT
		path	: STRING;	{ DE:"Path name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION


FUNCTION FS_Unmount : BOOL
{ DE:"Unmount the mount point specified" }
	VAR_INPUT
		mountpoint	: STRING;	{ DE:"Mountpoint name" }
	END_VAR

    {CODE:EMBEDDED}
END_FUNCTION

	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE
	FS_ERROR: (
		FS_NOT_IMPL_OR_NOT_SUPP		:= -100, {DE: "Not implemented or not supported"}
		FS_REALTIME_NOT_ALLOWED		:= -1,	{DE: "Realtime task not allowed"}
		FS_NOT_MOUNTED				:= -2,	{DE: "Mountpoint not mounted"}
		FS_NOERR					:= 0,	{DE: "No error" }
		EPERM 						:= 1,	{DE: "Operation not permitted" }
		ENOENT 						:= 2,	{DE: "No such file or directory" }
		ESRCH 						:= 3,	{DE: "No such process" }
		EINTR 						:= 4,	{DE: "Interrupted system call" }
		EIO 						:= 5,	{DE: "Input/output error" }
		ENXIO 						:= 6,	{DE: "No such device or address" }
		E2BIG 						:= 7,	{DE: "Argument list too long" }
		ENOEXEC 					:= 8,	{DE: "Exec format error" }
		EBADF 						:= 9,	{DE: "Bad file descriptor" }
		ECHILD 						:= 10, 	{DE: "No child processes" }
		EAGAIN 						:= 11,  {DE: "Resource temporarily unavailable" }
		ENOMEM						:= 12,  {DE: "Cannot allocate memory" }
		EACCES 						:= 13,  {DE: "Permission denied" }
		EFAULT 						:= 14,  {DE: "Bad address" }
		ENOTBLK 					:= 15,  {DE: "Block device required" }
		EBUSY						:= 16,  {DE: "Device or resource busy" }
		EEXIST						:= 17,  {DE: "File exists" }
		EXDEV 						:= 18,  {DE: "Invalid cross-device link" }
		ENODEV 						:= 19,  {DE: "No such device" }
		ENOTDIR 					:= 20,  {DE: "Not a directory" }
		EISDIR 						:= 21,  {DE: "Is a directory" }
		EINVAL 						:= 22,  {DE: "Invalid argument" }
		ENFILE 						:= 23,  {DE: "Too many open files in system" }
		EMFILE 						:= 24,  {DE: "Too many open files" }
		ENOTTY 						:= 25,  {DE: "Inappropriate ioctl for device" }
		ETXTBSY 					:= 26,  {DE: "Text file busy" }
		EFBIG 						:= 27,  {DE: "File too large" }
		ENOSPC 						:= 28,  {DE: "No space left on device" }
		ESPIPE 						:= 29,  {DE: "Illegal seek" }
		EROFS 						:= 30,  {DE: "Read-only file system" }
		EMLINK 						:= 31,  {DE: "Too many links" }
		EPIPE 						:= 32,  {DE: "Broken pipe" }
		EDOM 						:= 33,  {DE: "Numerical argument out of domain" }
		ERANGE 						:= 34,  {DE: "Numerical result out of range" }
		EDEADLK 					:= 35,  {DE: "Resource deadlock avoided" }
		ENAMETOOLONG 				:= 36,  {DE: "File name too long" }
		ENOLCK 						:= 37,  {DE: "No locks available" }
		ENOSYS 						:= 38,  {DE: "Function not implemented" }
		ENOTEMPTY 					:= 39,  {DE: "Directory not empty" }
		ELOOP 						:= 40,  {DE: "Too many levels of symbolic links" }
		ENOMSG 						:= 42,  {DE: "No message of desired type" }
		EIDRM 						:= 43,  {DE: "Identifier removed" }
		ECHRNG 						:= 44,  {DE: "Channel number out of range" }
		EL2NSYNC 					:= 45,  {DE: "Level 2 not synchronized" }
		EL3HLT 						:= 46,  {DE: "Level 3 halted" }
		EL3RST 						:= 47,  {DE: "Level 3 reset" }
		ELNRNG 						:= 48,  {DE: "Link number out of range" }
		EUNATCH 					:= 49,  {DE: "Protocol driver not attached" }
		ENOCSI 						:= 50,  {DE: "No CSI structure available" }
		EL2HLT 						:= 51,  {DE: "Level 2 halted" }
		EBADE 						:= 52,  {DE: "Invalid exchange" }
		EBADR 						:= 53,  {DE: "Invalid request descriptor" }
		EXFULL 						:= 54,  {DE: "Exchange full" }
		ENOANO 						:= 55,  {DE: "No anode" }
		EBADRQC 					:= 56,  {DE: "Invalid request code" }
		EBADSLT 					:= 57,  {DE: "Invalid slot" }
		EBFONT 						:= 59,  {DE: "Bad font file format" }
		ENOSTR 						:= 60,  {DE: "Device not a stream" }
		ENODATA 					:= 61,  {DE: "No data available" }
		ETIME 						:= 62,  {DE: "Timer expired" }
		ENOSR 						:= 63,  {DE: "Out of streams resources" }
		ENONET 						:= 64,  {DE: "Machine is not on the network" }
		ENOPKG 						:= 65,  {DE: "Package not installed" }
		EREMOTE 					:= 66,  {DE: "Object is remote" }
		ENOLINK 					:= 67,  {DE: "Link has been severed" }
		EADV 						:= 68,  {DE: "Advertise error" }
		ESRMNT 						:= 69,  {DE: "Srmount error" }
		ECOMM 						:= 70,  {DE: "Communication error on send" }
		EPROTO 						:= 71,  {DE: "Protocol error" }
		EMULTIHOP 					:= 72,  {DE: "Multihop attempted" }
		EDOTDOT 					:= 73,  {DE: "RFS specific error" }
		EBADMSG 					:= 74,  {DE: "Bad message" }
		EOVERFLOW 					:= 75,  {DE: "Value too large for defined data type" }
		ENOTUNIQ 					:= 76,  {DE: "Name not unique on network" }
		EBADFD 						:= 77,  {DE: "File descriptor in bad state" }
		EREMCHG 					:= 78,  {DE: "Remote address changed" }
		ELIBACC 					:= 79,  {DE: "Can not access a needed shared library" }
		ELIBBAD 					:= 80,  {DE: "Accessing a corrupted shared library" }
		ELIBSCN 					:= 81,  {DE: ".lib section in a.out corrupted" }
		ELIBMAX 					:= 82,  {DE: "Attempting to link in too many shared libraries" }
		ELIBEXEC 					:= 83,  {DE: "Cannot exec a shared library directly" }
		EILSEQ 						:= 84,  {DE: "Invalid or incomplete multibyte or wide character" }
		ERESTART 					:= 85,  {DE: "Interrupted system call should be restarted" }
		ESTRPIPE 					:= 86,  {DE: "Streams pipe error" }
		EUSERS 						:= 87,	{DE: "Too many users" }
		ENOTSOCK 					:= 88, 	{DE: "Socket operation on non-socket" }
		EDESTADDRREQ 				:= 89, 	{DE: "Destination address required" }
		EMSGSIZE 					:= 90, 	{DE: "Message too long" }
		EPROTOTYPE 					:= 91, 	{DE: "Protocol wrong type for socket" }
		ENOPROTOOPT 				:= 92, 	{DE: "Protocol not available" }
		EPROTONOSUPPORT 			:= 93, 	{DE: "Protocol not supported" }
		ESOCKTNOSUPPORT 			:= 94, 	{DE: "Socket type not supported" }
		EOPNOTSUPP 					:= 95, 	{DE: "Operation not supported" }
		EPFNOSUPPORT 				:= 96, 	{DE: "Protocol family not supported" }
		EAFNOSUPPORT 				:= 97, 	{DE: "Address family not supported by protocol" }
		EADDRINUSE 					:= 98, 	{DE: "Address already in use" }
		EADDRNOTAVAIL 				:= 99, 	{DE: "Cannot assign requested address" }
		ENETDOWN 					:= 100,	{DE: "Network is down" }
		ENETUNREACH 				:= 101,	{DE: "Network is unreachable" }
		ENETRESET 					:= 102,	{DE: "Network dropped connection on reset" }
		ECONNABORTED 				:= 103,	{DE: "Software caused connection abort" }
		ECONNRESET 					:= 104,	{DE: "Connection reset by peer" }
		ENOBUFS 					:= 105,	{DE: "No buffer space available" }
		EISCONN 					:= 106,	{DE: "Transport endpoint is already connected" }
		ENOTCONN 					:= 107,	{DE: "Transport endpoint is not connected" }
		ESHUTDOWN 					:= 108, {DE: "Cannot send after transport endpoint shutdown" }
		ETOOMANYREFS 				:= 109, {DE: "Too many references: cannot splice" }
		ETIMEDOUT 					:= 110, {DE: "Connection timed out" }
		ECONNREFUSED 				:= 111, {DE: "Connection refused" }
		EHOSTDOWN 					:= 112, {DE: "Host is down" }
		EHOSTUNREACH 				:= 113, {DE: "No route to host" }
		EALREADY 					:= 114, {DE: "Operation already in progress" }
		EINPROGRESS 				:= 115, {DE: "Operation now in progress" }
		ESTALE 						:= 116, {DE: "Stale file handle" }
		EUCLEAN 					:= 117, {DE: "Structure needs cleaning" }
		ENOTNAM 					:= 118, {DE: "Not a XENIX named type file" }
		ENAVAIL						:= 119, {DE: "No XENIX semaphores available" }
		EISNAM 						:= 120, {DE: "Is a named type file" }
		EREMOTEIO 					:= 121, {DE: "Remote I/O error" }
		EDQUOT 						:= 122, {DE: "Disk quota exceeded" }
		ENOMEDIUM 					:= 123, {DE: "No medium found" }
		EMEDIUMTYPE 				:= 124, {DE: "Wrong medium type" }
		ECANCELED 					:= 125, {DE: "Operation canceled" }
		ENOKEY 						:= 126, {DE: "Required key not available" }
		EKEYEXPIRED 				:= 127, {DE: "Key has expired" }
		EKEYREVOKED 				:= 128, {DE: "Key has been revoked" }
		EKEYREJECTED 				:= 129, {DE: "Key was rejected by service" }
		EOWNERDEAD 					:= 130, {DE: "Owner died" }
		ENOTRECOVERABLE 			:= 131, {DE: "State not recoverable" }
		ERFKILL 					:= 132, {DE: "Operation not possible due to RF-kill" }
		EHWPOISON 					:= 133 {DE: "Memory page has hardware error" }
	);
END_TYPE


VAR_GLOBAL
	{G:"Diagnostics"}
	FS_LastError AT %MD60311.0 : FS_ERROR;
END_VAR
]]></lib>
      <lib fullXml="true" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../Libraries/PLCConnect.plclib" version="1.0.2">
		      <descr/>
		      <libWorkspace>
			      <folder descr="" genCryptedChildren="false" id="15" libGeneration="true" name="PLCConnect" password="" version="1.0.0">
				        <Definition name="PLCCONNECTMASTERSTATUS"/>
				        <Definition name="PLCCONNECTENDPOINTSTATUS"/>
				        <GlobalVars name="PLCConnectVariables"/>
				        <Definition name="PLCCONNECTERROR"/>
			</folder>
		</libWorkspace>
		      <globalVars>
			      <group name="PLCConnectVariables">
				        <var name="sysPLCConnectMasterStatus" type="PLCCONNECTMASTERSTATUS">
					        <address index="60096" subIndex="0" type="M" typeVar="B"/>
				</var>
				        <var dim0="100" name="sysPLCConnectEndpointsStatus" type="PLCCONNECTENDPOINTSTATUS">
					        <address index="60097" subIndex="0" type="M" typeVar="B"/>
				</var>
			</group>
		</globalVars>
		      <retainVars>
			      <group name="PLCConnectVariables"/>
		</retainVars>
		      <constantVars>
			      <group name="PLCConnectVariables"/>
		</constantVars>
		      <iecVarsDeclaration>
			      <group name="PLCConnectVariables">
				        <iecDeclaration active="FALSE"/>
			</group>
		</iecVarsDeclaration>
		      <functions/>
		      <functionBlocks/>
		      <programs/>
		      <macros/>
		      <structs>
			      <struct name="PLCCONNECTENDPOINTSTATUS" version="1.0.0">
				        <vars>
					        <var name="configured" type="BOOL">
						          <descr>The endpoint have been correctly configured</descr>
					</var>
					        <var name="_spare0" type="BOOL">
						          <descr>Spare field</descr>
					</var>
					        <var name="_spare1" type="BOOL">
						          <descr>Spare field</descr>
					</var>
					        <var name="_spare2" type="BOOL">
						          <descr>Spare field</descr>
					</var>
					        <var name="numInputVars" type="UINT">
						          <descr>Number of input variables</descr>
					</var>
					        <var name="numOutputVars" type="UINT">
						          <descr>Number of output variables</descr>
					</var>
					        <var name="error" type="PLCCONNECTERROR">
						          <descr>Last error on endpoint</descr>
					</var>
				</vars>
			</struct>
			      <struct name="PLCCONNECTMASTERSTATUS" version="1.0.0">
				        <vars>
					        <var name="configured" type="BOOL">
						          <descr>The master have been correctly configured</descr>
					</var>
					        <var name="network_ok" type="BOOL">
						          <descr>The master is running and all the endpoints are online</descr>
					</var>
					        <var name="numConfiguredEndpoints" type="UINT">
						          <descr>Number of configured endpoints</descr>
					</var>
					        <var name="numRunningEndpoints" type="UINT">
						          <descr>Number of running endpoints</descr>
					</var>
					        <var name="_spare" type="UINT">
						          <descr>Spare Field</descr>
					</var>
					        <var name="error" type="PLCCONNECTERROR">
						          <descr>Last error</descr>
					</var>
				</vars>
			</struct>
		</structs>
		      <typedefs/>
		      <enums>
			      <enum name="PLCCONNECTERROR" version="1.0.0">
				        <elements>
					        <element name="sr_DATA_EXCHANGE_GENERIC">
						          <descr>Data exchange generic error</descr>
						          <value>-743</value>
					</element>
					        <element name="sr_OUTPUT_ACCESS_MISMATCH">
						          <descr>Wrong remote output tag access rights</descr>
						          <value>-742</value>
					</element>
					        <element name="sr_NO_OUTPUT_TAGACCESS">
						          <descr>Failure retrieving remote output tag access rights</descr>
						          <value>-741</value>
					</element>
					        <element name="sr_OUTPUT_SIZE_MISMATCH">
						          <descr>Wrong remote output tag size</descr>
						          <value>-740</value>
					</element>
					        <element name="sr_NO_OUTPUT_TAGSIZE">
						          <descr>Failure retrieving remote output tag size</descr>
						          <value>-739</value>
					</element>
					        <element name="sr_OUTPUT_TYPE_MISMATCH">
						          <descr>Wrong remote output tag type</descr>
						          <value>-738</value>
					</element>
					        <element name="sr_NO_OUTPUT_TAGTYPE">
						          <descr>Failure retrieving remote output tag type</descr>
						          <value>-737</value>
					</element>
					        <element name="sr_NO_OUTPUT_TAG">
						          <descr>Failure retrieving remote output tag</descr>
						          <value>-736</value>
					</element>
					        <element name="sr_INPUT_SIZE_MISMATCH">
						          <descr>Wrong remote input tag size</descr>
						          <value>-735</value>
					</element>
					        <element name="sr_NO_INPUT_TAGSIZE">
						          <descr>Failure retrieving remote input tag size</descr>
						          <value>-734</value>
					</element>
					        <element name="sr_INPUT_TYPE_MISMATCH">
						          <descr>Wrong remote input tag type</descr>
						          <value>-733</value>
					</element>
					        <element name="sr_NO_INPUT_TAGTYPE">
						          <descr>Failure retrieving remote input tag type</descr>
						          <value>-732</value>
					</element>
					        <element name="sr_NO_INPUT_TAG">
						          <descr>Failure retrieving remote input tag</descr>
						          <value>-731</value>
					</element>
					        <element name="sr_NO_CONNECTION">
						          <descr>No connection with endpoint</descr>
						          <value>-730</value>
					</element>
					        <element name="sr_CFG_WRONG_ENDPOINT">
						          <descr>Endpoint not present in main config file</descr>
						          <value>-719</value>
					</element>
					        <element name="sr_CFG_NO_SYMSIZE">
						          <descr>Missing size for local variable</descr>
						          <value>-718</value>
					</element>
					        <element name="sr_CFG_NO_SYMTYPE">
						          <descr>Missing type for local variable</descr>
						          <value>-717</value>
					</element>
					        <element name="sr_CFG_NO_SYMADDRESS">
						          <descr>Missing address for local variable</descr>
						          <value>-716</value>
					</element>
					        <element name="sr_CFG_NO_SYMLOCAL">
						          <descr>Missing symbol in local symbol table</descr>
						          <value>-715</value>
					</element>
					        <element name="sr_CFG_NO_LOCAL">
						          <descr>Missed an endpoint local variable</descr>
						          <value>-714</value>
					</element>
					        <element name="sr_CFG_NO_REMOTE">
						          <descr>Missed an endpoint remote variable</descr>
						          <value>-713</value>
					</element>
					        <element name="sr_CFG_NO_PLC_AREA">
						          <descr>Missed endpoint plc area</descr>
						          <value>-712</value>
					</element>
					        <element name="sr_CFG_WRONG_PARAMS">
						          <descr>Wrong endpoint protocol parameters</descr>
						          <value>-711</value>
					</element>
					        <element name="sr_CFG_NO_PARAMS">
						          <descr>Missed endpoint protocol parameters</descr>
						          <value>-710</value>
					</element>
					        <element name="sr_CFG_WRONG_PROTO">
						          <descr>Wrong endpoint protocol</descr>
						          <value>-709</value>
					</element>
					        <element name="sr_CFG_NO_PROTO">
						          <descr>Missed endpoint protocol</descr>
						          <value>-708</value>
					</element>
					        <element name="sr_CFG_NO_NAME">
						          <descr>Missed endpoint name</descr>
						          <value>-707</value>
					</element>
					        <element name="sr_CFG_GET_SYM_API">
						          <descr>Fail to load LLSymbols direct access API</descr>
						          <value>-706</value>
					</element>
					        <element name="sr_CFG_ALLOC">
						          <descr>Configuration alloc</descr>
						          <value>-705</value>
					</element>
					        <element name="sr_CFG_VERSION">
						          <descr>Configuration version mismatch</descr>
						          <value>-704</value>
					</element>
					        <element name="sr_CFG_EMPTY">
						          <descr>Empty configuration</descr>
						          <value>-703</value>
					</element>
					        <element name="sr_CFG_FILE">
						          <descr>File I/O Error</descr>
						          <value>-702</value>
					</element>
					        <element name="sr_OUT_OF_MEMORY">
						          <descr>Out of memory</descr>
						          <value>-701</value>
					</element>
					        <element name="sr_OK">
						          <descr>No error</descr>
						          <value>0</value>
					</element>
				</elements>
			</enum>
		</enums>
		      <subranges/>
		      <interfaces/>
	</lib>    <lib fullXml="false" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../Libraries/Serial.pll"><![CDATA[	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	SERIAL_HANDLE : DINT; 
END_TYPE

	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	SERIAL_OPT: ( { DE:"COM option that can be set using Serial_SetOption, Serial_GetOption or Serial_ConfigPort functions" }
		SERIAL_OPT_PORT				:=1,	{ DE:"COM port number" }
		SERIAL_OPT_BAUDRATE			:=2,	{ DE:"Baudrate (supported values: 115200, 57600, 38400, 19200, 9600, 4800, 2400)" }
		SERIAL_OPT_PARITY			:=3,	{ DE:"Parity (0 = NO Parity, 1 = ODD parity, 2 = EVEN parity, 3 = MARK parity, 4 = SPACE parity)" }
		SERIAL_OPT_BYTESIZE			:=4,	{ DE:"Bytesize (7, 8)" }
		SERIAL_OPT_STOPBITS			:=5,	{ DE:"Stopbits (0 = 1 stopbit, 1 = 1.5 stopbits, 2 = 2 stopbits)" }
		SERIAL_OPT_RX_TIMEOUT		:=6,	{ DE:"Rx timeout (Default 1000)" }
		SERIAL_OPT_XONXOFF_ENA		:=7,	{ DE:"XON/XOFF software flow control enabled (TRUE/FALSE. Default FALSE)" }
		SERIAL_OPT_RTSCTS_ENA		:=8,		{ DE:"RTS/CTS hardware flow control enabled (TRUE/FALSE. Default FALSE)" }
		SERIAL_OPT_USBSERIAL		:=11	{ DE:"USB-SERIAL setting (0 = not enabled, 1 = Standard class, 2 = Communication class )" }
	);

END_TYPE

TYPE

	SERIAL_RET: ( { DE:"COM return value definitions." }
		SERIAL_OK							:=0,	{ DE:"OK" }
		SERIAL_ERR_NOT_OPENED				:=-1,	{ DE:"ERR Port is not opened" }
		SERIAL_ERR_NOT_CONFIGURED			:=-2,	{ DE:"ERR Port is not configured" }
		SERIAL_ERR_ALREADY_OPENED			:=-3,	{ DE:"ERR Port is already opened" }
		SERIAL_ERR_ALREADY_CONFIGURED		:=-4,	{ DE:"ERR Port is already configured" }
		SERIAL_ERR_INVALID_VALUE			:=-5,	{ DE:"ERR Invalid value specified" }
		SERIAL_ERR_INVALID_OPTION			:=-6,	{ DE:"ERR Invalid option specified" }
		SERIAL_ERR_MAX_PORT_OPENED			:=-7,	{ DE:"ERR Max number of port opened" }
		SERIAL_ERR_CANNOT_OPEN				:=-8,	{ DE:"ERR Cannot open port" }
		SERIAL_ERR_CANNOT_CLOSE				:=-9,	{ DE:"ERR Cannot close port" }
		SERIAL_ERR_READ						:=-10,	{ DE:"ERR Read" }
		SERIAL_ERR_READ_TIMEOUT				:=-11,	{ DE:"ERR Read timeout" }
		SERIAL_ERR_NOT_SUPPORTED_OPTION		:=-12,	{ DE:"ERR Option is not supported for the current architecture" }
		SERIAL_ERR_INVALID_VALUE_BAUDRATE	:=-13,	{ DE:"ERR invalid baudrate value specified" }
		SERIAL_ERR_INVALID_VALUE_PARITY 	:=-14,	{ DE:"ERR invalid parity value specified" }
		SERIAL_ERR_INVALID_VALUE_BYTESIZE	:=-15,	{ DE:"ERR invalid bytesize value specified" }
		SERIAL_ERR_INVALID_VALUE_STOPBITS	:=-16,	{ DE:"ERR invalid stopbits value specified" }
		SERIAL_ERR_NOT_ALLOWED_IN_IOTASK	:=-17,	{ DE:"ERR operation not allowed in high priority task" }
		SERIAL_ERR_BUFFER					:=-18	{ DE:"ERR buffer is too small" }
	);

END_TYPE

TYPE

	SERIAL_BAUDRATE: ( { DE:"Available baudrate" }
		SERIAL_BAUDRATE_2400	:=2400,		{ DE:"Baudrate 2400" }
		SERIAL_BAUDRATE_4800	:=4800,		{ DE:"Baudrate 4800" }
		SERIAL_BAUDRATE_9600	:=9600,		{ DE:"Baudrate 9600" }
		SERIAL_BAUDRATE_19200	:=19200,	{ DE:"Baudrate 19200" }
		SERIAL_BAUDRATE_38400	:=38400,	{ DE:"Baudrate 38400" }
		SERIAL_BAUDRATE_57600	:=57600,	{ DE:"Baudrate 57600" }
		SERIAL_BAUDRATE_115200	:=115200	{ DE:"Baudrate 115200" }
	);

END_TYPE

TYPE

	SERIAL_PARITY: ( { DE:"Available parity settings" }
		SERIAL_NOPARITY		:=0,	{ DE:"Parity NONE" }
		SERIAL_ODDPARITY	:=1,	{ DE:"Parity ODD" }
		SERIAL_EVENPARITY	:=2,	{ DE:"Parity EVEN" }
		SERIAL_MARKPARITY	:=3,	{ DE:"Parity MARK" }
		SERIAL_SPACEPARITY	:=4		{ DE:"Parity SPACE" }
	);

END_TYPE

TYPE

	SERIAL_BYTESIZE: ( { DE:"Available bytesize settings" }
		SERIAL_BYTESIZE_7	:=7,	{ DE:"Bytesize 7" }
		SERIAL_BYTESIZE_8	:=8		{ DE:"Bytesize 8" }
	);

END_TYPE

TYPE

	SERIAL_STOPBITS: ( { DE:"Available stopbits settings" }
		SERIAL_ONESTOPBIT	:=0,	{ DE:"One stopbit" }
		SERIAL_TWOSTOPBITS	:=2		{ DE:"Two stopbits" }
	);

END_TYPE

TYPE

	SERIAL_USBSERIAL_CLASS: ( { DE:"Available usb-serial classes" }
		SERIAL_USBSERIAL_CLASS_STANDARD			:=1,		{ DE:"Standard class" }
		SERIAL_USBSERIAL_CLASS_COMMUNICATION	:=2		{ DE:"Communication class" }
		
	);

END_TYPE

	(************************)
	(*                   	*)
	(*     FUNCTIONS        *)
	(*                   	*)
	(************************)
	
FUNCTION Serial_ConfigPort : SERIAL_HANDLE
	
	{ DE:"Configure port settings.
If port has been configured (or opened) value returned is a SERIAL_HANDLE >= 0, otherwise is a SERIAL_RET error code." }
	
	VAR_INPUT
	port : USINT; { DE:"The number of the port (eg: 2 for COM2)" }
	baudrate : SERIAL_BAUDRATE; { DE:"One of the SERIAL_BAUDRATE supported values" }
	parity : SERIAL_PARITY; { DE:"One of the SERIAL_PARITY supported values" }
	bytesize : SERIAL_BYTESIZE; { DE:"One of the SERIAL_BYTESIZE supported values" }
	stopbits : SERIAL_STOPBITS; { DE:"One of the SERIAL_STOPBITS supported values" }
	open : BOOL; { DE:"If TRUE open the COM port with the values passed as parameters and the other default options." }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_ConfigPortByName : SERIAL_HANDLE
	
	{ DE:"Configure port settings.
If port has been configured (or opened) value returned is a SERIAL_HANDLE >= 0, otherwise is a SERIAL_RET error code." }
	
	VAR_INPUT
	port_dev : STRING[64]; { DE:"The name of the port device (eg: /dev/ttyUSB0)" }
	baudrate : SERIAL_BAUDRATE; { DE:"One of the SERIAL_BAUDRATE supported values" }
	parity : SERIAL_PARITY; { DE:"One of the SERIAL_PARITY supported values" }
	bytesize : SERIAL_BYTESIZE; { DE:"One of the SERIAL_BYTESIZE supported values" }
	stopbits : SERIAL_STOPBITS; { DE:"One of the SERIAL_STOPBITS supported values" }
	open : BOOL; { DE:"If TRUE open the COM port with the values passed as parameters and the other default options." }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_SetOption : SERIAL_RET
	
	{ DE:"Change setting for the specified option.
SERIAL_OK if the option has been set, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	option : SERIAL_OPT; { DE:"The SERIAL_OPT to set" }
	value : DINT; { DE:"Value depends on the option specified" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetOption : DINT
	
	{ DE:"Get port configuration settings.
Returns a value >= 0 with the value of the option if can be retrieved, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	option : SERIAL_OPT; { DE:"The SERIAL_OPT to get." }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_OpenPort : SERIAL_RET
	
	{ DE:"Open the specified port using the configured settings.
Returns SERIAL_OK if the option has been opened, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_ClosePort : SERIAL_RET
	
	{ DE:"Function to close the specified port.
Returns SERIAL_OK if the port has been closed, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_PutBuff : SERIAL_RET
	
	{ DE:"Send 1 or more BYTE data.
The number of bytes put on the serial otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	buff : @BYTE; { DE:"The address of the TX buffer. Address can be retrieved using ADR operator" }
	len : UINT; { DE:"The number of bytes to send" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetBuff : SERIAL_RET
	
	{ DE:"Receive the specified number of BYTEs.
Returns a value >= 0 indicating the bytes received, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	buff : @BYTE; { DE:"The address of the array of BYTE in which to put the received data. Address can be retrieved using ADR operator" }
	len : UINT; { DE:"The number of BYTEs to receive" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetBuff_tmo : SERIAL_RET
	
	{ DE:"Receive the specified number of BYTEs. It is also possible to specify the timeout.
Returns a value >= 0 indicating the bytes received, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	buff : @BYTE; { DE:"The address of the array of BYTE in which to put the received data. Address can be retrieved using ADR operator" }
	len : UINT; { DE:"The number of BYTEs to receive" }
	tmo : UINT; { DE:"Timeout in ms specified for current function" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION


FUNCTION Serial_PutString : SERIAL_RET
	
	{ DE:"Send a STRING.
Returns the number of characters put on the serial otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	str : STRING; { DE:"The STRING to transmit" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_PutByte : SERIAL_RET
	
	{ DE:"Send a single BYTE value.
Returns 1 if the BYTE can be put on the serial bus, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	val : BYTE; { DE:"The BYTE value to send" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetByte : SERIAL_RET
	
	{ DE:"Receive a single byte. 
Returns 1 if the BYTE has been received, otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	val : @BYTE; { DE:"The address of the BYTE in which to put the received data. Address is retrieved using ADR operator" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

FUNCTION Serial_GetByte_tmo : SERIAL_RET
	
	{ DE:"Receive a single byte specifying the timeout. " }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	val : @BYTE; { DE:"The address of the BYTE in which to put the received data" }
	tmo : UINT; { DE:"Timeout in ms for the current function only" }
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION

	(************************)
	(*                   	*)
	(*     FUNCTIONS BLOCK  *)
	(*                   	*)
	(************************)


FUNCTION_BLOCK Serial_GetString
	
	{ DE:"Receive a STRING.
Returns a value > 0 indicates the number of bytes received (including termination character), otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	str : UDINT; { DE:"The address of a STRING in which to put the received data" }
	len : UINT; { DE:"The max of characters of the string. The size of the string as indicated in the declaration of the STRING variable is the max size that can be indicated." }
	term : UDINT; { DE:"The address of a STRING in which to put the termination character" }
	END_VAR
	
	VAR_OUTPUT
	esi : SERIAL_RET; { DE:"Operation result" } 
	hasTerm : BOOL; { DE:"true if the string has the terminator char " } 
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK Serial_GetString_tmo
	
	{ DE:"Receive a STRING. It is also possible to specify the timeout.
Returns a value > 0 indicates the number of bytes received (including null character), otherwise a SERIAL_RET error code" }
	
	VAR_INPUT
	handle : SERIAL_HANDLE; { DE:"The handle of the port" }
	str : UDINT; { DE:"The address of a STRING in which to put the received data" }
	len : UINT; { DE:"The max of characters of the string. The size of the string as indicated in the declaration of the STRING variable is the max size that can be indicated." }
	term : UDINT; { DE:"The address of a STRING in which to put the termination character" }
	tmo : UINT; { DE:"Timeout in ms specified for current function" }
	END_VAR
	
	VAR_OUTPUT
	esi : SERIAL_RET; { DE:"Operation result" } 
	hasTerm : BOOL; { DE:"true if the string has the terminator char " } 
	END_VAR
	
	{CODE:EMBEDDED}
	
END_FUNCTION_BLOCK

]]></lib>
      <lib fullXml="true" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../Libraries/ModbusRTU.plclib" version="1.0.3">
		      <descr>ModbusRTU library</descr>
		      <libWorkspace>
			      <folder id="161" name="ModbusRTU">
				        <GlobalVars name="Modbus_RTU_Master"/>
				        <folder name="Definitions">
					        <folder name="Structures">
						          <Definition name="MBMNODESTATUS"/>
					</folder>
					        <folder name="Enumerations">
						          <Definition name="MB_RTU_NETWORK_ID"/>
						          <Definition name="MB_DATA_TYPE"/>
						          <Definition name="MB_ESI_VALUE"/>
						          <Definition name="MB_ASYNC_RQ_STATUS"/>
						          <Definition name="MB_COMPORT_SETTING_DATABITS_ENUM"/>
						          <Definition name="MB_COMPORT_SETTING_PARITY_ENUM"/>
						          <Definition name="MB_COMPORT_SETTING_RIS_ENUM"/>
						          <Definition name="MB_COMPORT_SETTING_STOPBITS_ENUM"/>
					</folder>
				</folder>
				        <folder name="Obsolete">
					        <Pou name="ModbusRTU_WriteReg_S"/>
					        <Pou name="ModbusRTU_ReadReg_RW"/>
					        <Pou name="ModbusRTU_ReadReg_RO"/>
					        <Pou name="ModbusRTU_Active"/>
					        <Pou name="ModbusRTU_WriteReg_M"/>
					        <Pou name="ModbusRTUNet_WriteReg_S_Async"/>
					        <Pou name="ModbusRTUNet_WriteReg_M"/>
					        <Pou name="ModbusRTUNet_ReadReg_RW_Async"/>
					        <Pou name="ModbusRTUNet_ReadReg_RO"/>
					        <Pou name="ModbusRTUNet_ReadReg_RW"/>
					        <Pou name="ModbusRTUNet_WriteReg_S"/>
					        <Pou name="ModbusRTUNet_WriteReg_M_Async"/>
					        <Pou name="ModbusRTUNet_ReadReg_RO_Async"/>
				</folder>
				        <folder name="Network commands">
					        <Pou name="ModbusRTUNet_Active"/>
					        <Pou name="ModbusRTUNet_RdHoldRegs"/>
					        <Pou name="ModbusRTUNet_RdInpRegs"/>
					        <Pou name="ModbusRTUNet_WrSingleReg"/>
					        <Pou name="ModbusRTUNet_WrMultiRegs"/>
					        <Pou name="ModbusRTUNet_ReadCoils"/>
					        <Pou name="ModbusRTUNet_ReadDiscrInputs"/>
					        <Pou name="ModbusRTUNet_WriteSingleCoil"/>
					        <Pou name="ModbusRTUNet_WriteMultCoils"/>
					        <Pou name="ModbusRTUNet_RdHoldRegs_Async"/>
					        <Pou name="ModbusRTUNet_RdInpRegs_Async"/>
					        <Pou name="ModbusRTUNet_WrSingleReg_Async"/>
					        <Pou name="ModbusRTUNet_WrMultiRegs_Async"/>
					        <Pou name="ModbusRTUNet_RdCoils_Async"/>
					        <Pou name="ModbusRTUNet_RdDiscrInp_Async"/>
					        <Pou name="ModbusRTUNet_WrSingleCoil_Async"/>
					        <Pou name="ModbusRTUNet_WrMultCoils_Async"/>
				</folder>
				        <folder name="Raw commands">
					        <Pou name="ModbusRTU_ReadHoldingRegs_Async"/>
					        <Pou name="ModbusRTU_WriteSingleCoil"/>
					        <Pou name="ModbusRTU_WriteMultRegs"/>
					        <Pou name="ModbusRTU_ReadDiscrInputs"/>
					        <Pou name="ModbusRTU_ReadCoils_Async"/>
					        <Pou name="ModbusRTU_ReadHoldingRegs"/>
					        <Pou name="ModbusRTU_ReadInputRegs_Async"/>
					        <Pou name="ModbusRTU_WriteSingleReg_Async"/>
					        <Pou name="ModbusRTU_ReadDiscrInputs_Async"/>
					        <Pou name="ModbusRTU_ReadInputRegs"/>
					        <Pou name="ModbusRTU_ReadCoils"/>
					        <Pou name="ModbusRTU_WriteMultCoils_Async"/>
					        <Pou name="ModbusRTU_WriteMultCoils"/>
					        <Pou name="ModbusRTU_WriteMultRegs_Async"/>
					        <Pou name="ModbusRTU_WriteSingleReg"/>
					        <Pou name="ModbusRTU_WriteSingleCoil_Async"/>
				</folder>
				        <folder name="Port settings">
					        <Pou name="ModbusRTU_GetComPortInfo"/>
					        <Pou name="ModbusRTU_ChangeComPortSettings"/>
				</folder>
			</folder>
		</libWorkspace>
		      <globalVars>
			      <group excludeFromBuild="FALSE" name="Modbus_RTU_Master">
				        <var dim0="248" name="sysMbMRtuNodeStatus" type="MBMNODESTATUS">
					        <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_0.
					
See the description of the MBMNODESTATUS structure for the meaning of the various fields.</descr>
					        <address index="60010" subIndex="0" type="I" typeVar="B"/>
				</var>
				        <var dim0="248" name="sysMbMRtuNodeStatus_1" type="MBMNODESTATUS">
					        <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_1.
					
See the description of the MBMNODESTATUS structure for the meaning of the various fields.</descr>
					        <address index="60010" subIndex="2976" type="I" typeVar="B"/>
				</var>
				        <var dim0="248" name="sysMbMRtuNodeStatus_2" type="MBMNODESTATUS">
					        <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_2.
					
See the description of the MBMNODESTATUS structure for the meaning of the various fields.</descr>
					        <address index="60010" subIndex="5952" type="I" typeVar="B"/>
				</var>
				        <var dim0="248" name="sysMbMRtuNodeStatus_3" type="MBMNODESTATUS">
					        <descr>System Modbus Master RTU communication status for network with id MB_RTU_NETWORK_3.
					
See the description of the MBMNODESTATUS structure for the meaning of the various fields.</descr>
					        <address index="60010" subIndex="8928" type="I" typeVar="B"/>
				</var>
			</group>
		</globalVars>
		      <retainVars>
			      <group excludeFromBuild="FALSE" name="Modbus_RTU_Master"/>
		</retainVars>
		      <constantVars>
			      <group excludeFromBuild="FALSE" name="Modbus_RTU_Master"/>
		</constantVars>
		      <iecVarsDeclaration>
			      <group name="Modbus_RTU_Master">
				        <iecDeclaration active="FALSE"/>
			</group>
		</iecVarsDeclaration>
		      <functions>
			      <function creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_Active" version="1.0.0">
				        <title>Activate/Deactivate slave node</title>
				        <descr>It is possible to deactivate a node in the network with netId=0.
Non blocking function.
Deprecated, use ModbusRTUNet_Active instead</descr>
				        <returnValue>BOOL</returnValue>
				        <vars>
					        <inputVars>
						          <var name="node" type="USINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="active" type="BOOL">
							          <descr>Activate node in network</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_Active" version="1.0.0">
				        <title>Activate/Deactivate slave node</title>
				        <descr>It is possible to activate/deactivate a node in the specified network.
Non blocking function.</descr>
				        <returnValue>BOOL</returnValue>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network</descr>
						</var>
						          <var name="node" type="USINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="active" type="BOOL">
							          <descr>Activate node in network</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="1575024867" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ChangeComPortSettings" version="1.0.0">
				        <title>Change COM port setting</title>
				        <descr>&lt;HTML&gt;It is possible to change port setting of a dedicated modbus RTU master COM port.&lt;br&gt;
It is possible to change parity, databits and stopbits. It is not possible to assign a different COM port.&lt;br&gt;
A valid port must be specified for modbus RTU master in configuration tool.</descr>
				        <returnValue>MB_COMPORT_SETTING_RIS_ENUM</returnValue>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="baudrate" type="UDINT">
							          <descr>Baudrate value</descr>
						</var>
						          <var name="parity" type="MB_COMPORT_SETTING_PARITY_ENUM">
							          <descr>Parity value</descr>
						</var>
						          <var name="databits" type="MB_COMPORT_SETTING_DATABITS_ENUM">
							          <descr>Databits value</descr>
						</var>
						          <var name="stopbits" type="MB_COMPORT_SETTING_STOPBITS_ENUM">
							          <descr>Stopbits value</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
		</functions>
		      <functionBlocks>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_WriteReg_S" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command. For network with netId=0.
Blocking function, cannot be called from init or timed tasks.
Deprecated, use ModbusRTUNet_WriteReg_S instead</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_ReadReg_RW" version="1.0.0">
				        <descr>Read ReadWrite modbus register using ReadHoldingRegister modbus command. For network with netId=0.
Blocking function, cannot be called from init or timed tasks.
Deprecated, use ModbusRTUNet_ReadReg_RW instead</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_ReadReg_RO" version="1.0.0">
				        <descr>Read ReadOnly modbus register using ReadInputRegister modbus command. For network with netId=0.
Blocking function, cannot be called from init or timed tasks.
Deprecated, use ModbusRTUNet_ReadReg_RO instead</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTU_WriteReg_M" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command. For network with netId=0.
Blocking function, cannot be called from init or timed tasks.
Deprecated, use ModbusRTUNet_WriteReg_M instead</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_S_Async" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. Check esi field for request result.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WrSingleReg_Async" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. Check esi field for request result.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>The address of the register to write</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>The value to write</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_M" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command, from a node of the specified network.
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WrMultiRegs" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command, from a node of the specified network.
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to write</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to write</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size of the provided buffer</descr>
						</var>
						          <var name="pDataIn" type="UDINT">
							          <descr>Pointer to buffer with the register values to write</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RW_Async" version="1.0.0">
				        <descr>Read ReadWrite modbus register using ReadHoldingRegister modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_RdHoldRegs_Async" version="1.0.0">
				        <descr>Read ReadWrite modbus register using ReadHoldingRegister modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to read</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the output buffer to store the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Maximum size of the provided output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size of the result (number of bytes stored in the output buffer) </descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RO" version="1.0.0">
				        <descr>Read ReadOnly modbus register using ReadInputRegister modbus command, from a node of the specified network.
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_RdInpRegs" version="1.0.0">
				        <descr>Read ReadOnly modbus register using ReadInputRegister modbus command, from a node of the specified network.
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to read</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the destination buffer for the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size of the provided buffer for the result</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size of the result (number of bytes stored in the buffer)</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RW" version="1.0.0">
				        <descr>Read ReadWrite modbus register using ReadHoldingRegister modbus command, from a node of the specified network
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_RdHoldRegs" version="1.0.0">
				        <descr>Read ReadWrite modbus register using ReadHoldingRegister modbus command, from a node of the specified network
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to read</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the destination buffer for the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size of the provided buffer for the result</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size of the result (number of bytes stored in the buffer)</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_S" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command, from a node of the specified network.
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WrSingleReg" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command, from a node of the specified network.
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>The address of the register to write</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>The value to write</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WriteReg_M_Async" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. Check esi field for request result.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_WrMultiRegs_Async" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. Check esi field for request result.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The first register to write</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to write</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size of the provided buffer</descr>
						</var>
						          <var name="pDataIn" type="UDINT">
							          <descr>Pointer to buffer with the register values to write</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_ReadReg_RO_Async" version="1.0.0">
				        <descr>Read ro modbus register using ReadInputRegister modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MB_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="0" name="ModbusRTUNet_RdInpRegs_Async" version="1.0.0">
				        <descr>Read readonly modbus register using ReadInputRegister modbus command asynchronously, from a node of the specified network
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>The index of the network. MB_RTU_NETWORK_ID to max modbus network supported</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to read</descr>
						</var>
						          <var name="_reserved" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the output buffer to store the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Maximum size of the provided output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size of the result (number of bytes stored in the output buffer) </descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Operation result. This flag has meaning only when asyncRqStatus is MB_ASYNC_RQ_ERROR or MB_ASYNC_RQ_DONE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadHoldingRegs_Async" version="1.0.0">
				        <title>Read holding registers - FC 03 modbus function - Async call</title>
				        <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleCoil" version="1.0.0">
				        <title>Write single coil - FC 05 modbus function</title>
				        <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultRegs" version="1.0.0">
				        <title>Write multiple registers - FC 16 modbus function</title>
				        <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved1" type="UINT"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the output buffer with registers values to transmit</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadDiscrInputs" version="1.0.0">
				        <title>Read discrete inputs - FC 02 modbus function</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from target using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadCoils_Async" version="1.0.0">
				        <title>Read multiple coils - FC 01 modbus function - Async call</title>
				        <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadHoldingRegs" version="1.0.0">
				        <title>Read holding registers - FC 03 modbus function</title>
				        <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadInputRegs_Async" version="1.0.0">
				        <title>Read input registers - FC 04 modbus function - Async call</title>
				        <descr>&lt;HTML&gt;Read input registers from target using FC 04 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleReg_Async" version="1.0.0">
				        <title>Write single register - FC 06 modbus function</title>
				        <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>Register address</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>Register value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadDiscrInputs_Async" version="1.0.0">
				        <title>Read discrete inputs - FC 02 modbus function - Async call</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from target using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadInputRegs" version="1.0.0">
				        <title>Read input registers - FC 04 modbus function</title>
				        <descr>&lt;HTML&gt;Read input registers from target using FC 04 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_ReadCoils" version="1.0.0">
				        <title>Read multiple coils - FC 01 modbus function</title>
				        <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultCoils_Async" version="1.0.0">
				        <title>Write multiple coils - FC 15 modbus function - Async call</title>
				        <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultCoils" version="1.0.0">
				        <title>Write multiple coils - FC 15 modbus function</title>
				        <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_WriteMultRegs_Async" version="1.0.0">
				        <title>Write multiple registers - FC 16 modbus function - Async call</title>
				        <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved1" type="UINT"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the output buffer with registers values to transmit</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleReg" version="1.0.0">
				        <title>Write single register - FC 06 modbus function</title>
				        <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>Register address</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>Register value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTU_WriteSingleCoil_Async" version="1.0.0">
				        <title>Write single coil - FC 05 modbus function - Async call</title>
				        <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1575025743" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTU_GetComPortInfo" version="1.0.0">
				        <title>Get actual communication port settings</title>
				        <descr>&lt;HTML&gt;Get communication port settings of a dedicated Modbus RTU master COM port.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="isModbusPort" type="BOOL">
							          <descr>Indcate if port is used by Modbus RTU Master</descr>
						</var>
						          <var name="isOpened" type="BOOL">
							          <descr>Port is opened and used by Modbus RTU Master</descr>
						</var>
						          <var name="isReopening" type="BOOL">
							          <descr>Request to reopen port with different settings is in progress</descr>
						</var>
						          <var name="comNumber" type="USINT">
							          <descr>Com number</descr>
						</var>
						          <var length="32" name="comString" type="STRING">
							          <descr>Com string</descr>
						</var>
						          <var name="baudrate" type="UDINT">
							          <descr>Baudrate value</descr>
						</var>
						          <var name="parity" type="MB_COMPORT_SETTING_PARITY_ENUM">
							          <descr>Parity value</descr>
						</var>
						          <var name="databits" type="MB_COMPORT_SETTING_DATABITS_ENUM">
							          <descr>Databits value</descr>
						</var>
						          <var name="stopbits" type="MB_COMPORT_SETTING_STOPBITS_ENUM">
							          <descr>Stopbits value</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTUNet_ReadCoils" version="1.0.0">
				        <title>Read coils from a node in the network</title>
				        <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function from a node of the specified network.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTUNet_RdCoils_Async" version="1.0.0">
				        <title>Read coils from a node in the network - Async call</title>
				        <descr>&lt;HTML&gt;Read coils from a node in the network using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTUNet_ReadDiscrInputs" version="1.0.0">
				        <title>Read discrete inputs from a node in the network</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from target using FC 02 modbus function from a node of the specified network.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTUNet_RdDiscrInp_Async" version="1.0.0">
				        <title>Read discrete inputs from a node in the network - Async call</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from a node in the network using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 16;&lt;br&gt;
				</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTUNet_WriteSingleCoil" version="1.0.0">
				        <title>Write single coil into a node in the network</title>
				        <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function into a node of the specified network.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273923" name="ModbusRTUNet_WrSingleCoil_Async" version="1.0.0">
				        <title>Write single coil into a node of the network - Async call</title>
				        <descr>&lt;HTML&gt;Write single coil into a node of the network using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTUNet_WriteMultCoils" version="1.0.0">
				        <title>Write multiple coils into a node of the network</title>
				        <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function into a node of the specified network.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1575273922" name="ModbusRTUNet_WrMultCoils_Async" version="1.0.0">
				        <title>Write multiple coils into a node of the network - Async call</title>
				        <descr>&lt;HTML&gt;Write multiple coils into a node of the network using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MB_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MB_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MB_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MB_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="netId" type="MB_RTU_NETWORK_ID">
							          <descr>Network id</descr>
						</var>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MB_ESI_VALUE">
							          <descr>Result of the command. One of the MB_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MB_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
		</functionBlocks>
		      <programs/>
		      <macros/>
		      <structs>
			      <struct name="MBMNODESTATUS" version="1.0.0">
				        <descr>
Communication status of a single Modbus RTU slave.

state could have the following meanings:
(valid only if miss is TRUE )
- MB_E_PROTOCOL               -320 :   Protocol error
- MB_E_IDE                    -321 :   Ide not match                        
- MB_E_ILLEGALFUNCTION        -322 :   Illegal function                        
- MB_E_ILLEGALDATAADDR        -323 :   Illegal data address                    
- MB_E_ILLEGALDATAVALUE       -324 :   Illegal data value                      
- MB_E_SLAVEDEVICEFAILURE     -325 :   Slave device failure                    
- MB_E_ACKNOWLEDGE            -326 :   Acknowledge                             
- MB_E_SLAVEDEVICEBUSY        -327 :   Slave device busy                       
- MB_E_MEMORYPARITYERROR      -328 :   Memory parity error                     
- MB_E_GATEWAYPATHUNAV        -329 :   Gateway path unavailable                
- MB_E_GATEWAYDEVICEFAILED    -330 :   Gateway target device failed to respond 
- MB_E_TIMEOUT                -331 :   Request timed out
- MB_E_ILLEGALDATAPROTOCOL    -332 :   Illegal data value in protocol
- MB_E_SWITCHEDOFF            -335 :   Node is switched off	

netStat can have the following meanings:
(node == 0, master)
- MB_MST_NOT_READY            0 :   Not ready
- MB_MST_READY                1 :   Ready
- MB_MST_START                2 :   Start
- MB_MST_STOP                 3 :   Stop
- MB_MST_RUN                  4 :   Run
- MB_MST_STOPPED              5 :   Stopped
- MB_MST_ERROR                6 :   Error

(node &gt;= 1, slave)
- MB_SLV_DISCONNECTED         0 :   Disconnected
- MB_SLV_OPENCONN             1 :   Connection opened
- MB_SLV_CLOSECONN            2 :   Connection closed
- MB_SLV_PAR                  3 :   Parameters setting
- MB_SLV_RUN                  4 :   Running</descr>
				        <vars>
					        <var name="cfg" type="BOOL">
						          <descr>Configurated</descr>
					</var>
					        <var name="pres" type="BOOL">
						          <descr>Present</descr>
					</var>
					        <var name="active" type="BOOL">
						          <descr>Indicate if node is active on network</descr>
					</var>
					        <var name="miss" type="BOOL">
						          <descr>Slave failure</descr>
					</var>
					        <var name="address" type="UINT">
						          <descr>Address</descr>
					</var>
					        <var name="missCnt" type="UINT">
						          <descr>Number of Task Timed cycles with Slave failure</descr>
					</var>
					        <var name="state" type="INT">
						          <descr>Slave failure error code</descr>
					</var>
					        <var name="netStat" type="UINT">
						          <descr>Status of the node in the network</descr>
					</var>
				</vars>
				        <iecDeclaration active="FALSE"/>
			</struct>
		</structs>
		      <typedefs/>
		      <enums>
			      <enum name="MB_RTU_NETWORK_ID" version="1.0.0">
				        <descr>Modbus RTU Network ID</descr>
				        <elements>
					        <element name="MB_RTU_NETWORK_0">
						          <descr>Network 0</descr>
						          <value>0</value>
					</element>
					        <element name="MB_RTU_NETWORK_1">
						          <descr>Network 1</descr>
						          <value>1</value>
					</element>
					        <element name="MB_RTU_NETWORK_2">
						          <descr>Network 2</descr>
						          <value>2</value>
					</element>
					        <element name="MB_RTU_NETWORK_3">
						          <descr>Network 3</descr>
						          <value>3</value>
					</element>
					        <element name="MB_RTU_NETWORKS">
						          <descr>Maximum number of networks supported</descr>
						          <value>4</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MB_DATA_TYPE" version="1.0.0">
				        <descr>Data types for modbus call</descr>
				        <elements>
					        <element name="DATA_T_SINT">
						          <descr>SINT</descr>
						          <value>0</value>
					</element>
					        <element name="DATA_T_USINT">
						          <descr>USINT</descr>
						          <value>1</value>
					</element>
					        <element name="DATA_T_BYTE">
						          <descr>BYTE</descr>
						          <value>2</value>
					</element>
					        <element name="DATA_T_INT">
						          <descr>INT</descr>
						          <value>3</value>
					</element>
					        <element name="DATA_T_UINT">
						          <descr>UINT</descr>
						          <value>4</value>
					</element>
					        <element name="DATA_T_WORD">
						          <descr>WORD</descr>
						          <value>5</value>
					</element>
					        <element name="DATA_T_DINT">
						          <descr>DINT</descr>
						          <value>6</value>
					</element>
					        <element name="DATA_T_UDINT">
						          <descr>UDINT</descr>
						          <value>7</value>
					</element>
					        <element name="DATA_T_DWORD">
						          <descr>DWORD</descr>
						          <value>8</value>
					</element>
					        <element name="DATA_T_REAL">
						          <descr>REAL</descr>
						          <value>9</value>
					</element>
					        <element name="DATA_T_BOOL">
						          <descr>BOOL</descr>
						          <value>10</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MB_ESI_VALUE" version="1.0.0">
				        <descr>Return value from modbus function call</descr>
				        <elements>
					        <element name="MB_E_OK">
						          <descr>Successful command</descr>
						          <value>0</value>
					</element>
					        <element name="MB_E_SYS">
						          <descr>Generic/system error</descr>
						          <value>-300</value>
					</element>
					        <element name="MB_E_NODE">
						          <descr>Not valid node</descr>
						          <value>-301</value>
					</element>
					        <element name="MB_E_NODEEXIST">
						          <descr>Node already existing</descr>
						          <value>-302</value>
					</element>
					        <element name="MB_E_NODENOTEXIST">
						          <descr>Not assigned node</descr>
						          <value>-303</value>
					</element>
					        <element name="MB_E_ADDR">
						          <descr>Invalid node address</descr>
						          <value>-304</value>
					</element>
					        <element name="MB_E_ADDREXIST">
						          <descr>Node address already assigned</descr>
						          <value>-305</value>
					</element>
					        <element name="MB_E_IMGBLOCKINV">
						          <descr>Invalid image block (network configuration error)</descr>
						          <value>-306</value>
					</element>
					        <element name="MB_E_IMGTYPEINV">
						          <descr>Invalid image block type (network configuration error)</descr>
						          <value>-307</value>
					</element>
					        <element name="MB_E_IMGSIZEINV">
						          <descr>Invalid size of image block (network configuration error)</descr>
						          <value>-308</value>
					</element>
					        <element name="MB_E_IMGADDRINV">
						          <descr>Invalid address of image block (network configuration error)</descr>
						          <value>-309</value>
					</element>
					        <element name="MB_E_IMGOVR">
						          <descr>Image memory exausted (network configuration error)</descr>
						          <value>-310</value>
					</element>
					        <element name="MB_E_DATATYPE">
						          <descr>Data type parameter not valid</descr>
						          <value>-311</value>
					</element>
					        <element name="MB_E_IMGBLOCKNOTFOUND">
						          <descr>Image block not found (network configuration error)</descr>
						          <value>-312</value>
					</element>
					        <element name="MB_E_PLCBLOCKNOTFOUND">
						          <descr>Plc datablock not found (network configuration error)</descr>
						          <value>-313</value>
					</element>
					        <element name="MB_E_IMGBROADCAST">
						          <descr>Broadcast not allowed (network configuration error)</descr>
						          <value>-314</value>
					</element>
					        <element name="MB_E_IMGONESHOTINV">
						          <descr>Invalid oneshot variable address (network configuration error)</descr>
						          <value>-315</value>
					</element>
					        <element name="MB_E_PARAMDBVALINV">
						          <descr>Invalid parameter address (network configuration error)</descr>
						          <value>-316</value>
					</element>
					        <element name="MB_E_STOPPED">
						          <descr>Master not running (network configuration error)</descr>
						          <value>-317</value>
					</element>
					        <element name="MB_E_PROTOCOL">
						          <descr>Protocol error</descr>
						          <value>-320</value>
					</element>
					        <element name="MB_E_IDE">
						          <descr>Ide doesn't match</descr>
						          <value>-321</value>
					</element>
					        <element name="MB_E_ILLEGALFUNCTION">
						          <descr>Illegal function</descr>
						          <value>-322</value>
					</element>
					        <element name="MB_E_ILLEGALDATAADDR">
						          <descr>Illegal data address</descr>
						          <value>-323</value>
					</element>
					        <element name="MB_E_ILLEGALDATAVALUE">
						          <descr>Illegal data value</descr>
						          <value>-324</value>
					</element>
					        <element name="MB_E_SLAVEDEVICEFAILURE">
						          <descr>Slave device failure</descr>
						          <value>-325</value>
					</element>
					        <element name="MB_E_ACKNOWLEDGE">
						          <descr>Acknowledge</descr>
						          <value>-326</value>
					</element>
					        <element name="MB_E_SLAVEDEVICEBUSY">
						          <descr>Slave device busy</descr>
						          <value>-327</value>
					</element>
					        <element name="MB_E_MEMORYPARITYERROR">
						          <descr>Memory parity error</descr>
						          <value>-328</value>
					</element>
					        <element name="MB_E_GATEWAYPATHUNAV">
						          <descr>Gateway path unavailable</descr>
						          <value>-329</value>
					</element>
					        <element name="MB_E_GATEWAYDEVICEFAILED">
						          <descr>Gateway target device failed to respond</descr>
						          <value>-330</value>
					</element>
					        <element name="MB_E_TIMEOUT">
						          <descr>Request timed out</descr>
						          <value>-331</value>
					</element>
					        <element name="MB_E_ILLEGALDATAPROTOCOL">
						          <descr>Illegal data value in protocol</descr>
						          <value>-332</value>
					</element>
					        <element name="MB_E_COMMUNICATION">
						          <descr>Communication error. Serial port closed</descr>
						          <value>-333</value>
					</element>
					        <element name="MB_E_SWITCHEDOFF">
						          <descr>Node is switched off</descr>
						          <value>-335</value>
					</element>
					        <element name="MB_E_NOTALLOWEDINTIMEDTASK">
						          <descr>Function cannot be called in a timed task</descr>
						          <value>-336</value>
					</element>
					        <element name="MB_E_NEGATIVEACKNOWLEDGE">
						          <descr>Negative acknowledge</descr>
						          <value>-337</value>
					</element>
					        <element name="MB_E_CHECKSUM">
						          <descr>Checksum</descr>
						          <value>-338</value>
					</element>
					        <element name="MB_E_NETWORK">
						          <descr>Invalid network id specified</descr>
						          <value>-339</value>
					</element>
					        <element name="MB_E_CMDBUFFERSIZEERROR">
						          <descr>Invalid command buffer size error</descr>
						          <value>-340</value>
					</element>
					        <element name="MB_E_CMDBUFFERERROR">
						          <descr>Invalid command buffer error</descr>
						          <value>-341</value>
					</element>
					        <element name="MB_E_CMDBUFFERTOOSMALL">
						          <descr>Buffer too small</descr>
						          <value>-342</value>
					</element>
					        <element name="MB_E_CMDSAMEBUFFER">
						          <descr>Same buffer specified</descr>
						          <value>-343</value>
					</element>
					        <element name="MB_E_CMDPARAMERROR">
						          <descr>Invalid parameter specified</descr>
						          <value>-344</value>
					</element>
					        <element name="MB_E_NOCONNSLOTAVAILABLE">
						          <descr>Connection error</descr>
						          <value>-345</value>
					</element>
					        <element name="MB_E_NOCONNSYSTEMBUSY">
						          <descr>System busy</descr>
						          <value>-346</value>
					</element>
					        <element name="MB_E_REQUESTMISMATCH">
						          <descr>Request mismatch</descr>
						          <value>-347</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MB_ASYNC_RQ_STATUS" version="1.0.0">
				        <descr>Status of the async request</descr>
				        <elements>
					        <element name="MB_ASYNC_RQ_UNKNOWN">
						          <descr>Initial or unknown status</descr>
						          <value>0</value>
					</element>
					        <element name="MB_ASYNC_RQ_ERROR">
						          <descr>Error in setting request</descr>
						          <value>1</value>
					</element>
					        <element name="MB_ASYNC_RQ_SET">
						          <descr>Status take this value when request is successfully set</descr>
						          <value>2</value>
					</element>
					        <element name="MB_ASYNC_RQ_BUSY">
						          <descr>Request in progress</descr>
						          <value>3</value>
					</element>
					        <element name="MB_ASYNC_RQ_DONE">
						          <descr>Request completed. Command result can be checked. Other requests can be done</descr>
						          <value>4</value>
					</element>
					        <element name="MB_ASYNC_RQ_MISMATCH">
						          <descr>Request set by user and processed mismatch from actual frame command</descr>
						          <value>5</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MB_COMPORT_SETTING_DATABITS_ENUM" version="1.0.0">
				        <descr>Number of data bits that can be specified in change serial port function ModbusRTU_ChangeComPortSettings</descr>
				        <elements>
					        <element name="MB_COMPORT_SETTING_DATABITS_7">
						          <descr>Databits 7</descr>
						          <value>7</value>
					</element>
					        <element name="MB_COMPORT_SETTING_DATABITS_8">
						          <descr>Databits 8</descr>
						          <value>8</value>
					</element>
					        <element name="MB_COMPORT_SETTING_DATABITS_UNKNOWN">
						          <descr>Unknown</descr>
						          <value>255</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MB_COMPORT_SETTING_PARITY_ENUM" version="1.0.0">
				        <descr>Parity setting that can be specified in change serial port function ModbusRTU_ChangeComPortSettings</descr>
				        <elements>
					        <element name="MB_COMPORT_SETTING_PARITY_NONE">
						          <descr>Parity none</descr>
						          <value>0</value>
					</element>
					        <element name="MB_COMPORT_SETTING_PARITY_ODD">
						          <descr>Parity odd</descr>
						          <value>1</value>
					</element>
					        <element name="MB_COMPORT_SETTING_PARITY_EVEN">
						          <descr>Parity error</descr>
						          <value>2</value>
					</element>
					        <element name="MB_COMPORT_SETTING_PARITY_UNKNOWN">
						          <descr>Unknown</descr>
						          <value>255</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MB_COMPORT_SETTING_RIS_ENUM" version="1.0.0">
				        <descr>Function ModbusRTU_ChangeComPortSettings result value</descr>
				        <elements>
					        <element name="MB_COMPORT_SETTING_RIS_OK">
						          <descr>Ok</descr>
						          <value>0</value>
					</element>
					        <element name="MB_COMPORT_SETTING_ERR_INVALID_NETID">
						          <descr>Invalid network id specified</descr>
						          <value>1</value>
					</element>
					        <element name="MB_COMPORT_SETTING_ERR_NO_MODBUS">
						          <descr>Modbus master not running on this network</descr>
						          <value>2</value>
					</element>
					        <element name="MB_COMPORT_SETTING_ERR_PARAM_PARITY">
						          <descr>Parity error</descr>
						          <value>3</value>
					</element>
					        <element name="MB_COMPORT_SETTING_ERR_PARAM_DATABITS">
						          <descr>Databits error</descr>
						          <value>4</value>
					</element>
					        <element name="MB_COMPORT_SETTING_ERR_PARAM_STOPBITS">
						          <descr>Stopbits error</descr>
						          <value>5</value>
					</element>
					        <element name="MB_COMPORT_SETTING_ERR_REQUEST_ALREADY_SET">
						          <descr>Request to change port settings already in progress</descr>
						          <value>6</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MB_COMPORT_SETTING_STOPBITS_ENUM" version="1.0.0">
				        <descr>Number of stop bits that can be specified in change serial port function ModbusRTU_ChangeComPortSettings</descr>
				        <elements>
					        <element name="MB_COMPORT_SETTING_STOPBITS_1">
						          <descr>One stopbit</descr>
						          <value>1</value>
					</element>
					        <element name="MB_COMPORT_SETTING_STOPBITS_2">
						          <descr>Two stopbits</descr>
						          <value>2</value>
					</element>
					        <element name="MB_COMPORT_SETTING_STOPBITS_UNKNOWN">
						          <descr>Unknown setting</descr>
						          <value>255</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
		</enums>
		      <subranges/>
		      <interfaces/>
	</lib>    <lib fullXml="true" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../Libraries/ModbusTCP.plclib" version="1.0.5">
		      <descr>ModbusTCP master library</descr>
		      <libWorkspace>
			      <folder id="49" name="ModbusTCP">
				        <folder name="Definitions">
					        <folder name="Enumerations">
						          <Definition name="MBTCP_ASYNC_RQ_STATUS"/>
						          <Definition name="MBTCP_DATA_TYPE"/>
						          <Definition name="MBTCP_ESI_VALUE"/>
					</folder>
					        <folder name="Structures">
						          <Definition name="MBMTCPNODESTATUS"/>
					</folder>
				</folder>
				        <GlobalVars name="Modbus_TCP_Master"/>
				        <folder name="Raw commands">
					        <Pou name="ModbusTCP_WriteSingleReg_Async"/>
					        <Pou name="ModbusTCP_WriteMultRegs"/>
					        <Pou name="ModbusTCP_WriteSingleCoil"/>
					        <Pou name="ModbusTCP_WriteSingleCoil_Async"/>
					        <Pou name="ModbusTCP_ReadInputRegs_Async"/>
					        <Pou name="ModbusTCP_ReadDiscrInputs"/>
					        <Pou name="ModbusTCP_ReadDiscrInputs_Async"/>
					        <Pou name="ModbusTCP_ReadHoldingRegs"/>
					        <Pou name="ModbusTCP_ReadInputRegs"/>
					        <Pou name="ModbusTCP_ReadHoldingRegs_Async"/>
					        <Pou name="ModbusTCP_WriteMultCoils"/>
					        <Pou name="ModbusTCP_WriteSingleReg"/>
					        <Pou name="ModbusTCP_ReadCoils"/>
					        <Pou name="ModbusTCP_ReadCoils_Async"/>
					        <Pou name="ModbusTCP_WriteMultCoils_Async"/>
					        <Pou name="ModbusTCP_WriteMultRegs_Async"/>
				</folder>
				        <folder name="Obsolete">
					        <Pou name="ModbusTCP_WriteReg_M_Async"/>
					        <Pou name="ModbusTCP_ReadReg_RO_Async"/>
					        <Pou name="ModbusTCP_ReadReg_RO"/>
					        <Pou name="ModbusTCP_WriteReg_M"/>
					        <Pou name="ModbusTCP_ReadReg_RW"/>
					        <Pou name="ModbusTCP_WriteReg_S_Async"/>
					        <Pou name="ModbusTCP_ReadReg_RW_Async"/>
					        <Pou name="ModbusTCP_WriteReg_S"/>
					        <Pou name="ModbusTCPNet_WriteReg_M_Async"/>
					        <Pou name="ModbusTCPNet_ReadReg_RO_Async"/>
					        <Pou name="ModbusTCPNet_ReadReg_RO"/>
					        <Pou name="ModbusTCPNet_WriteReg_M"/>
					        <Pou name="ModbusTCPNet_ReadReg_RW"/>
					        <Pou name="ModbusTCPNet_WriteReg_S_Async"/>
					        <Pou name="ModbusTCPNet_ReadReg_RW_Async"/>
					        <Pou name="ModbusTCPNet_WriteReg_S"/>
				</folder>
				        <folder name="Network commands">
					        <Pou name="ModbusTCPNet_RdHoldRegs"/>
					        <Pou name="ModbusTCPNet_RdInpRegs"/>
					        <Pou name="ModbusTCPNet_WrSingleReg"/>
					        <Pou name="ModbusTCPNet_WrMultiRegs"/>
					        <Pou name="ModbusTCPNet_RdHoldRegs_Async"/>
					        <Pou name="ModbusTCPNet_RdInpRegs_Async"/>
					        <Pou name="ModbusTCPNet_WrSingleReg_Async"/>
					        <Pou name="ModbusTCPNet_WrMultiRegs_Async"/>
					        <Pou name="ModbusTCPNet_ReadCoils"/>
					        <Pou name="ModbusTCPNet_RdCoils_Async"/>
					        <Pou name="ModbusTCPNet_ReadDiscrInputs"/>
					        <Pou name="ModbusTCPNet_RdDiscrInp_Async"/>
					        <Pou name="ModbusTCPNet_WriteSingleCoil"/>
					        <Pou name="ModbusTCPNet_WrSingleCoil_Async"/>
					        <Pou name="ModbusTCPNet_WriteMultCoils"/>
					        <Pou name="ModbusTCPNet_WrMultCoils_Async"/>
				</folder>
			</folder>
		</libWorkspace>
		      <globalVars>
			      <group excludeFromBuild="FALSE" name="Modbus_TCP_Master">
				        <var dim0="248" name="sysMbMTcpNodeStatus" type="MBMTCPNODESTATUS">
					        <descr>System Modbus Master TCP communication status.
					
See the description of the MBMTCPNODESTATUS structure for the meaning of the various fields.</descr>
					        <address index="60020" subIndex="0" type="I" typeVar="B"/>
				</var>
			</group>
		</globalVars>
		      <retainVars>
			      <group excludeFromBuild="FALSE" name="Modbus_TCP_Master"/>
		</retainVars>
		      <constantVars>
			      <group excludeFromBuild="FALSE" name="Modbus_TCP_Master"/>
		</constantVars>
		      <iecVarsDeclaration>
			      <group name="Modbus_TCP_Master">
				        <iecDeclaration active="FALSE"/>
			</group>
		</iecVarsDeclaration>
		      <functions/>
		      <functionBlocks>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleReg_Async" version="1.0.0">
				        <title>Write single register - FC 06 modbus function</title>
				        <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
				</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>Register address</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>Register value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultRegs" version="1.0.0">
				        <title>Write multiple registers - FC 16 modbus function</title>
				        <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the output buffer with registers values to transmit</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleCoil" version="1.0.0">
				        <title>Write single coil - FC 05 modbus function</title>
				        <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.
				</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleCoil_Async" version="1.0.0">
				        <title>Write single coil - FC 05 modbus function</title>
				        <descr>&lt;HTML&gt;Write single coil into target using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadInputRegs_Async" version="1.0.0">
				        <title>Read holding registers - FC 03 modbus function</title>
				        <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadDiscrInputs" version="1.0.0">
				        <title>Read discrete inputs - FC 02 modbus function</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from a node in the network using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put value into a WORD var inputsInAWordVar:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataOut := ADR( inputsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put values into an array of BOOL var inputsBoolArray:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( inputsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing inputs buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing inputs buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (inputs will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each input requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadDiscrInputs_Async" version="1.0.0">
				        <title>Read discrete inputs - FC 02 modbus function</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put value into a WORD var inputsInAWordVar:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataOut := ADR( inputsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put values into an array of BOOL var inputsBoolArray:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( inputsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing inputs buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing inputs buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (inputs will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each input requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadHoldingRegs" version="1.0.0">
				        <title>Read holding registers - FC 03 modbus function</title>
				        <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadInputRegs" version="1.0.0">
				        <title>Read holding registers - FC 03 modbus function</title>
				        <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadHoldingRegs_Async" version="1.0.0">
				        <title>Read holding registers - FC 03 modbus function</title>
				        <descr>&lt;HTML&gt;Read registers from target using FC 03 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
External buffer must be provided to put received data in&lt;br&gt;
&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 registers and put values into dwordArray[ 0..7 ] OF DWORD array:&lt;br&gt;
regNum := 16;&lt;br&gt;
pDataOut := ADR( dwordArray[0] );&lt;br&gt;
sizeIn := 32;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Number of bytes of data received stored in pDataOut</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultCoils" version="1.0.0">
				        <title>Write multiple coils - FC 15 modbus function</title>
				        <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteSingleReg" version="1.0.0">
				        <title>Write single register - FC 06 modbus function</title>
				        <descr>&lt;HTML&gt;Write single register into target using FC 06 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
				</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>Register address</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>Register value</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadCoils" version="1.0.0">
				        <title>Read multiple coils - FC 01 modbus function</title>
				        <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCP_ReadCoils_Async" version="1.0.0">
				        <title>Read multiple coils - FC 01 modbus function</title>
				        <descr>&lt;HTML&gt;Read coils from target using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultCoils_Async" version="1.0.0">
				        <title>Write multiple coils - FC 15 modbus function</title>
				        <descr>&lt;HTML&gt;Write multiple coils into target using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataBoolIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="_reserved1" type="WORD"/>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCP_WriteMultRegs_Async" version="1.0.0">
				        <title>Write multiple registers - FC 16 modbus function</title>
				        <descr>&lt;HTML&gt;Write multiple registers into target using FC 16 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
External buffer must be provided. sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 registers from a wordArray[0..11] OF WORD var:&lt;br&gt;
regNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 24;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var length="15" name="IPAddress" type="STRING">
							          <descr>IP address</descr>
						</var>
						          <var name="TCPPort" type="UINT">
							          <descr>TCP port</descr>
						</var>
						          <var name="modbusAddr" type="UINT">
							          <descr>Modbus network node address</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="regAddrStart" type="UINT">
							          <descr>Register start address</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>Number of registers</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Max size in bytes of the output buffer</descr>
						</var>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the output buffer with registers values to transmit</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885197" name="ModbusTCP_WriteReg_M_Async" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_WriteReg_M_Async instead.
Write modbus register using WriteMultipleRegisters modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCP_ReadReg_RO_Async" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_ReadReg_RO_Async instead.
Read ro modbus register using ReadInputRegister modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCP_ReadReg_RO" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_ReadReg_RO instead.
Read ro modbus register using ReadInputRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885187" name="ModbusTCP_WriteReg_M" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_WriteReg_M instead.
Write modbus register using WriteMultipleRegisters modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCP_ReadReg_RW" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_ReadReg_RW instead.
Read rw modbus register using ReadHoldingRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885230" name="ModbusTCP_WriteReg_S_Async" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_WriteReg_S_Async instead.
Write modbus register using WriteSingleRegister modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCP_ReadReg_RW_Async" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_ReadReg_RW_Async instead.
Read rw modbus register using ReadHoldingRegister modbus command asynchronously
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885216" name="ModbusTCP_WriteReg_S" version="1.0.0">
				        <descr>Deprecated: use ModbusTCPNet_WriteReg_S instead.
Write modbus register using WriteSingleRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885197" name="ModbusTCPNet_WriteReg_M_Async" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885197" name="ModbusTCPNet_WrMultiRegs_Async" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to write</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size of the provided buffer</descr>
						</var>
						          <var name="pDataIn" type="UDINT">
							          <descr>Pointer to buffer with the register values to write</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCPNet_ReadReg_RO_Async" version="1.0.0">
				        <descr>Read ro modbus register using ReadInputRegister modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCPNet_RdInpRegs_Async" version="1.0.0">
				        <descr>Read readonly modbus register using ReadInputRegister modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of input registers to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the destination buffer to store the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Maximum size in bytes of the destination buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size of result (number of byte stored in the destination buffer)</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCPNet_ReadReg_RO" version="1.0.0">
				        <descr>Read ro modbus register using ReadInputRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885156" name="ModbusTCPNet_RdInpRegs" version="1.0.0">
				        <descr>Read readonly modbus register using ReadInputRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of input registers to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the destination buffer to store the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size of the provided destination buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size of result (number of bytes stored in destination buffer)</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885187" name="ModbusTCPNet_WriteReg_M" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885187" name="ModbusTCPNet_WrMultiRegs" version="1.0.0">
				        <descr>Write modbus register using WriteMultipleRegisters modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to write</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to write</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size of the provided buffer</descr>
						</var>
						          <var name="pDataIn" type="UDINT">
							          <descr>Pointer to buffer with the register values to write</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCPNet_ReadReg_RW" version="1.0.0">
				        <descr>Read rw modbus register using ReadHoldingRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCPNet_RdHoldRegs" version="1.0.0">
				        <descr>Read rw modbus register using ReadHoldingRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the destination buffer to store the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size of the provided buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Bytes with data in the buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885230" name="ModbusTCPNet_WriteReg_S_Async" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885230" name="ModbusTCPNet_WrSingleReg_Async" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command asynchronously.
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>The address of the register to write</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>The value to write</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCPNet_ReadReg_RW_Async" version="1.0.0">
				        <descr>Read rw modbus register using ReadHoldingRegister modbus command asynchronously
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="res_dword" type="DWORD">
							          <descr>Result is always put in a dword</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885180" name="ModbusTCPNet_RdHoldRegs_Async" version="1.0.0">
				        <descr>Read rw modbus register using ReadHoldingRegister modbus command asynchronously
Non blocking function. Only one request at the time can be processed.

Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.

Call the first time the FB to raise the request:
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.
If request has been set, call periodically the FB to check if the request is completed:
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_STATUS. It is possible to check esi field and get received data.
A new request can be raised.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddrStart" type="UINT">
							          <descr>The address of the first register to read</descr>
						</var>
						          <var name="regNum" type="UINT">
							          <descr>The number of registers to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
						          <var name="pDataOut" type="UDINT">
							          <descr>Pointer to the destination buffer to store the result</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Maximum number of bytes of destination buffer</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size of result (number of bytes stored into destination buffer)</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Status of the async request</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885216" name="ModbusTCPNet_WriteReg_S" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="reg_addr" type="UINT">
							          <descr>The address of the register to read</descr>
						</var>
						          <var name="data_type" type="MBTCP_DATA_TYPE">
							          <descr>The type of the data to read</descr>
						</var>
						          <var name="data_raw" type="DWORD">
							          <descr>Data to be written</descr>
						</var>
						          <var name="tmo" type="UDINT">
							          <descr>Timeout in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="0" excludeFromBuild="FALSE" lastModifiedDate="1617885216" name="ModbusTCPNet_WrSingleReg" version="1.0.0">
				        <descr>Write modbus register using WriteSingleRegister modbus command
Blocking function, cannot be called from init or timed tasks.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="regAddr" type="UINT">
							          <descr>The address of the register to write</descr>
						</var>
						          <var name="regValue" type="UINT">
							          <descr>The value to write</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved1" type="UINT">
							          <descr>Reserved for future use</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Operation result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCPNet_ReadCoils" version="1.0.0">
				        <title>Read multiple coils from a node in the network</title>
				        <descr>&lt;HTML&gt;Read coils from a node in the network using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCPNet_RdCoils_Async" version="1.0.0">
				        <title>Read multiple coils from a node in the network</title>
				        <descr>&lt;HTML&gt;Read coils from a node in the network using FC 01 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataOut := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 coils and put values into an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddrStart" type="UINT">
							          <descr>Coil start address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCPNet_ReadDiscrInputs" version="1.0.0">
				        <title>Read discrete inputs from a node in the network</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from a node in the network using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put value into a WORD var inputsInAWordVar:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataOut := ADR( inputsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put values into an array of BOOL var inputsBoolArray:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( inputsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing inputs buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing inputs buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (inputs will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each input requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574773515" excludeFromBuild="FALSE" lastModifiedDate="1617885338" name="ModbusTCPNet_RdDiscrInp_Async" version="1.0.0">
				        <title>Read discrete inputs from a node in the network</title>
				        <descr>&lt;HTML&gt;Read discrete inputs from a node in the network using FC 02 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to get received data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put value into a WORD var inputsInAWordVar:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataOut := ADR( inputsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolOut buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to read 16 inputs and put values into an array of BOOL var inputsBoolArray:&lt;br&gt;
discrInputsNum := 16;&lt;br&gt;
pDataBoolOut := ADR( inputsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 16;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="discrInputStart" type="UINT">
							          <descr>Discrete input start address</descr>
						</var>
						          <var name="discrInputsNum" type="UINT">
							          <descr>Number of discrete inputs to read</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataOut. Set 0 if pDataBoolOut is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolOut. Set 0 if pDataOut is provided</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="pDataOut" type="PVOID">
							          <descr>Address of the output buffer (coils will be packed as bit)</descr>
						</var>
						          <var name="pDataBoolOut" type="@BOOL">
							          <descr>Address of the output buffer (each coil requires a BOOL)</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="sizeOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataOut buffer</descr>
						</var>
						          <var name="sizeBoolOut" type="UINT">
							          <descr>Size in bytes of the data in the pDataBoolOut buffer</descr>
						</var>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCPNet_WriteSingleCoil" version="1.0.0">
				        <title>Write single coil into a node of the network</title>
				        <descr>&lt;HTML&gt;Write single coil into a node of the network using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.
				</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCPNet_WrSingleCoil_Async" version="1.0.0">
				        <title>Write single coil into a node of the network</title>
				        <descr>&lt;HTML&gt;Write single coil into a node of the network using FC 05 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
If coil value is 0, value 0 is sent as coil value
IF coil value is != 0, value 0x00FF is sent as coil value.</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilAddr" type="UINT">
							          <descr>Coil address</descr>
						</var>
						          <var name="coilValue" type="UINT">
							          <descr>Coil value. 0 or 1 value</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCPNet_WriteMultCoils" version="1.0.0">
				        <title>Write multiple coils into a node of the network</title>
				        <descr>&lt;HTML&gt;Write multiple coils into a node of the network using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Blocking function, cannot be called from init or timed tasks.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1574783202" excludeFromBuild="FALSE" lastModifiedDate="1617885393" name="ModbusTCPNet_WrMultCoils_Async" version="1.0.0">
				        <title>Write multiple coils into a node of the network</title>
				        <descr>&lt;HTML&gt;Write multiple coils into a node of the network using FC 15 modbus function.&lt;br&gt;
&lt;br&gt;
Non blocking function. Only one request at the time can be processed.&lt;br&gt;
&lt;br&gt;
Request must be periodically called until is completed. Other requests are rejected until the current one is in progress.&lt;br&gt;
&lt;br&gt;
Call the first time the FB to raise the request:&lt;br&gt;
- if request can be forwarded to modbus network asyncRqStatus value is MBTCP_ASYNC_RQ_SET.&lt;br&gt;
- if other request is in progress asyncRqStatus value is MBTCP_ASYNC_RQ_MISMATCH. Other request should be completed before to raise a new one.&lt;br&gt;
If request has been set, call periodically the FB to check if the request is completed:&lt;br&gt;
- if request is not completed asyncRqStatus value is MBTCP_ASYNC_RQ_BUSY. Call again the FB after some time.&lt;br&gt;
- if request is completed asyncRqStatus value is MBTCP_ASYNC_RQ_DONE. It is possible to check esi field and get received data.&lt;br&gt;
A new request can be raised.&lt;br&gt;
&lt;br&gt;
It is possible to set data in a buffer in two different ways:&lt;br&gt;
&lt;br&gt;
&lt;b&gt;1) bit packed&lt;/b&gt;&lt;br&gt;
sizeIn of the pDataIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils from a value into a WORD var coilsInAWordVar:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataIn := ADR( coilsInAWordVar );&lt;br&gt;
sizeIn := 2;&lt;br&gt;
&lt;br&gt;
&lt;b&gt;2) array of BOOL&lt;/b&gt;&lt;br&gt;
sizeBoolIn of the pDataBoolIn buffer must be specified in bytes&lt;br&gt;
es:&lt;br&gt;
to write 12 coils form an array of BOOL var coilsBoolArray:&lt;br&gt;
coilsNum := 12;&lt;br&gt;
pDataBoolIn := ADR( coilsBoolArray[0] );&lt;br&gt;
sizeBoolIn := 12;&lt;br&gt;</descr>
				        <vars>
					        <inputVars>
						          <var name="node" type="UINT">
							          <descr>The index of the node in the network</descr>
						</var>
						          <var name="coilStart" type="UINT">
							          <descr>First coil address</descr>
						</var>
						          <var name="coilsNum" type="UINT">
							          <descr>Number of coils</descr>
						</var>
						          <var name="sizeIn" type="UINT">
							          <descr>Size in bytes of the writing coils buffer pDataIn. Set 0 if pDataBoolIn is provided</descr>
						</var>
						          <var name="sizeBoolIn" type="UINT">
							          <descr>Size in bytes of the receiveing coils buffer pDataBoolIn. Set 0 if pDataIn is provided</descr>
						</var>
						          <var name="_reserved" type="WORD"/>
						          <var name="pDataIn" type="PVOID">
							          <descr>Address of the input buffer (coils are packed as bit)</descr>
						</var>
						          <var name="pDataBoolIn" type="@BOOL">
							          <descr>Address of the input buffer (each coil is on a BOOL array element)</descr>
						</var>
						          <var name="timeoutMs" type="UINT">
							          <descr>Timeout in ms</descr>
						</var>
						          <var name="waitBeforeSendMs" type="UINT">
							          <descr>Wait before send in ms</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="esi" type="MBTCP_ESI_VALUE">
							          <descr>Result of the command. One of the MBTCP_ESI_VALUE</descr>
						</var>
						          <var name="asyncRqStatus" type="MBTCP_ASYNC_RQ_STATUS">
							          <descr>Async request result</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
		</functionBlocks>
		      <programs/>
		      <macros/>
		      <structs>
			      <struct name="MBMTCPNODESTATUS" version="1.0.0">
				        <descr>Communication status of a single Modbus TCP slave.

state could have the following meanings:
(valid only if miss is TRUE )
- MB_E_PROTOCOL               -320 :   Protocol error
- MB_E_IDE                    -321 :   Ide not match                        
- MB_E_ILLEGALFUNCTION        -322 :   Illegal function                        
- MB_E_ILLEGALDATAADDR        -323 :   Illegal data address                    
- MB_E_ILLEGALDATAVALUE       -324 :   Illegal data value                      
- MB_E_SLAVEDEVICEFAILURE     -325 :   Slave device failure                    
- MB_E_ACKNOWLEDGE            -326 :   Acknowledge                             
- MB_E_SLAVEDEVICEBUSY        -327 :   Slave device busy                       
- MB_E_MEMORYPARITYERROR      -328 :   Memory parity error                     
- MB_E_GATEWAYPATHUNAV        -329 :   Gateway path unavailable                
- MB_E_GATEWAYDEVICEFAILED    -330 :   Gateway target device failed to respond 
- MB_E_TIMEOUT                -331 :   Time out richiesta
- MB_E_ILLEGALDATAPROTOCOL    -332 :   Illegal data value in protocol
- MB_E_COMMUNICATION          -333 :   Communication error
- MB_E_CONNECTION             -334 :   Connection error	

netStat can have the following meanings:
(node == 0, master)
- MB_MST_NOT_READY            0 :   Not ready
- MB_MST_READY                1 :   Ready
- MB_MST_START                2 :   Start
- MB_MST_STOP                 3 :   Stop
- MB_MST_RUN                  4 :   Run
- MB_MST_STOPPED              5 :   Stopped
- MB_MST_ERROR                6 :   Error

(node &gt;= 1, slave)
- MB_SLV_DISCONNECTED         0 :   Disconnected
- MB_SLV_OPENCONN             1 :   Connection opened
- MB_SLV_CLOSECONN            2 :   Connection closed
- MB_SLV_PAR                  3 :   Parameters setting
- MB_SLV_RUN                  4 :   Running
- MB_SLV_WAITCONN             5 :   Waiting for connection establishment</descr>
				        <vars>
					        <var name="cfg" type="BOOL">
						          <descr>Configurated</descr>
					</var>
					        <var name="pres" type="BOOL">
						          <descr>Present</descr>
					</var>
					        <var name="active" type="BOOL">
						          <descr>Indicate if node is active on network</descr>
					</var>
					        <var name="miss" type="BOOL">
						          <descr>Slave failure</descr>
					</var>
					        <var length="19" name="ip" type="STRING">
						          <descr>IP address</descr>
					</var>
					        <var name="address" type="UINT">
						          <descr>Subnet Address</descr>
					</var>
					        <var name="missCnt" type="UINT">
						          <descr>Number of Task Timed cycles with Slave failure</descr>
					</var>
					        <var name="state" type="INT">
						          <descr>Slave failure error code</descr>
					</var>
					        <var name="netStat" type="UINT">
						          <descr>Status of the node in the network</descr>
					</var>
				</vars>
				        <iecDeclaration active="FALSE"/>
			</struct>
		</structs>
		      <typedefs/>
		      <enums>
			      <enum name="MBTCP_ASYNC_RQ_STATUS" version="1.0.0">
				        <descr>Status of the async request</descr>
				        <elements>
					        <element name="MBTCP_ASYNC_RQ_UNKNOWN">
						          <descr>Initial or unknown status</descr>
						          <value>0</value>
					</element>
					        <element name="MBTCP_ASYNC_RQ_ERROR">
						          <descr>Error in setting request</descr>
						          <value>1</value>
					</element>
					        <element name="MBTCP_ASYNC_RQ_SET">
						          <descr>Status take this value when request is successfully set</descr>
						          <value>2</value>
					</element>
					        <element name="MBTCP_ASYNC_RQ_BUSY">
						          <descr>Request in progress</descr>
						          <value>3</value>
					</element>
					        <element name="MBTCP_ASYNC_RQ_DONE">
						          <descr>Request completed. Command result can be checked. Other requests can be done</descr>
						          <value>4</value>
					</element>
					        <element name="MBTCP_ASYNC_RQ_MISMATCH">
						          <descr>Request set by user and processed mismatch from actual frame command</descr>
						          <value>5</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MBTCP_DATA_TYPE" version="1.0.0">
				        <descr>Data types for modbus call</descr>
				        <elements>
					        <element name="MBTCP_DATA_T_SINT">
						          <descr>SINT</descr>
						          <value>0</value>
					</element>
					        <element name="MBTCP_DATA_T_USINT">
						          <descr>USINT</descr>
						          <value>1</value>
					</element>
					        <element name="MBTCP_DATA_T_BYTE">
						          <descr>BYTE</descr>
						          <value>2</value>
					</element>
					        <element name="MBTCP_DATA_T_INT">
						          <descr>INT</descr>
						          <value>3</value>
					</element>
					        <element name="MBTCP_DATA_T_UINT">
						          <descr>UINT</descr>
						          <value>4</value>
					</element>
					        <element name="MBTCP_DATA_T_WORD">
						          <descr>WORD</descr>
						          <value>5</value>
					</element>
					        <element name="MBTCP_DATA_T_DINT">
						          <descr>DINT</descr>
						          <value>6</value>
					</element>
					        <element name="MBTCP_DATA_T_UDINT">
						          <descr>UDINT</descr>
						          <value>7</value>
					</element>
					        <element name="MBTCP_DATA_T_DWORD">
						          <descr>DWORD</descr>
						          <value>8</value>
					</element>
					        <element name="MBTCP_DATA_T_REAL">
						          <descr>REAL</descr>
						          <value>9</value>
					</element>
					        <element name="MBTCP_DATA_T_BOOL">
						          <descr>BOOL</descr>
						          <value>10</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MBTCP_ESI_VALUE" version="1.0.0">
				        <descr>Return value from modbus function call</descr>
				        <elements>
					        <element name="MBTCP_E_OK">
						          <descr>Successful command</descr>
						          <value>0</value>
					</element>
					        <element name="MBTCP_E_SYS">
						          <descr>Generic/system error</descr>
						          <value>-300</value>
					</element>
					        <element name="MBTCP_E_NODE">
						          <descr>Not valid node</descr>
						          <value>-301</value>
					</element>
					        <element name="MBTCP_E_NODEEXIST">
						          <descr>Node already existing</descr>
						          <value>-302</value>
					</element>
					        <element name="MBTCP_E_NODENOTEXIST">
						          <descr>Not assigned node</descr>
						          <value>-303</value>
					</element>
					        <element name="MBTCP_E_ADDR">
						          <descr>Invalid node address</descr>
						          <value>-304</value>
					</element>
					        <element name="MBTCP_E_ADDREXIST">
						          <descr>Node address already assigned</descr>
						          <value>-305</value>
					</element>
					        <element name="MBTCP_E_IMGBLOCKINV">
						          <descr>Invalid image block (network configuration error)</descr>
						          <value>-306</value>
					</element>
					        <element name="MBTCP_E_IMGTYPEINV">
						          <descr>Invalid image block type (network configuration error)</descr>
						          <value>-307</value>
					</element>
					        <element name="MBTCP_E_IMGSIZEINV">
						          <descr>Invalid size of image block (network configuration error)</descr>
						          <value>-308</value>
					</element>
					        <element name="MBTCP_E_IMGADDRINV">
						          <descr>Invalid address of image block (network configuration error)</descr>
						          <value>-309</value>
					</element>
					        <element name="MBTCP_E_IMGOVR">
						          <descr>Image memory exausted (network configuration error)</descr>
						          <value>-310</value>
					</element>
					        <element name="MBTCP_E_DATATYPE">
						          <descr>Data type parameter not valid</descr>
						          <value>-311</value>
					</element>
					        <element name="MBTCP_E_IMGBLOCKNOTFOUND">
						          <descr>Image block not found (network configuration error)</descr>
						          <value>-312</value>
					</element>
					        <element name="MBTCP_E_PLCBLOCKNOTFOUND">
						          <descr>Plc datablock not found (network configuration error)</descr>
						          <value>-313</value>
					</element>
					        <element name="MBTCP_E_IMGBROADCAST">
						          <descr>Broadcast not allowed (network configuration error)</descr>
						          <value>-314</value>
					</element>
					        <element name="MBTCP_E_IMGONESHOTINV">
						          <descr>Invalid oneshot variable address (network configuration error)</descr>
						          <value>-315</value>
					</element>
					        <element name="MBTCP_E_PARAMDBVALINV">
						          <descr>Invalid parameter address (network configuration error)</descr>
						          <value>-316</value>
					</element>
					        <element name="MBTCP_E_STOPPED">
						          <descr>Master not running (network configuration error)</descr>
						          <value>-317</value>
					</element>
					        <element name="MBTCP_E_PROTOCOL">
						          <descr>Protocol error</descr>
						          <value>-320</value>
					</element>
					        <element name="MBTCP_E_IDE">
						          <descr>Ide doesn't match</descr>
						          <value>-321</value>
					</element>
					        <element name="MBTCP_E_ILLEGALFUNCTION">
						          <descr>Illegal function</descr>
						          <value>-322</value>
					</element>
					        <element name="MBTCP_E_ILLEGALDATAADDR">
						          <descr>Illegal data address</descr>
						          <value>-323</value>
					</element>
					        <element name="MBTCP_E_ILLEGALDATAVALUE">
						          <descr>Illegal data value</descr>
						          <value>-324</value>
					</element>
					        <element name="MBTCP_E_SLAVEDEVICEFAILURE">
						          <descr>Slave device failure</descr>
						          <value>-325</value>
					</element>
					        <element name="MBTCP_E_ACKNOWLEDGE">
						          <descr>Acknowledge</descr>
						          <value>-326</value>
					</element>
					        <element name="MBTCP_E_SLAVEDEVICEBUSY">
						          <descr>Slave device busy</descr>
						          <value>-327</value>
					</element>
					        <element name="MBTCP_E_MEMORYPARITYERROR">
						          <descr>Memory parity error</descr>
						          <value>-328</value>
					</element>
					        <element name="MBTCP_E_GATEWAYPATHUNAV">
						          <descr>Gateway path unavailable</descr>
						          <value>-329</value>
					</element>
					        <element name="MBTCP_E_GATEWAYDEVICEFAILED">
						          <descr>Gateway target device failed to respond</descr>
						          <value>-330</value>
					</element>
					        <element name="MBTCP_E_TIMEOUT">
						          <descr>Request timed out</descr>
						          <value>-331</value>
					</element>
					        <element name="MBTCP_E_ILLEGALDATAPROTOCOL">
						          <descr>Illegal data value in protocol</descr>
						          <value>-332</value>
					</element>
					        <element name="MBTCP_E_COMMUNICATION">
						          <descr>Communication error</descr>
						          <value>-333</value>
					</element>
					        <element name="MBTCP_E_CONNECTION">
						          <descr>Cannot connect to slave</descr>
						          <value>-334</value>
					</element>
					        <element name="MBTCP_E_SWITCHEDOFF">
						          <descr>Node is switched off</descr>
						          <value>-335</value>
					</element>
					        <element name="MBTCP_E_NOTALLOWEDINTIMEDTASK">
						          <descr>Function cannot be called in a timed task</descr>
						          <value>-336</value>
					</element>
					        <element name="MBTCP_E_NEGATIVEACKNOWLEDGE">
						          <descr>Negative acknowledge</descr>
						          <value>-337</value>
					</element>
					        <element name="MBTCP_E_CHECKSUM">
						          <descr>Checksum</descr>
						          <value>-338</value>
					</element>
					        <element name="MBTCP_E_NETWORK">
						          <descr>Invalid network id specified</descr>
						          <value>-339</value>
					</element>
					        <element name="MBTCP_E_CMDBUFFERSIZEERROR">
						          <descr>Invalid command buffer size error</descr>
						          <value>-340</value>
					</element>
					        <element name="MBTCP_E_CMDBUFFERERROR">
						          <descr>Invalid command buffer error</descr>
						          <value>-341</value>
					</element>
					        <element name="MBTCP_E_CMDBUFFERTOOSMALL">
						          <descr>Buffer too small</descr>
						          <value>-342</value>
					</element>
					        <element name="MBTCP_E_CMDSAMEBUFFER">
						          <descr>Same buffer specified</descr>
						          <value>-343</value>
					</element>
					        <element name="MBTCP_E_CMDPARAMERROR">
						          <descr>Invalid parameter specified</descr>
						          <value>-344</value>
					</element>
					        <element name="MBTCP_E_NOCONNSLOTAVAILABLE">
						          <descr>Connection error</descr>
						          <value>-345</value>
					</element>
					        <element name="MBTCP_E_NOCONNSYSTEMBUSY">
						          <descr>System busy</descr>
						          <value>-346</value>
					</element>
					        <element name="MBTCP_E_REQUESTMISMATCH">
						          <descr>Request mismatch</descr>
						          <value>-347</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
		</enums>
		      <subranges/>
		      <interfaces/>
	</lib>    <lib fullXml="false" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../LLXPlugin_Alarms/PLC/Alarms.pll"><![CDATA[
VAR_GLOBAL 

	{ G:"Global status" }
	sysAlarmCfgOk AT %MB60040.0 : BOOL;	{ DE:"Alarm manager properly configured" }
	sysAlarmActive AT %MB60040.1 : BOOL;	{ DE:"At least one alarm is active (associated condition holds true)" }
	sysAlarmWaitAck AT %MB60040.2 : BOOL;	{ DE:"No alarm is active but at least one alarm is waiting for acknowledgement" }

	{ G:"Counters" }
	sysAlarmCount AT %MW60041.0 : UINT;	{ DE:"Number of active alarms" }

END_VAR


	(*********************)
	(*                   *)
	(*     FUNCTIONS     *)
	(*                   *)
	(*********************)

FUNCTION sysAlarm_InitConfiguration : BOOL
{ DE:"Init configuration phase, specifying configuration name" }

	VAR_INPUT
	name : STRING[ 128 ]; { DE:"Configuration name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_EndConfiguration : BOOL
{ DE:"End configuration phase. After this call, all configuration functions will not work anymore." }

	VAR_INPUT
	dummy : USINT; 
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_GlobalAck : BOOL
{ DE:"This function acknowledges all alarms waiting for acknowledge" }

	VAR_INPUT
		dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_AddAlarmGroup : BOOL
{ DE:"Creates a new alarm group, specifying its unique ID and label." }
	
	VAR_INPUT
		
		id : UINT;	{ DE:"Alarm code" }
		label : STRING[ 128 ];	{ DE:"Alarm ID" }
		
	END_VAR
	
	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmGroup_GetLabel : STRING
{ DE:"This function returns the label associated to the alarm group identified by its ID" }
	
	VAR_INPUT
		id : UINT;	{ DE:"Alarm group ID" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_AddBooleanFlagAlarm : BOOL
{ DE:"Creates a new alarm condition, based on the value of a variable of type BOOL, specifying its name. Returns an handle to the new alarm condition. Must be called between Alarms_InitConfiguration and Alarms_EndConfiguration." }

	VAR_INPUT
		
		code : UINT;	{ DE:"Alarm code" }
		label : STRING[ 128 ];	{ DE:"Alarm ID" }
		ack : ALARM_ACK_TYPE;	{ DE:"Type of alarm acknowledgement (manual or auto)" }
		groupId : UINT;	{ DE:"Alarm group" }
		level : USINT;		{ DE:"Alarm level (the lower the value the higher the alarm priority)" }
		address : DWORD;	{ DE:"Physical address of the variable of type BOOL representing the alarm condition status (if TRUE, alarm is active)" }
		
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetLabel : STRING
{ DE:"This function returns the label associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetTime : BOOL
{ DE:"This function returns date and time of the event associated to the alarm identified by its code" }

	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
		day: @USINT;
		month: @USINT;
		year: @UINT;
		dayOfWeek: @UINT;
		hours: @USINT;
		minutes: @USINT;
		seconds: @USINT;
	END_VAR
	
	{CODE:EMBEDDED}

END_FUNCTION

FUNCTION Alarm_GetGroup : UINT
{ DE:"This function returns the alarm group ID associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetLevel : USINT
{ DE:"This function returns the alarm level associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_GetAckType : ALARM_ACK_TYPE
{ DE:"This function returns the alarm ACK type (AUTO/MANUAL) associated to the alarm identified by its code" }
	
	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_Ack : BOOL
{ DE:"This function acknowledges the alarm identified by its code" }

	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Alarm_IsWaitingForAck : BOOL
{ DE:"This function returns TRUE if the alarm identified by its code is waiting for acknowledgement" }

	VAR_INPUT
		code : UINT;	{ DE:"Alarm code" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_CreateAlarmQuery : ALARM_QUERY_HND
{ DE:"This function creates a new query and returns a handle to it" }

	VAR_INPUT
		dummy : USINT;	{ DE:"Not used" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_Query : ALARM_QUERY_RESULT_HND
{ DE:"This function actually performs the query and returns a handle to the query result" }

	VAR_INPUT
                query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_FilterByGroup : BOOL
{ DE:"This function sets a filter on alarm group" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		groupId : UINT;	{ DE:"Alarm priority value by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_FilterByLevel : BOOL
{ DE:"This function sets a filter on alarm priority" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		level : USINT;	{ DE:"Alarm priority value by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_SortByTime : BOOL
{ DE:"This function sets alarm activation timestamp as the criterion by which query result has to be sorted" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		desc : BOOL;	{ DE:"Ascending/Descending order" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_SortByGroup : BOOL
{ DE:"This function sets the group ID as the criterion by which query result has to be sorted" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		desc : BOOL;	{ DE:"Ascending/Descending order" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_SortByLevel : BOOL
{ DE:"This function sets alarm priority as the criterion by which query result has to be sorted" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
		desc : BOOL;	{ DE:"Ascending/Descending order" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQuery_Release : BOOL
{ DE:"This function release the query: its handle becomes invalid" }

	VAR_INPUT
		query : ALARM_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_GetCount : UINT
{ DE:"This function returns the number of records of the query result" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_SetWindow : BOOL
{ DE:"This function builds a window on the query result" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
		first : UINT;	{ DE:"First element of the window" }
		size : UINT;	{ DE:"Number of elements in the window" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_First : BOOL
{ DE:"This function moves the query result to the first element" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_Current : BOOL
{ DE:"This function returns TRUE if the current element of the query result is valid" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_Next : BOOL
{ DE:"This function moves the query result to the next element" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_GetAlarm : UINT
{ DE:"This function returns the alarm code associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmQueryResult_Release : BOOL
{ DE:"This function release the query result: its handle becomes invalid" }

	VAR_INPUT
		queryResult : ALARM_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_EnableLog : BOOL
{ DE:"This function enables/disables the alarm log" }

	VAR_INPUT
		enable : BOOL;	{ DE:"If TRUE, alarm log is enabled; it is disabled, otherwise" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_ResetLog : BOOL
{ DE:"This function resets the alarm log" }

	VAR_INPUT
		dummy : USINT;	{ DE:"Not used" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION sysAlarm_CreateAlarmLogQuery : ALARM_LOG_QUERY_HND
{ DE:"This function creates a new query and returns a handle to it" }

	VAR_INPUT
		dummy : USINT;	{ DE:"Not used" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_Query : ALARM_LOG_QUERY_RESULT_HND
{ DE:"This function actually performs the query and returns a handle to the query result" }

	VAR_INPUT
                query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_FilterByAlarm : BOOL
{ DE:"This function sets a filter on alarm" }

	VAR_INPUT
		query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
		code : UINT;	{ DE:"Alarm code by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_FilterByGroup : BOOL
{ DE:"This function sets a filter on alarm group" }

	VAR_INPUT
		query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
		groupId : UINT;	{ DE:"Alarm group ID by which query result has to be filtered" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQuery_Release : BOOL
{ DE:"This function release the query: its handle becomes invalid" }

	VAR_INPUT
		query : ALARM_LOG_QUERY_HND;	{ DE:"Handle to the query" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetCount : UINT
{ DE:"This function returns the number of records of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_SetWindow : BOOL
{ DE:"This function builds a window on the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
		first : UINT;	{ DE:"First element of the window" }
		size : UINT;	{ DE:"Number of elements in the window" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_First : BOOL
{ DE:"This function moves the query result to the first element" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_Current : BOOL
{ DE:"This function returns TRUE if the current element of the query result is valid" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_Next : BOOL
{ DE:"This function moves the query result to the next element" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetEvent : ALARM_LOG_EVENT
{ DE:"This function returns the event code associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetAlarm : UINT
{ DE:"This function returns the alarm code associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION AlarmLogQueryResult_GetTime : BOOL
{ DE:"This function returns date and time of the event associated to the current element of the query result" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
		day: @USINT;
		month: @USINT;
		year: @UINT;
		dayOfWeek: @UINT;
		hours: @USINT;
		minutes: @USINT;
		seconds: @USINT;
	END_VAR
	
	{CODE:EMBEDDED}

END_FUNCTION

FUNCTION AlarmLogQueryResult_Release : BOOL
{ DE:"This function release the query result: its handle becomes invalid" }

	VAR_INPUT
		queryResult : ALARM_LOG_QUERY_RESULT_HND;	{ DE:"Handle to the query result" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION


	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	ALARM_QUERY_HND : DWORD;
	ALARM_QUERY_RESULT_HND : DWORD;
	ALARM_LOG_QUERY_HND : DWORD;
	ALARM_LOG_QUERY_RESULT_HND : DWORD;
END_TYPE


	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	ALARM_ACK_TYPE : (
		ACK_MANUAL := 1,
		ACK_AUTO := 2
	);

	ALARM_LOG_EVENT : (
		LOG_EVENT_ACTIVATION := 1,
		LOG_EVENT_DEACTIVATION := 2,
		LOG_EVENT_ACK := 3,
		LOG_EVENT_ACK_ATTEMPT := 4
	);
	
END_TYPE

]]></lib>
      <lib fullXml="false" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../LLXPlugin_Recipes/PLC/Recipes.pll"><![CDATA[
	(*********************)
	(*                   *)
	(*     FUNCTIONS     *)
	(*                   *)
	(*********************)

FUNCTION Recipes_InitConfiguration : BOOL

{ DE:"Init configuration phase, specifying configuration name" }

	VAR_INPUT
	name : STRING; { DE:"Configuration name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_EndConfiguration : BOOL

{ DE:"End configuration phase. After this call, all configuration functions will not work anymore." }

	VAR_INPUT
	dummy : USINT; 
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_GetConfigurationName : STRING

{ DE:"Get configuration name, specified with Recipes_InitConfiguration" }

	VAR_INPUT
	dummy : USINT; 
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_CreateDefinition : RECIPE_DEFINITION_HANDLE

{ DE:"Creates a new recipe definition, specifying its name. Returns an handle to the new recipe. Must be called between Recipes_InitConfiguration and Recipes_EndConfiguration." }

	VAR_INPUT
	name : STRING; { DE:"New recipe definition name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_GetDefinition : RECIPE_DEFINITION_HANDLE

{ DE:"Returns an handle to an existing recipe definition, searching by its name." }

	VAR_INPUT
	name : STRING; { DE:"Recipe definition name to search" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_AddVariable : BOOL
{ DE:"(DEPRECATED) Adds a new variable to a recipe definition. Must be called between Recipes_InitConfiguration and Recipes_EndConfiguration." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Variable name" }
	type : RECIPE_DATA_TYPE; { DE:"Type of the variable" }
	address : DWORD; { DE:"Variable physical address" }
	strsize : DWORD; { DE:"Variable size for STRINGs" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION Recipes_AddNewVariable : BOOL
{ DE:"Adds a new variable to a recipe definition. Must be called between Recipes_InitConfiguration and Recipes_EndConfiguration." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Variable name" }
	type : RECIPE_DATA_TYPE; { DE:"Type of the variable" }
	address : DWORD; { DE:"Variable physical address" }
	strsize : DWORD; { DE:"Variable size for STRINGs" }
	format : STRING; { DE:"Format (for preview only)" }
	description : STRING; { DE:"Variable description" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION



FUNCTION Recipes_Load : RECIPE_RESULT

{ DE:"Loads values saved in the specified recipe in the corresponding variables. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_Save : RECIPE_RESULT

{ DE:"Saves values saved to the specified recipe with the corresponding variables. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_Delete : RECIPE_RESULT

{ DE:"Delete the specified recipe from disk. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION



FUNCTION Recipes_QueueLoadRequest : RECIPE_REQUEST_HANDLE

{ DE:"Queues a load recipe request, that will be executed asynchronously. Returns an handle of the operation, that can be used to poll for result and termination with RecipeRequest_GetStatus or just closed with RecipeRequest_CloseHandle (that must be called in any case to avoid memory leaks)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_QueueSaveRequest : RECIPE_REQUEST_HANDLE

{ DE:"Queues a save recipe request, that will be executed asynchronously. Returns an handle of the operation, that can be used to poll for result and termination with RecipeRequest_GetStatus or just closed with RecipeRequest_CloseHandle (that must be called in any case to avoid memory leaks)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_QueueDeleteRequest : RECIPE_REQUEST_HANDLE

{ DE:"Queues a delete recipe request, that will be executed asynchronously. Returns an handle of the operation, that can be used to poll for result and termination with RecipeRequest_GetStatus or just closed with RecipeRequest_CloseHandle (that must be called in any case to avoid memory leaks)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION


FUNCTION RecipeRequest_GetStatus : RECIPE_RESULT

{ DE:"Returns the execution or termination state of the specified request handle, returned by Recipes_Queue*Request functions family." }

	VAR_INPUT
	recipeRequest : RECIPE_REQUEST_HANDLE; { DE:"Recipe request handle" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION RecipeRequest_CloseHandle : BOOL

{ DE:"Closes the specified request handle. After this call the handle and RecipeRequest_GetStatus can not be used anymore" }

	VAR_INPUT
	recipeRequest : RECIPE_REQUEST_HANDLE; { DE:"Recipe request handle" }
	END_VAR

	{ CODE:EMBEDDED }

END_FUNCTION

FUNCTION Recipes_GetName : STRING
{ DE:"Gets the name of the specified recipe" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_First : BOOL
{ DE:"Goes to first recipe definition to iterate on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_Current : BOOL
{ DE:"Checks if there is a valid recipe definition to iterate on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_Next : BOOL
{ DE:"Goes to next recipe definition to iterate on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipesDefs_GetHandle : RECIPE_DEFINITION_HANDLE
{ DE:"Gets the handle of current recipe while iterating on them" }

	VAR_INPUT
	dummy : USINT;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION Recipes_GetFileList : RECIPE_FILELIST_HANDLE
{ DE:"Gets the list of existing files for the specified recipe" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_First : BOOL
{ DE:"Goes to first file in the list to iterate on them" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_Next : BOOL
{ DE:"Goes to next file in the list to iterate on them" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_Current : BOOL
{ DE:"Checks if there is a valid file in the list to iterate on them" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_GetFileName : STRING
{ DE:"Gets the file name of the current file in the list" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeFileList_CloseHandle : BOOL
{ DE:"Closes the specified list of files of the recipe" }

	VAR_INPUT
	filelist : RECIPE_FILELIST_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION Recipes_LoadPreview : RECIPE_RESULT
{ DE:"Loads values saved in the specified recipe for preview only. Waits for the operation to be executed and returns its exit code." }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE; { DE:"Recipe definition handle" }
	name : STRING; { DE:"Recipe name" }
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION RecipeDef_First : BOOL
{ DE:"Goes to first variabile in the recipe definition to iterate on them" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_Next : BOOL
{ DE:"Goes to next variabile in the recipe definition to iterate on them" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_Current : BOOL
{ DE:"Checks if there is a valid variabile in the recipe definition to iterate on them" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_GetVarName : STRING
{ DE:"Gets the name of the current variable in the recipe definition" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_GetPreviewValue : STRING
{ DE:"Gets the preview value of the current variable in the recipe definition ('---' if the preview value is not valid)" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION

FUNCTION RecipeDef_GetDescription : STRING
{ DE:"Gets the description of the current variable in the recipe definition" }

	VAR_INPUT
	definition : RECIPE_DEFINITION_HANDLE;
	END_VAR

	{ CODE:EMBEDDED }
END_FUNCTION



	(************************)
	(*                      *)
	(*      TYPEDEFS        *)
	(*                      *)
	(************************)

TYPE
	RECIPE_DEFINITION_HANDLE : DWORD; 
	RECIPE_REQUEST_HANDLE : DWORD; 
	RECIPE_FILELIST_HANDLE : DWORD; 
END_TYPE

	(************************)
	(*                      *)
	(*        ENUMS         *)
	(*                      *)
	(************************)

TYPE

	RECIPE_DATA_TYPE: ( 
		recUndefined := 19,
		recBool := 1,
		recSInt := 2,
		recInt := 5,
		recDInt := 9,
		recLInt := 12,
		recUSInt := 3,
		recUInt := 6,
		recUDInt := 10,
		recULInt := 13,
		recReal := 15,
		recLReal := 16,
		recByte := 4,
		recWord := 7,
		recDWord := 11,
		recLWord := 14,
		recString := 17,
		recWString := 22
	);

	RECIPE_RESULT: (
		RECIPE_OK := 0,
		RECIPE_INPROGRESS := 1,
		RECIPE_ERROR_IO := 2,
		RECIPE_ERROR_PARAMS := 3,
		RECIPE_ERROR_NOFILE := 4,
		RECIPE_ERROR_INVALIDTASK := 5
	);
	
END_TYPE

]]></lib>
      <lib fullXml="false" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/ ../Libraries/COPM.pll"><![CDATA[]]></lib>
      <lib fullXml="true" link="true" name="/LLWeb/AxelCatalog/Catalog/RaspPI_2p2/RaspPI/../Libraries/MQTTLib.plclib" version="2.0.5">
		      <descr/>
		      <libWorkspace>
			      <folder name="MQTTLib">
				        <GlobalVars name="Variables"/>
				        <Pou name="MQTT_ConnectionClose"/>
				        <Pou name="MQTT_ConnectionOpen"/>
				        <Pou name="MQTT_ConnectionOpen2"/>
				        <Definition name="MQTT_DataType"/>
				        <Definition name="MQTT_Error"/>
				        <Pou name="MQTT_GetConnErrorState"/>
				        <Pou name="MQTT_Ping"/>
				        <Pou name="MQTT_Publish"/>
				        <Pou name="MQTT_Subscribe"/>
				        <Definition name="MQTTEndpointStatus"/>
				        <Definition name="MQTTEngineStatus"/>
				        <Pou name="MQTT_EngineConnectionOpen"/>
				        <Pou name="MQTT_EngineConnectionClose"/>
				        <Pou name="MQTT_EnginePublishTopic"/>
			</folder>
		</libWorkspace>
		      <globalVars>
			      <group excludeFromBuild="FALSE" name="Variables">
				        <var dim0="100" name="sysMQTTEndpointStatus" type="MQTTEndpointStatus">
					        <descr>Endpoint State</descr>
					        <address index="60099" subIndex="0" type="M" typeVar="B"/>
				</var>
				        <var name="sysMQTTEngineStatus" type="MQTTEngineStatus">
					        <descr>Engine Global State</descr>
					        <address index="60098" subIndex="0" type="M" typeVar="B"/>
				</var>
				        <var length="1024" name="sysMQTTLastJsonSent" type="STRING">
					        <descr>Last Json Payload Sent</descr>
					        <address index="60200" subIndex="0" type="M" typeVar="B"/>
				</var>
			</group>
		</globalVars>
		      <retainVars/>
		      <constantVars/>
		      <iecVarsDeclaration>
			      <group name="Variables">
				        <iecDeclaration active="FALSE"/>
			</group>
		</iecVarsDeclaration>
		      <functions>
			      <function creationDate="1592406764" excludeFromBuild="FALSE" lastModifiedDate="1593507208" name="MQTT_ConnectionClose" version="1.0.0">
				        <title>Connection Close</title>
				        <descr>Close an MQTT Connection</descr>
				        <returnValue>MQTT_Error</returnValue>
				        <vars>
					        <inputVars>
						          <var name="connHandle" type="INT">
							          <descr>Connection Handle</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="1592406585" excludeFromBuild="FALSE" lastModifiedDate="1635326280" name="MQTT_ConnectionOpen" version="1.0.0">
				        <title>Open MQTT Connection</title>
				        <descr>Estabilish a connection with a mqtt broker,
needs username, password and a unique connection name.
It returns a connection handle ( &gt;= 0), if some parameter is invalid the function returns an handle &lt;0 which is not valid.</descr>
				        <returnValue>INT</returnValue>
				        <vars>
					        <inputVars>
						          <var name="server" type="STRING">
							          <descr>server : port</descr>
						</var>
						          <var name="username" type="STRING">
							          <descr>Username (&lt;255 chars)</descr>
						</var>
						          <var name="password" type="STRING">
							          <descr>Password (&lt;255 chars)</descr>
						</var>
						          <var name="clientname" type="STRING">
							          <descr>Unique client name (&lt;255 chars)</descr>
						</var>
						          <var name="tls" type="BOOL">
							          <descr>Enable TLS communication</descr>
						</var>
						          <var name="commonNameServer" type="STRING">
							          <descr>Required for TLS communication</descr>
						</var>
						          <var name="timeoutTcp" type="UDINT">
							          <descr>Timeout for TCP operations</descr>
						</var>
						          <var name="timeoutMqtt" type="UDINT">
							          <descr>Timeout for MQTT operations</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="1592406585" excludeFromBuild="FALSE" lastModifiedDate="1650977825" name="MQTT_ConnectionOpen2" version="1.0.0">
				        <title>Open MQTT Connection</title>
				        <descr>Estabilish a connection with a mqtt broker,
needs username, password and a unique connection name.
It returns a connection handle ( &gt;= 0), if some parameter is invalid the function returns an handle &lt;0 which is not valid.</descr>
				        <returnValue>INT</returnValue>
				        <vars>
					        <inputVars>
						          <var name="server" type="STRING">
							          <descr>server : port</descr>
						</var>
						          <var name="username" type="STRING">
							          <descr>Username (&lt;255 chars)</descr>
						</var>
						          <var name="password" type="STRING">
							          <descr>Password (&lt;255 chars)</descr>
						</var>
						          <var name="clientname" type="STRING">
							          <descr>Unique client name (&lt;255 chars)</descr>
						</var>
						          <var name="tls" type="BOOL">
							          <descr>Enable TLS communication</descr>
						</var>
						          <var name="commonNameServer" type="STRING">
							          <descr>Required for TLS communication</descr>
						</var>
						          <var name="timeoutTcp" type="UDINT">
							          <descr>Timeout for TCP operations</descr>
						</var>
						          <var name="timeoutMqtt" type="UDINT">
							          <descr>Timeout for MQTT operations</descr>
						</var>
						          <var name="clientCert" type="STRING">
							          <descr>Optional client certificate filename</descr>
						</var>
						          <var name="clientKey" type="STRING">
							          <descr>Optional client private key associated to clientCert</descr>
						</var>
						          <var name="caCert" type="STRING">
							          <descr>Optional Root CA certificate filename to validate the broker</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="1592411969" excludeFromBuild="FALSE" lastModifiedDate="1593507208" name="MQTT_GetConnErrorState" version="1.0.0">
				        <title>Get state of an mqtt connection</title>
				        <descr>Open connections gets MQTTE_Ok</descr>
				        <returnValue>MQTT_Error</returnValue>
				        <vars>
					        <inputVars>
						          <var name="connHandle" type="INT">
							          <descr>Connection Handle</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="1635323245" excludeFromBuild="FALSE" lastModifiedDate="1635323432" name="MQTT_EngineConnectionOpen" version="1.0.0">
				        <returnValue>MQTT_Error</returnValue>
				        <vars>
					        <inputVars>
						          <var name="endpoint_id" type="UINT">
							          <descr>The ID of the configured endpoint to be activated</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="1635323400" excludeFromBuild="FALSE" lastModifiedDate="1635323432" name="MQTT_EngineConnectionClose" version="1.0.0">
				        <returnValue>MQTT_Error</returnValue>
				        <vars>
					        <inputVars>
						          <var name="endpoint_id" type="UINT">
							          <descr>The ID of the configured endpoint to be closed</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
			      <function creationDate="1635323473" excludeFromBuild="FALSE" lastModifiedDate="1635323715" name="MQTT_EnginePublishTopic" version="1.0.0">
				        <returnValue>MQTT_Error</returnValue>
				        <vars>
					        <inputVars>
						          <var name="endpoint_id" type="UINT">
							          <descr>The ID of the endpoint</descr>
						</var>
						          <var name="row_line" type="UINT">
							          <descr>The table line number of the topic</descr>
						</var>
					</inputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <sourceCode type="EMBEDDED"/>
			</function>
		</functions>
		      <functionBlocks>
			      <functionBlock creationDate="1591257225" excludeFromBuild="FALSE" lastModifiedDate="1593507208" name="MQTT_Ping" version="1.0.0">
				        <title>Ping</title>
				        <descr>Ping a broker to check the connection state</descr>
				        <vars>
					        <inputVars>
						          <var name="connHandle" type="INT">
							          <descr>Connection Handle</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="error" type="MQTT_Error">
							          <descr>Error code</descr>
						</var>
						          <var name="done" type="BOOL">
							          <descr>Done flag</descr>
						</var>
						          <var name="busy" type="BOOL">
							          <descr>Busy flag</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1591257472" excludeFromBuild="FALSE" lastModifiedDate="1635321850" name="MQTT_Publish" version="1.0.0">
				        <title>Publish</title>
				        <descr>Publish a single mqtt topic value</descr>
				        <vars>
					        <inputVars>
						          <var name="connHandle" type="INT">
							          <descr>Connection Handle</descr>
						</var>
						          <var length="255" name="topic" type="STRING">
							          <descr>Single topic</descr>
						</var>
						          <var name="dataType" type="MQTT_DataType">
							          <descr>Data Type</descr>
						</var>
						          <var name="dataSize" type="UINT">
							          <descr>Size needed for type MQTTDT_RAW</descr>
							          <initValue>0</initValue>
						</var>
						          <var name="dataInBool" type="BOOL">
							          <descr>Input boolean value</descr>
						</var>
						          <var name="dataInInt" type="ULINT">
							          <descr>Input int value</descr>
						</var>
						          <var name="dataInReal" type="LREAL">
							          <descr>Input real value</descr>
						</var>
						          <var length="255" name="dataInString" type="STRING">
							          <descr>Input string value</descr>
						</var>
						          <var name="dataInAddr" type="ULINT">
							          <descr>Input RAW address</descr>
							          <initValue>0</initValue>
						</var>
						          <var name="QoS" type="USINT">
							          <descr>Quality of Service (0,1,2)</descr>
							          <initValue>0</initValue>
						</var>
						          <var name="retained" type="BOOL"/>
						          <var name="timeout_s" type="UINT">
							          <descr>Optional MQTT timeout</descr>
							          <initValue>0</initValue>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="error" type="MQTT_Error">
							          <descr>Error code</descr>
						</var>
						          <var name="done" type="BOOL">
							          <descr>Done flag</descr>
						</var>
						          <var name="busy" type="BOOL">
							          <descr>Busy flag</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
			      <functionBlock creationDate="1591258468" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" lastModifiedDate="1633361275" name="MQTT_Subscribe" version="1.0.0">
				        <title>Subscribe</title>
				        <descr>Subscribe to mqtt single topic</descr>
				        <vars>
					        <inputVars>
						          <var name="connHandle" type="INT">
							          <descr>Connection Handle</descr>
						</var>
						          <var length="255" name="topic" type="STRING">
							          <descr>Single topic</descr>
						</var>
						          <var name="QoS" type="USINT">
							          <descr>Subscribe Quality of Service (upper bound for message QoS)</descr>
							          <initValue>0</initValue>
						</var>
						          <var name="dataType" type="MQTT_DataType">
							          <descr>Data type</descr>
						</var>
						          <var name="dataSize" type="UINT">
							          <descr>Data size needed for MQTTDT_RAW</descr>
						</var>
						          <var name="dataOutAddr" type="ULINT">
							          <descr>Data address for MQTTDT_RAW</descr>
						</var>
						          <var name="stop" type="BOOL">
							          <descr>Stop/Unsubscribe command</descr>
						</var>
					</inputVars>
					        <outputVars>
						          <var name="error" type="MQTT_Error">
							          <descr>Error code</descr>
						</var>
						          <var name="done" type="BOOL">
							          <descr>Done flag</descr>
						</var>
						          <var name="busy" type="BOOL">
							          <descr>Busy flag</descr>
						</var>
						          <var name="newData" type="BOOL">
							          <descr>New data flag</descr>
						</var>
						          <var name="dischargedValues" type="BOOL">
							          <descr>Overflow flag</descr>
						</var>
						          <var name="dataOutBool" type="BOOL">
							          <descr>Output boolean value</descr>
						</var>
						          <var name="dataOutInt" type="LINT">
							          <descr>Output int value</descr>
						</var>
						          <var name="dataOutReal" type="LREAL">
							          <descr>Output real value</descr>
						</var>
						          <var length="255" name="dataOutString" type="STRING">
							          <descr>Output string value</descr>
						</var>
					</outputVars>
				</vars>
				        <iecDeclaration active="FALSE"/>
				        <interfaces/>
				        <methods/>
				        <sourceCode type="EMBEDDED"/>
			</functionBlock>
		</functionBlocks>
		      <programs/>
		      <macros/>
		      <structs>
			      <struct name="MQTTEndpointStatus" version="1.0.0">
				        <vars>
					        <var name="configured" type="BOOL">
						          <descr>Endpoint is correctly configured</descr>
					</var>
					        <var name="active" type="BOOL">
						          <descr>Endpoint active</descr>
					</var>
					        <var name="running" type="BOOL">
						          <descr>Endpoint running</descr>
					</var>
					        <var name="handle" type="INT">
						          <descr>Connection handle</descr>
					</var>
					        <var name="connectionState" type="MQTT_Error">
						          <descr>Connection state</descr>
					</var>
					        <var name="lastErrorPublish" type="MQTT_Error">
						          <descr>Last error in publish communication</descr>
					</var>
					        <var name="lastErrorSubscribe" type="MQTT_Error">
						          <descr>Last error in subscribe communication</descr>
					</var>
					        <var name="numPublishItems" type="UDINT">
						          <descr>Number of items configured</descr>
					</var>
					        <var name="numSubscribeItems" type="UDINT">
						          <descr>Number of items configured</descr>
					</var>
					        <var name="errorPublishIdx" type="UDINT">
						          <descr>Row index of the last publish item in error</descr>
					</var>
					        <var name="errorSubscribeIdx" type="UDINT">
						          <descr>Row index of the last subscribe item in error</descr>
					</var>
				</vars>
				        <iecDeclaration active="FALSE"/>
			</struct>
			      <struct name="MQTTEngineStatus" version="1.0.0">
				        <vars>
					        <var name="configured" type="BOOL">
						          <descr>Engine configured</descr>
					</var>
					        <var name="network_ok" type="BOOL">
						          <descr>All the active endpoints communicating</descr>
					</var>
					        <var name="numConfiguredEndpoints" type="UDINT">
						          <descr>Number of configured endpoints</descr>
					</var>
					        <var name="numActiveEndpoints" type="UDINT">
						          <descr>Number of endpoints activated</descr>
					</var>
					        <var name="numRunningEndpoints" type="UDINT">
						          <descr>Number of endpoints actually running</descr>
					</var>
					        <var name="ErrorCode" type="DINT">
						          <descr>Global main error code</descr>
					</var>
				</vars>
				        <iecDeclaration active="FALSE"/>
			</struct>
		</structs>
		      <typedefs/>
		      <enums>
			      <enum name="MQTT_DataType" version="1.0.0">
				        <elements>
					        <element name="MQTTDT_BOOL">
						          <value>0</value>
					</element>
					        <element name="MQTTDT_SINT">
						          <value>1</value>
					</element>
					        <element name="MQTTDT_USINT">
						          <value>2</value>
					</element>
					        <element name="MQTTDT_INT">
						          <value>3</value>
					</element>
					        <element name="MQTTDT_UINT">
						          <value>4</value>
					</element>
					        <element name="MQTTDT_DINT">
						          <value>5</value>
					</element>
					        <element name="MQTTDT_UDINT">
						          <value>6</value>
					</element>
					        <element name="MQTTDT_LINT">
						          <value>7</value>
					</element>
					        <element name="MQTTDT_ULINT">
						          <value>8</value>
					</element>
					        <element name="MQTTDT_REAL">
						          <value>9</value>
					</element>
					        <element name="MQTTDT_LREAL">
						          <value>10</value>
					</element>
					        <element name="MQTTDT_STRING">
						          <value>11</value>
					</element>
					        <element name="MQTTDT_RAW">
						          <value>12</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
			      <enum name="MQTT_Error" version="1.0.0">
				        <title>MQTT error codes</title>
				        <elements>
					        <element name="MQTTE_Ok">
						          <descr>No error</descr>
						          <value>0</value>
					</element>
					        <element name="MQTTE_ConnectionError">
						          <descr>Connection Error</descr>
						          <value>1</value>
					</element>
					        <element name="MQTTE_InvalidPar">
						          <descr>Invalid Par</descr>
						          <value>2</value>
					</element>
					        <element name="MQTTE_ConnectionClosed">
						          <descr>Connection Closed</descr>
						          <value>3</value>
					</element>
					        <element name="MQTTE_ConnectionOpening">
						          <descr>Connection Opening</descr>
						          <value>4</value>
					</element>
					        <element name="MQTTE_ConnectionClosing">
						          <descr>Connection Closing</descr>
						          <value>5</value>
					</element>
					        <element name="MQTTE_PingResourcesBusy">
						          <descr>Ping Resources Busy</descr>
						          <value>6</value>
					</element>
					        <element name="MQTTE_PublishResourcesBusy">
						          <descr>Publish Resources Busy</descr>
						          <value>7</value>
					</element>
					        <element name="MQTTE_SubscribeResourcesBusy">
						          <descr>Subscribe Resources Busy</descr>
						          <value>8</value>
					</element>
					        <element name="MQTTE_InvalidTopic">
						          <descr>Invalid Topic</descr>
						          <value>9</value>
					</element>
					        <element name="MQTTE_TlsError">
						          <descr>TLS Error</descr>
						          <value>10</value>
					</element>
					        <element name="MQTTE_MsgTimeout">
						          <descr>Timeout of expected MQTT message (QoS &gt; 0)</descr>
						          <value>11</value>
					</element>
					        <element name="MQTTE_ConnectionFailed">
						          <descr>Connection will not be connected automatically, because of retries expired</descr>
						          <value>12</value>
					</element>
				</elements>
				        <iecDeclaration active="FALSE"/>
			</enum>
		</enums>
		      <subranges/>
		      <interfaces/>
	</lib>  </libraries>
    <aux/>
    <workspace>
			  <root name="RaspPI_PlcSample" nextID="1155">
				    <folder id="1" name="Programs">
					    <Pou id="3" name="PidControl"/>
					    <Pou id="4" name="PidModeSelector"/>
					    <Pou id="5" name="Loops"/>
					    <Pou id="6" name="Init"/>
					    <Pou id="1028" name="LadderLogic"/>
				</folder>
				    <folder id="7" name="Function blocks">
					    <Pou id="8" name="LowPassFilter"/>
				</folder>
				    <folder id="9" name="Functions">
					    <Pou id="10" name="RotateBit"/>
				</folder>
				    <folder id="11" name="Global variables">
					    <folder id="12" name="Automatic variables">
						      <GlobalVars id="17" name="Counters_and_timers"/>
						      <GlobalVars id="24" name="PID"/>
						      <GlobalVars id="37" name="IO"/>
						      <GlobalVars id="57" name="Ungrouped_vars"/>
					</folder>
					    <folder id="14" name="Constants"/>
					    <folder id="15" name="Retain variables"/>
				</folder>
				    <GlobalVars id="102" name="Counters_and_timers_1"/>
				    <GlobalVars id="194" name="Counters_and_timers_2"/>
				    <GlobalVars id="241" name="Counters_and_timers_3"/>
			</root>
		</workspace></sources>
  <codegen allocateUnusedVariables="false" checkArrayBounds="false" checkDivisionByZero="true" checkIndexType="false" checkInterfaces="false" checkPointers="1" checkReferences="false" checkStackOverflow="false" crossReference="true" crossReferenceOptions="0x3000001D" customTargetBINFileName="RaspPI_PlcSample.bin" customTargetTDSFileName="RaspPI_PlcSample_debug.bin" customTargetTSCFileName="RaspPI_PlcSample_source.bin" enablePreprocessDirectives="false" generateCustomFilesName="false" initFunVarsWithZero="false" ioVarsAsReferences="true" listing="false" saveEXPFile="false" saveEXPFileLibraries="false" saveTargetFiles="false" symMap="true" unusedObjs="true" waitExtension="false" warningEnable="true">
    <disabledWarnings/>
    <applicationDataBlocks/>
  </codegen>
  <debug autoSaveWatchList="false" watchFBLocalVars="false" watchMaxArray="20" watchRefresh="20" watchVarRefresh="0"/>
  <editor useOldGridSize="false"/>
  <userDef>
    <release>PLCSample</release>
    <author></author>
    <note></note>
    <version></version>
    <password disabled="true"></password>
  </userDef>
  <downloadSequence debugSymbols="onPLCApplicationDownload" sourceCode="onPLCApplicationDownload"/>
  <commands>
    <postbuild></postbuild>
    <postdown></postdown>
    <predown></predown>
  </commands>
  <resources>
    <configuration template="LogicLab.pct" version="1">
			  <data protocol="root">
				    <project_config nextID="4">
					    <datacomment/>
				</project_config>
				    <RaspPI_2p2 caption="Raspberry Pi" name="Raspberry Pi" template="RaspPI_2p2\RaspPI\RaspPI_2p2.pct" version="15">
					    <config GPIOConfig="PIFace" databaseDefinitionMode="0" model="3">
						      <params/>
						      <paramsRO/>
						      <menus/>
						      <ioMappings>
							      <ioMapping IOType="1" id="0" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="1" id="1" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="1" id="2" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="1" id="3" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="1" id="4" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="1" id="5" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="1" id="6" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="1" id="7" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="8" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="9" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="10" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="11" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="12" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="13" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="14" resistor="0">
								        <label/>
							</ioMapping>
							      <ioMapping IOType="2" id="15" resistor="0">
								        <label/>
							</ioMapping>
						</ioMappings>
						
      <!--
					<ioMappings_AI>
						<ioMapping id="0"> <label/> </ioMapping>
						<ioMapping id="1"> <label/> </ioMapping>
						<ioMapping id="2"> <label/> </ioMapping>
						<ioMapping id="3"> <label/> </ioMapping>
					</ioMappings_AI>
					<ioMappings_AO>
						<ioMapping id="0"> <label/> </ioMapping>
						<ioMapping id="1"> <label/> </ioMapping>
					</ioMappings_AO>
-->
						      <LLXPlugin_Recipes template="RaspPI_2p2\LLXPlugin_Recipes\LLXPlugin_Recipes.PCT" version="2"/>
						      <LLXPlugin_Alarms enableLog="false" logSize="100" template="RaspPI_2p2\LLXPlugin_Alarms\LLXPlugin_Alarms.PCT" version="1">
							      <alarmGroups/>
							      <alarms/>
						</LLXPlugin_Alarms>
					    </config>
					    <CANopen baudRate="500000" dyncfgMasterBaudRate="false" dyncfgMasterNodeID="false" hbTime="0" masterBaudRateVar="" masterNodeIDVar="" mode="0" nodeID="127" protocol="" slaveCfgCOBIDAutoAssignment="1" slaveCfgGranularity="8" slaveCfgMaxRPDONum="8" slaveCfgMaxTPDONum="8" slaveConsumerHeartbeatTime="0" slaveDeviceType="301" slaveGuardTime="200" slaveLifeTimeFactor="3" slaveManufacturerDeviceName="" slaveManufacturerHardwareVer="" slaveManufacturerSoftwareVer="" slaveNodeID="1" slaveProducerHeartbeatTime="0" slaveProductCode="0" slaveRevisionNumber="0" slaveSerialNumber="0" slaveSyncCOBID="128" slaveSyncCycle="0" slaveVendorID="0" syncCOBID="128" syncCycle="0"/>
					    <RS485 COMdev="/dev/ttyUSB0" baudRate="38400" mode="0" protocol="" serialMode="none,8,1" slaveAddress="1"/>
					    <Ethernet enableMaster="0" enableSlave="0" enableSlaveRtuGateway="0" protocol="" rtuGatewayDefaultTimeout="100" slavePort="502"/>
					    <LLXPlugin_LLSymbolsRemote masterEnabled="1" template="%TARGETPCTPATH%\..\LLXPlugin_LLSymbolsRemote\LLXPlugin_LLSymbolsRemote.pct" version="1"/>
					    <webmenus template="%TARGETPCTPATH%\..\LLXPlugin_WebServer\LLXPlugin_WebServer.pct" version="2"/>
					    <MQTT enabled="1" template="%TARGETPCTPATH%\..\LLXPlugin_MQTT\LLXPlugin_MQTT.pct" version="3"/>
				    </RaspPI_2p2>
			  </data>
		  </configuration>
  </resources>
</plcProject>
